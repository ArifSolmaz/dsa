<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 14: Course Review & Final Practice | DSA Course</title>
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>
    <script type="module">
        // Wait for PyScript to be ready
        const pyReady = new Promise((resolve) => {
            const check = setInterval(() => {
                if (typeof pyscript !== 'undefined' && pyscript.interpreter) {
                    clearInterval(check);
                    resolve();
                }
            }, 100);
            // Timeout after 15 seconds
            setTimeout(() => { clearInterval(check); resolve(); }, 15000);
        });
        window.pyReady = pyReady;
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Crimson Pro', Georgia, serif;
            font-size: 19px;
            background: #faf9f7;
            color: #2c2c2c; 
            line-height: 1.8;
        }
        
        .topbar {
            position: sticky;
            top: 0;
            background: #1a1a2e;
            color: white;
            padding: 12px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }
        .topbar .title { font-family: system-ui, sans-serif; font-size: 0.9rem; font-weight: 500; }
        .topbar a { font-family: system-ui, sans-serif; color: white; text-decoration: none; font-size: 0.85rem; padding: 6px 14px; background: rgba(255,255,255,0.1); border-radius: 5px; }
        .topbar a:hover { background: rgba(255,255,255,0.2); }
        
        .book { max-width: 750px; margin: 0 auto; padding: 60px 40px 100px; }
        
        .chapter-header { text-align: center; padding: 50px 0 60px; border-bottom: 1px solid #ddd; margin-bottom: 50px; }
        .chapter-num { font-family: system-ui, sans-serif; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 3px; color: #7c3aed; margin-bottom: 15px; }
        .chapter-header h1 { font-size: 2.8rem; font-weight: 600; color: #1a1a2e; margin-bottom: 15px; letter-spacing: -0.5px; }
        .chapter-header .subtitle { font-style: italic; color: #666; font-size: 1.1rem; }
        
        h2 { font-size: 1.6rem; font-weight: 600; color: #1a1a2e; margin: 60px 0 25px; padding-top: 30px; border-top: 1px solid #e5e5e5; }
        h2:first-of-type { border-top: none; margin-top: 0; padding-top: 0; }
        h3 { font-size: 1.25rem; font-weight: 600; color: #333; margin: 40px 0 15px; }
        h4 { font-size: 1.05rem; font-weight: 600; color: #555; margin: 30px 0 12px; }
        
        p { margin: 0 0 20px; text-align: justify; hyphens: auto; }
        ul, ol { margin: 20px 0 25px 30px; }
        li { margin: 10px 0; }
        
        code { font-family: 'JetBrains Mono', monospace; font-size: 0.85em; background: #f0eeeb; padding: 2px 6px; border-radius: 3px; color: #7c3aed; }
        .term { font-weight: 600; color: #1a1a2e; }
        
        .definition { background: #f8f7f5; border-left: 4px solid #7c3aed; padding: 20px 25px; margin: 30px 0; }
        .definition-title { font-family: system-ui, sans-serif; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px; color: #7c3aed; margin-bottom: 8px; font-weight: 600; }
        .definition p { margin: 0; }
        
        .margin-note { background: #fffbeb; border: 1px solid #fcd34d; padding: 15px 18px; margin: 25px 0; border-radius: 4px; font-size: 0.9rem; }
        .margin-note::before { content: "ğŸ’¡ "; }
        
        .important { background: #fef2f2; border: 1px solid #fca5a5; padding: 15px 18px; margin: 25px 0; border-radius: 4px; font-size: 0.9rem; }
        .important::before { content: "âš ï¸ "; }
        
        .example { background: #fafafa; border: 1px solid #e5e5e5; border-radius: 6px; padding: 25px; margin: 30px 0; }
        .example-title { font-family: system-ui, sans-serif; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: #666; margin-bottom: 15px; font-weight: 600; }
        
        .code-figure { margin: 35px 0; border: 1px solid #e0e0e0; border-radius: 6px; overflow: hidden; background: #1e1e2e; }
        .code-figure-header { background: #28283c; padding: 10px 18px; display: flex; justify-content: space-between; align-items: center; }
        .code-figure-label { font-family: system-ui, sans-serif; font-size: 0.75rem; color: #a0a0b0; text-transform: uppercase; letter-spacing: 0.5px; }
        .code-figure-run { font-family: system-ui, sans-serif; background: #7c3aed; color: white; border: none; padding: 5px 14px; border-radius: 4px; font-size: 0.8rem; cursor: pointer; font-weight: 500; }
        .code-figure-run:hover { background: #6d28d9; }
        .code-figure textarea { width: 100%; min-height: 100px; padding: 18px; background: #1e1e2e; color: #e0e0e0; border: none; font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; line-height: 1.6; resize: vertical; }
        .code-figure textarea:focus { outline: none; }
        .code-figure-output { display: none; border-top: 1px solid #28283c; padding: 15px 18px; background: #161622; color: #4ade80; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; white-space: pre-wrap; }
        .code-figure-output.show { display: block; }
        .code-figure-caption { background: #f8f8f8; padding: 12px 18px; font-size: 0.85rem; color: #666; border-top: 1px solid #e0e0e0; }
        .code-figure-caption strong { color: #333; }
        
        .summary { background: linear-gradient(135deg, #7c3aed10, #7c3aed05); border: 1px solid #7c3aed30; border-radius: 8px; padding: 25px 30px; margin: 40px 0; }
        .summary-title { font-family: system-ui, sans-serif; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: #7c3aed; margin-bottom: 12px; font-weight: 600; }
        .summary ul { margin: 0; }
        
        .exercise { background: #f0fdf4; border: 1px solid #bbf7d0; border-radius: 8px; padding: 25px 30px; margin: 40px 0 20px; }
        .exercise-title { font-family: system-ui, sans-serif; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: #16a34a; margin-bottom: 12px; font-weight: 600; }
        .exercise p { margin: 0; }
        .exercise .answer { margin-top: 12px; font-size: 0.9rem; color: #166534; }
        
        table { width: 100%; border-collapse: collapse; margin: 25px 0; font-size: 0.95rem; }
        th, td { border: 1px solid #ddd; padding: 12px 15px; text-align: left; }
        th { background: #f5f5f5; font-weight: 600; }
        
        .submit-section { background: #1a1a2e; color: white; padding: 40px; border-radius: 10px; margin-top: 60px; }
        .submit-section h2 { color: white; border: none; margin: 0 0 20px; padding: 0; font-size: 1.4rem; }
        .submit-section p { color: #a0a0b0; text-align: left; }
        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; font-family: system-ui, sans-serif; font-size: 0.85rem; color: #a0a0b0; margin-bottom: 6px; }
        .form-group input { width: 100%; padding: 12px 14px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 5px; color: white; font-size: 1rem; font-family: system-ui, sans-serif; }
        .form-group input:focus { outline: none; border-color: #7c3aed; }
        .submit-btn { background: #7c3aed; color: white; border: none; padding: 14px 30px; border-radius: 6px; font-size: 1rem; font-weight: 500; cursor: pointer; font-family: system-ui, sans-serif; margin-top: 10px; }
        .submit-btn:hover { background: #6d28d9; }
        .submit-status { margin-top: 15px; padding: 12px; border-radius: 5px; display: none; font-family: system-ui, sans-serif; font-size: 0.9rem; }
        .hp { position: absolute; left: -9999px; }
        
        .toc { background: #f8f7f5; padding: 30px 35px; margin: 0 0 50px; border-radius: 6px; }
        .toc-title { font-family: system-ui, sans-serif; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 2px; color: #888; margin-bottom: 15px; }
        .toc ol { margin: 0; padding-left: 20px; }
        .toc li { margin: 8px 0; }
        .toc a { color: #7c3aed; text-decoration: none; }
        .toc a:hover { text-decoration: underline; }
        
        @media (max-width: 600px) {
            .book { padding: 30px 20px; }
            .chapter-header h1 { font-size: 2rem; }
            h2 { font-size: 1.4rem; }
            .form-row { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <nav class="topbar">
        <span class="title">Data Structures &amp; Algorithms</span>
        <a href="index.html">â† Course Home</a>
    </nav>
    
    <main class="book">
        <header class="chapter-header">
            <div class="chapter-num">Week Fourteen</div>
            <h1>Course Review &amp; Final Practice</h1>
            <p class="subtitle">Comprehensive review and exam preparation</p>
        </header>
        
        <nav class="toc">
            <div class="toc-title">Contents</div>
            <ol>
                <li><a href="#overview">Course Overview</a></li>
                <li><a href="#complexity">Complexity Analysis Review</a></li>
                <li><a href="#data-structures">Data Structures Summary</a></li>
                <li><a href="#algorithms">Algorithms Summary</a></li>
                <li><a href="#patterns">Problem-Solving Patterns</a></li>
                <li><a href="#choose">Choosing the Right Approach</a></li>
                <li><a href="#arrays">Practice: Arrays & Strings</a></li>
                <li><a href="#linkedlists">Practice: Linked Lists & Trees</a></li>
                <li><a href="#graphs">Practice: Graphs & Search</a></li>
                <li><a href="#dp-greedy">Practice: DP & Greedy</a></li>
                <li><a href="#tips">Exam Tips</a></li>
                <li><a href="#exercises">Final Practice Problems</a></li>
            </ol>
        </nav>

        <!-- ============================================== -->
        <!-- SECTION 1: COURSE OVERVIEW -->
        <!-- ============================================== -->
        <section id="overview">
            <h2>1. Course Overview</h2>
            
            <p>Congratulations on reaching the final week! This course covered the fundamental data structures and algorithms that form the foundation of computer science. This review consolidates all topics and prepares you for practical application and examinations.</p>
            
            <div class="definition">
                <div class="definition-title">Course Journey</div>
                <p>We covered 13 weeks of material: from basic complexity analysis through advanced algorithmic paradigms. Each topic builds on previous knowledge, creating a comprehensive toolkit for solving computational problems efficiently.</p>
            </div>
            
            <h3>Topics Covered</h3>
            
            <table>
                <tr>
                    <th>Week</th>
                    <th>Topic</th>
                    <th>Key Concepts</th>
                </tr>
                <tr><td>1</td><td>Foundations & Big O</td><td>Time/space complexity, Big O notation</td></tr>
                <tr><td>2</td><td>Arrays & Strings</td><td>Two pointers, sliding window</td></tr>
                <tr><td>3</td><td>Linked Lists</td><td>Singly/doubly linked, fast/slow pointers</td></tr>
                <tr><td>4</td><td>Recursion & Backtracking</td><td>Base cases, pruning, state space</td></tr>
                <tr><td>5</td><td>Stacks & Queues</td><td>LIFO/FIFO, monotonic stack</td></tr>
                <tr><td>6</td><td>Hashing</td><td>Hash tables, collision handling</td></tr>
                <tr><td>7</td><td>Trees</td><td>BST, traversals, balanced trees</td></tr>
                <tr><td>8</td><td>Heaps & Priority Queues</td><td>Min/max heap, heapify</td></tr>
                <tr><td>9</td><td>Graphs</td><td>BFS, DFS, topological sort</td></tr>
                <tr><td>10</td><td>Sorting</td><td>Comparison sorts, linear sorts</td></tr>
                <tr><td>11</td><td>Searching</td><td>Binary search, search variants</td></tr>
                <tr><td>12</td><td>Dynamic Programming</td><td>Memoization, tabulation</td></tr>
                <tr><td>13</td><td>Greedy Algorithms</td><td>Local optimal, activity selection</td></tr>
            </table>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.1 â€” Complete Algorithm Toolkit</span>
                    <button class="code-figure-run" onclick="runCode('code1')">â–¶ Run</button>
                </div>
                <textarea id="code1" spellcheck="false"># Your complete DSA toolkit in Python

# Data Structures
from collections import deque, defaultdict, Counter
import heapq
import bisect

# Key operations quick reference
toolkit = {
    'Array': {'access': 'O(1)', 'search': 'O(n)', 'insert': 'O(n)'},
    'Hash Table': {'access': 'O(1)', 'search': 'O(1)', 'insert': 'O(1)'},
    'Linked List': {'access': 'O(n)', 'search': 'O(n)', 'insert': 'O(1)'},
    'Stack/Queue': {'push/enqueue': 'O(1)', 'pop/dequeue': 'O(1)'},
    'Heap': {'insert': 'O(log n)', 'extract': 'O(log n)', 'peek': 'O(1)'},
    'BST (balanced)': {'search': 'O(log n)', 'insert': 'O(log n)'},
    'Graph (adj list)': {'add edge': 'O(1)', 'BFS/DFS': 'O(V+E)'},
}

print("=== Data Structure Operations ===")
for ds, ops in toolkit.items():
    print(f"\n{ds}:")
    for op, complexity in ops.items():
        print(f"  {op}: {complexity}")</textarea>
                <div class="code-figure-output" id="outputcode1"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.1:</strong> Quick reference for common data structure operations.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 2: COMPLEXITY ANALYSIS REVIEW -->
        <!-- ============================================== -->
        <section id="complexity">
            <h2>2. Complexity Analysis Review</h2>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.2 â€” Big O Comparison</span>
                    <button class="code-figure-run" onclick="runCode('code2')">â–¶ Run</button>
                </div>
                <textarea id="code2" spellcheck="false">import math

def show_complexity_growth(n_values):
    """Compare how different complexities grow."""
    print(f"{'n':>8} {'O(1)':>8} {'O(log n)':>10} {'O(n)':>10} {'O(n log n)':>12} {'O(nÂ²)':>12} {'O(2^n)':>15}")
    print("-" * 80)
    
    for n in n_values:
        o_1 = 1
        o_log = int(math.log2(n)) if n > 0 else 0
        o_n = n
        o_nlog = n * (int(math.log2(n)) if n > 0 else 0)
        o_n2 = n * n
        o_2n = 2 ** n if n <= 20 else float('inf')
        
        print(f"{n:>8} {o_1:>8} {o_log:>10} {o_n:>10} {o_nlog:>12} {o_n2:>12} {o_2n:>15.0f}" if o_2n != float('inf') else f"{n:>8} {o_1:>8} {o_log:>10} {o_n:>10} {o_nlog:>12} {o_n2:>12} {'overflow':>15}")

show_complexity_growth([1, 10, 100, 1000, 10000])

print("\n=== Complexity Hierarchy ===")
print("O(1) < O(log n) < O(n) < O(n log n) < O(nÂ²) < O(2^n) < O(n!)")</textarea>
                <div class="code-figure-output" id="outputcode2"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.2:</strong> Understanding how complexities scale is crucial for algorithm selection.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.3 â€” Recognizing Complexity Patterns</span>
                    <button class="code-figure-run" onclick="runCode('code3')">â–¶ Run</button>
                </div>
                <textarea id="code3" spellcheck="false"># Complexity recognition patterns

patterns = """
=== How to Identify Time Complexity ===

O(1) - Constant:
  â€¢ Direct array access: arr[i]
  â€¢ Hash table lookup: dict[key]
  â€¢ Push/pop from stack

O(log n) - Logarithmic:
  â€¢ Binary search
  â€¢ Balanced BST operations
  â€¢ Heap operations

O(n) - Linear:
  â€¢ Single loop through data
  â€¢ Linear search
  â€¢ Hash table iteration

O(n log n) - Linearithmic:
  â€¢ Efficient sorting (merge, quick, heap)
  â€¢ Divide and conquer with linear merge

O(nÂ²) - Quadratic:
  â€¢ Nested loops (both over n)
  â€¢ Bubble sort, selection sort
  â€¢ Comparing all pairs

O(2^n) - Exponential:
  â€¢ Recursive subsets
  â€¢ Naive Fibonacci
  â€¢ Backtracking without pruning

O(n!) - Factorial:
  â€¢ Generating all permutations
  â€¢ Traveling salesman brute force
"""
print(patterns)</textarea>
                <div class="code-figure-output" id="outputcode3"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.3:</strong> Pattern recognition helps quickly estimate algorithm complexity.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 3: DATA STRUCTURES SUMMARY -->
        <!-- ============================================== -->
        <section id="data-structures">
            <h2>3. Data Structures Summary</h2>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.4 â€” Array & String Essentials</span>
                    <button class="code-figure-run" onclick="runCode('code4')">â–¶ Run</button>
                </div>
                <textarea id="code4" spellcheck="false"># Arrays & Strings - Key Techniques

def two_pointer_example(arr, target):
    """Two pointers: find pair summing to target in sorted array."""
    left, right = 0, len(arr) - 1
    while left < right:
        s = arr[left] + arr[right]
        if s == target:
            return [left, right]
        elif s < target:
            left += 1
        else:
            right -= 1
    return []

def sliding_window_example(s, k):
    """Sliding window: max sum of k consecutive elements."""
    if len(s) < k:
        return 0
    window_sum = sum(s[:k])
    max_sum = window_sum
    for i in range(k, len(s)):
        window_sum += s[i] - s[i - k]
        max_sum = max(max_sum, window_sum)
    return max_sum

# Test
arr = [1, 2, 3, 4, 6]
print(f"Two pointers (sum=6): {two_pointer_example(arr, 6)}")

nums = [2, 1, 5, 1, 3, 2]
print(f"Sliding window (k=3): {sliding_window_example(nums, 3)}")</textarea>
                <div class="code-figure-output" id="outputcode4"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.4:</strong> Two pointers and sliding window are essential array techniques.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.5 â€” Linked List Operations</span>
                    <button class="code-figure-run" onclick="runCode('code5')">â–¶ Run</button>
                </div>
                <textarea id="code5" spellcheck="false">class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_list(head):
    """Reverse linked list - O(n) time, O(1) space."""
    prev = None
    curr = head
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    return prev

def has_cycle(head):
    """Detect cycle using Floyd's algorithm."""
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False

def find_middle(head):
    """Find middle node using slow/fast pointers."""
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    return slow

# Create list: 1 -> 2 -> 3 -> 4 -> 5
nodes = [ListNode(i) for i in range(1, 6)]
for i in range(4):
    nodes[i].next = nodes[i + 1]

print("Original: 1 -> 2 -> 3 -> 4 -> 5")
print(f"Middle node: {find_middle(nodes[0]).val}")
print(f"Has cycle: {has_cycle(nodes[0])}")</textarea>
                <div class="code-figure-output" id="outputcode5"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.5:</strong> Fast/slow pointers solve many linked list problems elegantly.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.6 â€” Stack & Queue Applications</span>
                    <button class="code-figure-run" onclick="runCode('code6')">â–¶ Run</button>
                </div>
                <textarea id="code6" spellcheck="false">from collections import deque

def valid_parentheses(s):
    """Check if parentheses are balanced - classic stack problem."""
    stack = []
    pairs = {')': '(', '}': '{', ']': '['}
    
    for char in s:
        if char in '({[':
            stack.append(char)
        elif char in ')}]':
            if not stack or stack.pop() != pairs[char]:
                return False
    return len(stack) == 0

def next_greater_element(nums):
    """Find next greater element - monotonic stack."""
    result = [-1] * len(nums)
    stack = []  # Store indices
    
    for i, num in enumerate(nums):
        while stack and nums[stack[-1]] < num:
            result[stack.pop()] = num
        stack.append(i)
    
    return result

def bfs_level_order(root):
    """BFS using queue - level order traversal."""
    if not root:
        return []
    result = []
    queue = deque([root])
    while queue:
        level = []
        for _ in range(len(queue)):
            node = queue.popleft()
            level.append(node)
            # Add children to queue
        result.append(level)
    return result

# Tests
print(f"Valid '([])': {valid_parentheses('([])')}")
print(f"Valid '([)]': {valid_parentheses('([)]')}")
print(f"Next greater [2,1,2,4,3]: {next_greater_element([2,1,2,4,3])}")</textarea>
                <div class="code-figure-output" id="outputcode6"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.6:</strong> Stacks for matching problems; queues for BFS.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.7 â€” Hash Table Patterns</span>
                    <button class="code-figure-run" onclick="runCode('code7')">â–¶ Run</button>
                </div>
                <textarea id="code7" spellcheck="false">from collections import Counter, defaultdict

def two_sum(nums, target):
    """Two Sum - O(n) with hash table."""
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    return []

def group_anagrams(strs):
    """Group anagrams using sorted string as key."""
    groups = defaultdict(list)
    for s in strs:
        key = tuple(sorted(s))
        groups[key].append(s)
    return list(groups.values())

def longest_consecutive(nums):
    """Longest consecutive sequence - O(n)."""
    num_set = set(nums)
    longest = 0
    
    for num in num_set:
        if num - 1 not in num_set:  # Start of sequence
            length = 1
            while num + length in num_set:
                length += 1
            longest = max(longest, length)
    
    return longest

# Tests
print(f"Two sum [2,7,11,15], target=9: {two_sum([2,7,11,15], 9)}")
print(f"Group anagrams: {group_anagrams(['eat','tea','tan','ate','nat','bat'])}")
print(f"Longest consecutive [100,4,200,1,3,2]: {longest_consecutive([100,4,200,1,3,2])}")</textarea>
                <div class="code-figure-output" id="outputcode7"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.7:</strong> Hash tables enable O(1) lookups and efficient grouping.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.8 â€” Tree Traversals & BST</span>
                    <button class="code-figure-run" onclick="runCode('code8')">â–¶ Run</button>
                </div>
                <textarea id="code8" spellcheck="false">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def inorder(root):
    """Inorder: Left -> Root -> Right (BST gives sorted)."""
    return inorder(root.left) + [root.val] + inorder(root.right) if root else []

def preorder(root):
    """Preorder: Root -> Left -> Right (copy structure)."""
    return [root.val] + preorder(root.left) + preorder(root.right) if root else []

def postorder(root):
    """Postorder: Left -> Right -> Root (delete tree)."""
    return postorder(root.left) + postorder(root.right) + [root.val] if root else []

def max_depth(root):
    """Maximum depth of binary tree."""
    if not root:
        return 0
    return 1 + max(max_depth(root.left), max_depth(root.right))

def is_valid_bst(root, min_val=float('-inf'), max_val=float('inf')):
    """Validate BST property."""
    if not root:
        return True
    if root.val <= min_val or root.val >= max_val:
        return False
    return (is_valid_bst(root.left, min_val, root.val) and
            is_valid_bst(root.right, root.val, max_val))

# Build BST: 4 -> 2,6 -> 1,3,5,7
root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), 
                   TreeNode(6, TreeNode(5), TreeNode(7)))

print(f"Inorder:  {inorder(root)}")
print(f"Preorder: {preorder(root)}")
print(f"Max depth: {max_depth(root)}")
print(f"Valid BST: {is_valid_bst(root)}")</textarea>
                <div class="code-figure-output" id="outputcode8"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.8:</strong> Tree traversals and BST validation are fundamental.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.9 â€” Heap Operations</span>
                    <button class="code-figure-run" onclick="runCode('code9')">â–¶ Run</button>
                </div>
                <textarea id="code9" spellcheck="false">import heapq

def kth_largest(nums, k):
    """Find kth largest using min-heap of size k."""
    heap = nums[:k]
    heapq.heapify(heap)
    
    for num in nums[k:]:
        if num > heap[0]:
            heapq.heapreplace(heap, num)
    
    return heap[0]

def merge_k_sorted(lists):
    """Merge k sorted lists using heap."""
    heap = []
    for i, lst in enumerate(lists):
        if lst:
            heapq.heappush(heap, (lst[0], i, 0))
    
    result = []
    while heap:
        val, list_idx, elem_idx = heapq.heappop(heap)
        result.append(val)
        
        if elem_idx + 1 < len(lists[list_idx]):
            next_val = lists[list_idx][elem_idx + 1]
            heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))
    
    return result

def top_k_frequent(nums, k):
    """Top k frequent elements."""
    count = {}
    for num in nums:
        count[num] = count.get(num, 0) + 1
    
    heap = []
    for num, freq in count.items():
        heapq.heappush(heap, (freq, num))
        if len(heap) > k:
            heapq.heappop(heap)
    
    return [num for freq, num in heap]

# Tests
print(f"3rd largest in [3,2,1,5,6,4]: {kth_largest([3,2,1,5,6,4], 3)}")
print(f"Merge [[1,4,5],[1,3,4],[2,6]]: {merge_k_sorted([[1,4,5],[1,3,4],[2,6]])}")
print(f"Top 2 frequent [1,1,1,2,2,3]: {top_k_frequent([1,1,1,2,2,3], 2)}")</textarea>
                <div class="code-figure-output" id="outputcode9"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.9:</strong> Heaps excel at top-k problems and merging sorted sequences.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 4: ALGORITHMS SUMMARY -->
        <!-- ============================================== -->
        <section id="algorithms">
            <h2>4. Algorithms Summary</h2>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.10 â€” Sorting Algorithms</span>
                    <button class="code-figure-run" onclick="runCode('code10')">â–¶ Run</button>
                </div>
                <textarea id="code10" spellcheck="false">def merge_sort(arr):
    """Merge Sort - O(n log n), stable, O(n) space."""
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result

def quick_sort(arr):
    """Quick Sort - O(n log n) avg, O(nÂ²) worst, in-place."""
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)

# Sorting summary
print("=== Sorting Algorithm Comparison ===")
print(f"{'Algorithm':<15} {'Time Avg':<12} {'Time Worst':<12} {'Space':<8} {'Stable'}")
print("-" * 60)
sorts = [
    ("Bubble", "O(nÂ²)", "O(nÂ²)", "O(1)", "Yes"),
    ("Selection", "O(nÂ²)", "O(nÂ²)", "O(1)", "No"),
    ("Insertion", "O(nÂ²)", "O(nÂ²)", "O(1)", "Yes"),
    ("Merge", "O(n log n)", "O(n log n)", "O(n)", "Yes"),
    ("Quick", "O(n log n)", "O(nÂ²)", "O(log n)", "No"),
    ("Heap", "O(n log n)", "O(n log n)", "O(1)", "No"),
    ("Counting", "O(n+k)", "O(n+k)", "O(k)", "Yes"),
    ("Python sorted", "O(n log n)", "O(n log n)", "O(n)", "Yes"),
]
for s in sorts:
    print(f"{s[0]:<15} {s[1]:<12} {s[2]:<12} {s[3]:<8} {s[4]}")</textarea>
                <div class="code-figure-output" id="outputcode10"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.10:</strong> Know when to use each sorting algorithm based on constraints.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.11 â€” Binary Search Patterns</span>
                    <button class="code-figure-run" onclick="runCode('code11')">â–¶ Run</button>
                </div>
                <textarea id="code11" spellcheck="false">def binary_search(arr, target):
    """Standard binary search - find exact match."""
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

def lower_bound(arr, target):
    """Find first index where arr[i] >= target."""
    left, right = 0, len(arr)
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid
    return left

def search_rotated(arr, target):
    """Search in rotated sorted array."""
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        if arr[left] <= arr[mid]:  # Left half sorted
            if arr[left] <= target < arr[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:  # Right half sorted
            if arr[mid] < target <= arr[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1

# Tests
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(f"Binary search for 5: {binary_search(arr, 5)}")
print(f"Lower bound for 5.5: {lower_bound(arr, 5.5)}")
print(f"Search rotated [4,5,6,7,0,1,2] for 0: {search_rotated([4,5,6,7,0,1,2], 0)}")</textarea>
                <div class="code-figure-output" id="outputcode11"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.11:</strong> Binary search variants handle different search requirements.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.12 â€” Graph Algorithms</span>
                    <button class="code-figure-run" onclick="runCode('code12')">â–¶ Run</button>
                </div>
                <textarea id="code12" spellcheck="false">from collections import deque
import heapq

def bfs(graph, start):
    """BFS - shortest path in unweighted graph."""
    visited = {start}
    queue = deque([start])
    order = []
    
    while queue:
        node = queue.popleft()
        order.append(node)
        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
    return order

def dfs(graph, start, visited=None):
    """DFS - explore deeply before backtracking."""
    if visited is None:
        visited = set()
    visited.add(start)
    order = [start]
    for neighbor in graph.get(start, []):
        if neighbor not in visited:
            order.extend(dfs(graph, neighbor, visited))
    return order

def dijkstra(graph, start):
    """Dijkstra - shortest path with non-negative weights."""
    dist = {start: 0}
    heap = [(0, start)]
    
    while heap:
        d, u = heapq.heappop(heap)
        if d > dist.get(u, float('inf')):
            continue
        for v, w in graph.get(u, []):
            if d + w < dist.get(v, float('inf')):
                dist[v] = d + w
                heapq.heappush(heap, (dist[v], v))
    return dist

# Test
graph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['D'], 'D': []}
print(f"BFS from A: {bfs(graph, 'A')}")
print(f"DFS from A: {dfs(graph, 'A')}")

weighted = {'A': [('B', 1), ('C', 4)], 'B': [('C', 2), ('D', 5)], 'C': [('D', 1)], 'D': []}
print(f"Dijkstra from A: {dijkstra(weighted, 'A')}")</textarea>
                <div class="code-figure-output" id="outputcode12"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.12:</strong> BFS for shortest path (unweighted), DFS for traversal, Dijkstra for weighted.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 5: PROBLEM-SOLVING PATTERNS -->
        <!-- ============================================== -->
        <section id="patterns">
            <h2>5. Problem-Solving Patterns</h2>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.13 â€” Pattern Recognition Guide</span>
                    <button class="code-figure-run" onclick="runCode('code13')">â–¶ Run</button>
                </div>
                <textarea id="code13" spellcheck="false">patterns = """
=== Problem-Solving Pattern Recognition ===

1. TWO POINTERS
   Clues: Sorted array, pair finding, container problems
   Examples: Two Sum (sorted), Container with Water, Remove Duplicates

2. SLIDING WINDOW
   Clues: Subarray/substring, fixed or variable size, continuous
   Examples: Max Sum Subarray, Longest Substring Without Repeating

3. FAST & SLOW POINTERS
   Clues: Linked list, cycle detection, middle finding
   Examples: Cycle Detection, Find Middle, Happy Number

4. BINARY SEARCH
   Clues: Sorted array, search space, minimize/maximize
   Examples: Search in Rotated, First Bad Version, Capacity to Ship

5. BFS / DFS
   Clues: Graph/tree, shortest path, connected components
   Examples: Level Order, Number of Islands, Clone Graph

6. DYNAMIC PROGRAMMING
   Clues: Optimization, counting ways, overlapping subproblems
   Examples: Fibonacci, Coin Change, Longest Subsequence

7. GREEDY
   Clues: Local choice leads to global optimal, intervals
   Examples: Activity Selection, Jump Game, Task Scheduler

8. BACKTRACKING
   Clues: All combinations/permutations, constraint satisfaction
   Examples: N-Queens, Subsets, Word Search

9. HEAP / PRIORITY QUEUE
   Clues: Top K, merge sorted, streaming data
   Examples: Kth Largest, Merge K Lists, Median Finder

10. HASH TABLE
    Clues: O(1) lookup needed, counting, grouping
    Examples: Two Sum, Group Anagrams, LRU Cache
"""
print(patterns)</textarea>
                <div class="code-figure-output" id="outputcode13"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.13:</strong> Recognize patterns to quickly identify the right approach.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.14 â€” Backtracking Template</span>
                    <button class="code-figure-run" onclick="runCode('code14')">â–¶ Run</button>
                </div>
                <textarea id="code14" spellcheck="false">def backtrack_template(candidates, target):
    """
    Generic backtracking template.
    Modify for specific problems.
    """
    result = []
    
    def backtrack(start, path, remaining):
        # Base case: found valid solution
        if remaining == 0:
            result.append(path[:])
            return
        
        # Pruning: invalid state
        if remaining < 0:
            return
        
        # Explore all choices
        for i in range(start, len(candidates)):
            # Make choice
            path.append(candidates[i])
            
            # Recurse (start=i for reuse, i+1 for no reuse)
            backtrack(i, path, remaining - candidates[i])
            
            # Undo choice (backtrack)
            path.pop()
    
    backtrack(0, [], target)
    return result

def subsets(nums):
    """Generate all subsets using backtracking."""
    result = []
    
    def backtrack(start, path):
        result.append(path[:])
        for i in range(start, len(nums)):
            path.append(nums[i])
            backtrack(i + 1, path)
            path.pop()
    
    backtrack(0, [])
    return result

# Tests
print(f"Combinations sum to 7 from [2,3,6,7]: {backtrack_template([2,3,6,7], 7)}")
print(f"Subsets of [1,2,3]: {subsets([1,2,3])}")</textarea>
                <div class="code-figure-output" id="outputcode14"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.14:</strong> Backtracking explores all possibilities with pruning.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 6: CHOOSING THE RIGHT APPROACH -->
        <!-- ============================================== -->
        <section id="choose">
            <h2>6. Choosing the Right Approach</h2>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.15 â€” Decision Framework</span>
                    <button class="code-figure-run" onclick="runCode('code15')">â–¶ Run</button>
                </div>
                <textarea id="code15" spellcheck="false">framework = """
=== Algorithm Selection Decision Framework ===

STEP 1: Understand the Problem
- What's the input? (array, string, graph, tree)
- What's the output? (single value, list, boolean)
- What are the constraints? (size, time limit)

STEP 2: Identify Problem Type
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Optimization (min/max)?                             â”‚
â”‚   â†’ Try Greedy first, then DP                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Counting ways?                                      â”‚
â”‚   â†’ Dynamic Programming                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Finding all solutions?                              â”‚
â”‚   â†’ Backtracking                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Shortest path / levels?                             â”‚
â”‚   â†’ BFS (unweighted) or Dijkstra (weighted)        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Search in sorted data?                              â”‚
â”‚   â†’ Binary Search                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Need O(1) lookup?                                   â”‚
â”‚   â†’ Hash Table                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Top K / streaming?                                  â”‚
â”‚   â†’ Heap / Priority Queue                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

STEP 3: Verify Complexity
- Does it fit time/space constraints?
- Can we optimize further?

STEP 4: Handle Edge Cases
- Empty input, single element
- All same elements, sorted/reverse sorted
- Negative numbers, zeros
"""
print(framework)</textarea>
                <div class="code-figure-output" id="outputcode15"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.15:</strong> Systematic approach to algorithm selection.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.16 â€” DP vs Greedy Decision</span>
                    <button class="code-figure-run" onclick="runCode('code16')">â–¶ Run</button>
                </div>
                <textarea id="code16" spellcheck="false">"""
=== DP vs Greedy: Which to Choose? ===

Use GREEDY when:
âœ“ Local optimal choice leads to global optimal
âœ“ Problem has greedy choice property
âœ“ No need to reconsider previous choices
Examples: Activity Selection, Huffman Coding, Dijkstra

Use DP when:
âœ“ Overlapping subproblems
âœ“ Need to consider all combinations
âœ“ Greedy doesn't give optimal solution
Examples: 0/1 Knapsack, Longest Common Subsequence, Edit Distance

QUICK TEST:
- Can you make a choice and never look back? â†’ Try Greedy
- Do you need to try all possibilities? â†’ Use DP
"""

# Example: Coin Change
# Greedy fails for [1, 3, 4], amount=6
# Greedy: 4+1+1 = 3 coins
# Optimal: 3+3 = 2 coins

def coin_change_greedy(coins, amount):
    coins = sorted(coins, reverse=True)
    count = 0
    for coin in coins:
        count += amount // coin
        amount %= coin
    return count if amount == 0 else -1

def coin_change_dp(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for i in range(1, amount + 1):
        for coin in coins:
            if coin <= i and dp[i - coin] != float('inf'):
                dp[i] = min(dp[i], dp[i - coin] + 1)
    return dp[amount] if dp[amount] != float('inf') else -1

coins = [1, 3, 4]
amount = 6
print(f"Coins: {coins}, Amount: {amount}")
print(f"Greedy: {coin_change_greedy(coins, amount)} coins")
print(f"DP: {coin_change_dp(coins, amount)} coins")
print("\nGreedy fails! Use DP for coin change.")</textarea>
                <div class="code-figure-output" id="outputcode16"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.16:</strong> Coin change demonstrates when greedy fails and DP succeeds.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 7: PRACTICE ARRAYS & STRINGS -->
        <!-- ============================================== -->
        <section id="arrays">
            <h2>7. Practice: Arrays &amp; Strings</h2>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.17 â€” Classic Array Problems</span>
                    <button class="code-figure-run" onclick="runCode('code17')">â–¶ Run</button>
                </div>
                <textarea id="code17" spellcheck="false">def product_except_self(nums):
    """Product of array except self - O(n) without division."""
    n = len(nums)
    result = [1] * n
    
    # Left products
    left = 1
    for i in range(n):
        result[i] = left
        left *= nums[i]
    
    # Right products
    right = 1
    for i in range(n - 1, -1, -1):
        result[i] *= right
        right *= nums[i]
    
    return result

def trap_water(height):
    """Trapping rain water - two pointers."""
    if not height:
        return 0
    
    left, right = 0, len(height) - 1
    left_max = right_max = 0
    water = 0
    
    while left < right:
        if height[left] < height[right]:
            if height[left] >= left_max:
                left_max = height[left]
            else:
                water += left_max - height[left]
            left += 1
        else:
            if height[right] >= right_max:
                right_max = height[right]
            else:
                water += right_max - height[right]
            right -= 1
    
    return water

# Tests
print(f"Product except self [1,2,3,4]: {product_except_self([1,2,3,4])}")
print(f"Trap water [0,1,0,2,1,0,1,3,2,1,2,1]: {trap_water([0,1,0,2,1,0,1,3,2,1,2,1])}")</textarea>
                <div class="code-figure-output" id="outputcode17"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.17:</strong> Product except self and trapping water are classic interview problems.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.18 â€” String Manipulation</span>
                    <button class="code-figure-run" onclick="runCode('code18')">â–¶ Run</button>
                </div>
                <textarea id="code18" spellcheck="false">def longest_substring_without_repeat(s):
    """Longest substring without repeating characters."""
    char_index = {}
    max_len = start = 0
    
    for i, char in enumerate(s):
        if char in char_index and char_index[char] >= start:
            start = char_index[char] + 1
        char_index[char] = i
        max_len = max(max_len, i - start + 1)
    
    return max_len

def min_window_substring(s, t):
    """Minimum window substring containing all chars of t."""
    from collections import Counter
    
    if not s or not t:
        return ""
    
    need = Counter(t)
    have = {}
    required = len(need)
    formed = 0
    
    left = 0
    min_len = float('inf')
    min_window = ""
    
    for right, char in enumerate(s):
        have[char] = have.get(char, 0) + 1
        
        if char in need and have[char] == need[char]:
            formed += 1
        
        while formed == required:
            if right - left + 1 < min_len:
                min_len = right - left + 1
                min_window = s[left:right + 1]
            
            have[s[left]] -= 1
            if s[left] in need and have[s[left]] < need[s[left]]:
                formed -= 1
            left += 1
    
    return min_window

# Tests
print(f"Longest without repeat 'abcabcbb': {longest_substring_without_repeat('abcabcbb')}")
print(f"Min window 'ADOBECODEBANC' containing 'ABC': '{min_window_substring('ADOBECODEBANC', 'ABC')}'")</textarea>
                <div class="code-figure-output" id="outputcode18"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.18:</strong> Sliding window solves many substring problems efficiently.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 8: PRACTICE LINKED LISTS & TREES -->
        <!-- ============================================== -->
        <section id="linkedlists">
            <h2>8. Practice: Linked Lists &amp; Trees</h2>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.19 â€” Advanced Linked List</span>
                    <button class="code-figure-run" onclick="runCode('code19')">â–¶ Run</button>
                </div>
                <textarea id="code19" spellcheck="false">class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_two_sorted(l1, l2):
    """Merge two sorted linked lists."""
    dummy = ListNode()
    curr = dummy
    
    while l1 and l2:
        if l1.val <= l2.val:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    
    curr.next = l1 or l2
    return dummy.next

def add_two_numbers(l1, l2):
    """Add two numbers represented as linked lists."""
    dummy = ListNode()
    curr = dummy
    carry = 0
    
    while l1 or l2 or carry:
        val1 = l1.val if l1 else 0
        val2 = l2.val if l2 else 0
        
        total = val1 + val2 + carry
        carry = total // 10
        curr.next = ListNode(total % 10)
        curr = curr.next
        
        if l1: l1 = l1.next
        if l2: l2 = l2.next
    
    return dummy.next

# Helper to create and print list
def create_list(vals):
    dummy = ListNode()
    curr = dummy
    for v in vals:
        curr.next = ListNode(v)
        curr = curr.next
    return dummy.next

def list_to_array(head):
    arr = []
    while head:
        arr.append(head.val)
        head = head.next
    return arr

# Test
l1 = create_list([1, 2, 4])
l2 = create_list([1, 3, 4])
merged = merge_two_sorted(l1, l2)
print(f"Merge [1,2,4] + [1,3,4]: {list_to_array(merged)}")</textarea>
                <div class="code-figure-output" id="outputcode19"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.19:</strong> Merging and addition are common linked list operations.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.20 â€” Tree Problems</span>
                    <button class="code-figure-run" onclick="runCode('code20')">â–¶ Run</button>
                </div>
                <textarea id="code20" spellcheck="false">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def lowest_common_ancestor(root, p, q):
    """Find LCA of two nodes in binary tree."""
    if not root or root == p or root == q:
        return root
    
    left = lowest_common_ancestor(root.left, p, q)
    right = lowest_common_ancestor(root.right, p, q)
    
    if left and right:
        return root
    return left or right

def serialize(root):
    """Serialize binary tree to string."""
    if not root:
        return "null"
    return f"{root.val},{serialize(root.left)},{serialize(root.right)}"

def is_symmetric(root):
    """Check if tree is symmetric."""
    def is_mirror(t1, t2):
        if not t1 and not t2:
            return True
        if not t1 or not t2:
            return False
        return (t1.val == t2.val and 
                is_mirror(t1.left, t2.right) and 
                is_mirror(t1.right, t2.left))
    
    return is_mirror(root, root) if root else True

# Build tree: 1 -> 2,2 -> 3,4,4,3
root = TreeNode(1, 
    TreeNode(2, TreeNode(3), TreeNode(4)),
    TreeNode(2, TreeNode(4), TreeNode(3)))

print(f"Serialized: {serialize(root)}")
print(f"Is symmetric: {is_symmetric(root)}")</textarea>
                <div class="code-figure-output" id="outputcode20"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.20:</strong> LCA, serialization, and symmetry are important tree problems.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 9: PRACTICE GRAPHS & SEARCH -->
        <!-- ============================================== -->
        <section id="graphs">
            <h2>9. Practice: Graphs &amp; Search</h2>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.21 â€” Graph Problems</span>
                    <button class="code-figure-run" onclick="runCode('code21')">â–¶ Run</button>
                </div>
                <textarea id="code21" spellcheck="false">from collections import deque

def num_islands(grid):
    """Count number of islands using DFS."""
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    count = 0
    
    def dfs(r, c):
        if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != '1':
            return
        grid[r][c] = '0'  # Mark visited
        dfs(r + 1, c)
        dfs(r - 1, c)
        dfs(r, c + 1)
        dfs(r, c - 1)
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                count += 1
                dfs(r, c)
    
    return count

def course_schedule(numCourses, prerequisites):
    """Can finish all courses? (Cycle detection in directed graph)"""
    graph = {i: [] for i in range(numCourses)}
    for course, prereq in prerequisites:
        graph[prereq].append(course)
    
    # 0: unvisited, 1: visiting, 2: visited
    state = [0] * numCourses
    
    def has_cycle(course):
        if state[course] == 1:
            return True
        if state[course] == 2:
            return False
        
        state[course] = 1
        for next_course in graph[course]:
            if has_cycle(next_course):
                return True
        state[course] = 2
        return False
    
    for course in range(numCourses):
        if has_cycle(course):
            return False
    return True

# Tests
grid = [
    ['1','1','0','0','0'],
    ['1','1','0','0','0'],
    ['0','0','1','0','0'],
    ['0','0','0','1','1']
]
print(f"Number of islands: {num_islands([row[:] for row in grid])}")
print(f"Can finish courses [[1,0],[0,1]]: {course_schedule(2, [[1,0],[0,1]])}")
print(f"Can finish courses [[1,0]]: {course_schedule(2, [[1,0]])}")</textarea>
                <div class="code-figure-output" id="outputcode21"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.21:</strong> Islands and course scheduling are classic graph problems.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.22 â€” Topological Sort</span>
                    <button class="code-figure-run" onclick="runCode('code22')">â–¶ Run</button>
                </div>
                <textarea id="code22" spellcheck="false">from collections import deque

def topological_sort(n, edges):
    """Topological sort using Kahn's algorithm (BFS)."""
    graph = {i: [] for i in range(n)}
    in_degree = [0] * n
    
    for u, v in edges:
        graph[u].append(v)
        in_degree[v] += 1
    
    # Start with nodes having no prerequisites
    queue = deque([i for i in range(n) if in_degree[i] == 0])
    order = []
    
    while queue:
        node = queue.popleft()
        order.append(node)
        
        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    return order if len(order) == n else []  # Empty if cycle

def find_order(numCourses, prerequisites):
    """Find course order to complete all courses."""
    edges = [(prereq, course) for course, prereq in prerequisites]
    return topological_sort(numCourses, edges)

# Test
prereqs = [[1,0], [2,0], [3,1], [3,2]]
order = find_order(4, prereqs)
print(f"Prerequisites: {prereqs}")
print(f"Course order: {order}")</textarea>
                <div class="code-figure-output" id="outputcode22"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.22:</strong> Topological sort orders tasks respecting dependencies.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 10: PRACTICE DP & GREEDY -->
        <!-- ============================================== -->
        <section id="dp-greedy">
            <h2>10. Practice: DP &amp; Greedy</h2>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.23 â€” Classic DP Problems</span>
                    <button class="code-figure-run" onclick="runCode('code23')">â–¶ Run</button>
                </div>
                <textarea id="code23" spellcheck="false">def longest_increasing_subsequence(nums):
    """LIS using DP - O(nÂ²)."""
    if not nums:
        return 0
    
    dp = [1] * len(nums)
    
    for i in range(1, len(nums)):
        for j in range(i):
            if nums[j] < nums[i]:
                dp[i] = max(dp[i], dp[j] + 1)
    
    return max(dp)

def edit_distance(word1, word2):
    """Minimum operations to convert word1 to word2."""
    m, n = len(word1), len(word2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i - 1] == word2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])
    
    return dp[m][n]

def house_robber(nums):
    """Maximum money without robbing adjacent houses."""
    if not nums:
        return 0
    if len(nums) <= 2:
        return max(nums)
    
    prev2, prev1 = nums[0], max(nums[0], nums[1])
    
    for i in range(2, len(nums)):
        current = max(prev1, prev2 + nums[i])
        prev2, prev1 = prev1, current
    
    return prev1

# Tests
print(f"LIS [10,9,2,5,3,7,101,18]: {longest_increasing_subsequence([10,9,2,5,3,7,101,18])}")
print(f"Edit distance 'horse' -> 'ros': {edit_distance('horse', 'ros')}")
print(f"House robber [2,7,9,3,1]: {house_robber([2,7,9,3,1])}")</textarea>
                <div class="code-figure-output" id="outputcode23"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.23:</strong> LIS, edit distance, and house robber are essential DP problems.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.24 â€” Classic Greedy Problems</span>
                    <button class="code-figure-run" onclick="runCode('code24')">â–¶ Run</button>
                </div>
                <textarea id="code24" spellcheck="false">def jump_game(nums):
    """Can reach the last index?"""
    max_reach = 0
    for i, jump in enumerate(nums):
        if i > max_reach:
            return False
        max_reach = max(max_reach, i + jump)
    return True

def merge_intervals(intervals):
    """Merge overlapping intervals."""
    if not intervals:
        return []
    
    intervals.sort()
    merged = [intervals[0]]
    
    for start, end in intervals[1:]:
        if start <= merged[-1][1]:
            merged[-1][1] = max(merged[-1][1], end)
        else:
            merged.append([start, end])
    
    return merged

def activity_selection(activities):
    """Maximum non-overlapping activities."""
    activities.sort(key=lambda x: x[1])
    
    count = 1
    last_end = activities[0][1]
    
    for start, end in activities[1:]:
        if start >= last_end:
            count += 1
            last_end = end
    
    return count

# Tests
print(f"Jump game [2,3,1,1,4]: {jump_game([2,3,1,1,4])}")
print(f"Merge [[1,3],[2,6],[8,10]]: {merge_intervals([[1,3],[2,6],[8,10]])}")
print(f"Activities [(1,4),(3,5),(0,6),(5,7)]: {activity_selection([(1,4),(3,5),(0,6),(5,7)])}")</textarea>
                <div class="code-figure-output" id="outputcode24"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.24:</strong> Jump game, merge intervals, and activity selection showcase greedy.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 11: EXAM TIPS -->
        <!-- ============================================== -->
        <section id="tips">
            <h2>11. Exam Tips</h2>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.25 â€” Problem-Solving Strategy</span>
                    <button class="code-figure-run" onclick="runCode('code25')">â–¶ Run</button>
                </div>
                <textarea id="code25" spellcheck="false">exam_tips = """
=== EXAM STRATEGY ===

BEFORE CODING (5 minutes):
1. Read the problem TWICE
2. Identify input/output types
3. Ask clarifying questions
4. Work through examples by hand
5. Identify the pattern (use the 10 patterns!)

WHILE CODING (15-20 minutes):
1. Start with brute force if stuck
2. State your approach before coding
3. Write clean, readable code
4. Use meaningful variable names
5. Handle edge cases explicitly

AFTER CODING (5 minutes):
1. Trace through with the example
2. Check edge cases: empty, single, duplicates
3. Verify time and space complexity
4. Look for off-by-one errors

=== COMMON MISTAKES TO AVOID ===
âœ— Jumping to code without understanding
âœ— Ignoring edge cases
âœ— Off-by-one errors in loops
âœ— Forgetting to return a value
âœ— Modifying input when shouldn't
âœ— Integer overflow (less common in Python)

=== TIME MANAGEMENT ===
â€¢ Easy: 15 minutes
â€¢ Medium: 25 minutes
â€¢ Hard: 40 minutes
â€¢ If stuck for 5 minutes, try different approach
"""
print(exam_tips)</textarea>
                <div class="code-figure-output" id="outputcode25"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.25:</strong> Structured approach improves problem-solving success.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.26 â€” Edge Case Checklist</span>
                    <button class="code-figure-run" onclick="runCode('code26')">â–¶ Run</button>
                </div>
                <textarea id="code26" spellcheck="false">def check_edge_cases(func, test_cases):
    """Always test edge cases!"""
    print("=== Edge Case Testing ===\n")
    
    for name, args, expected in test_cases:
        try:
            result = func(*args)
            status = "âœ“" if result == expected else "âœ—"
            print(f"{status} {name}: {args} -> {result} (expected {expected})")
        except Exception as e:
            print(f"âœ— {name}: {args} -> ERROR: {e}")

# Example: Testing two_sum
def two_sum(nums, target):
    seen = {}
    for i, num in enumerate(nums):
        if target - num in seen:
            return [seen[target - num], i]
        seen[num] = i
    return []

edge_cases = [
    ("Normal case", ([2, 7, 11, 15], 9), [0, 1]),
    ("Empty array", ([], 5), []),
    ("Single element", ([5], 5), []),
    ("No solution", ([1, 2, 3], 10), []),
    ("Negative numbers", ([-1, -2, -3, -4, -5], -8), [2, 4]),
    ("Duplicates", ([3, 3], 6), [0, 1]),
]

check_edge_cases(two_sum, edge_cases)</textarea>
                <div class="code-figure-output" id="outputcode26"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.26:</strong> Systematic edge case testing catches bugs early.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.27 â€” Complexity Quick Reference</span>
                    <button class="code-figure-run" onclick="runCode('code27')">â–¶ Run</button>
                </div>
                <textarea id="code27" spellcheck="false">quick_ref = """
=== COMPLEXITY QUICK REFERENCE ===

DATA STRUCTURE OPERATIONS:
Array:        Access O(1), Search O(n), Insert O(n)
Hash Table:   Access O(1), Search O(1), Insert O(1)
Linked List:  Access O(n), Search O(n), Insert O(1)
Stack/Queue:  Push O(1), Pop O(1), Peek O(1)
Heap:         Insert O(log n), Extract O(log n), Peek O(1)
BST:          Search O(h), Insert O(h), Delete O(h)

SORTING:
Quick Sort:   O(n log n) avg, O(nÂ²) worst
Merge Sort:   O(n log n) always
Heap Sort:    O(n log n) always
Counting:     O(n + k) where k is range

SEARCHING:
Linear:       O(n)
Binary:       O(log n)
BST:          O(log n) avg, O(n) worst
Hash:         O(1) avg

GRAPH:
BFS/DFS:      O(V + E)
Dijkstra:     O((V + E) log V)
Bellman-Ford: O(VE)
Topological:  O(V + E)

DYNAMIC PROGRAMMING:
Usually:      O(nÂ²) or O(n * target)
Space:        Often can optimize from O(nÂ²) to O(n)
"""
print(quick_ref)</textarea>
                <div class="code-figure-output" id="outputcode27"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.27:</strong> Memorize these complexities for quick analysis.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.28 â€” Python Built-in Functions Cheatsheet</span>
                    <button class="code-figure-run" onclick="runCode('code28')">â–¶ Run</button>
                </div>
                <textarea id="code28" spellcheck="false"># Essential Python built-ins for DSA

from collections import Counter, defaultdict, deque
import heapq
import bisect

# Counter - frequency counting
nums = [1, 2, 2, 3, 3, 3]
freq = Counter(nums)
print(f"Counter: {freq}")
print(f"Most common: {freq.most_common(2)}")

# defaultdict - auto-initialize
graph = defaultdict(list)
graph[0].append(1)
graph[0].append(2)
print(f"\ndefaultdict: {dict(graph)}")

# deque - O(1) both ends
dq = deque([1, 2, 3])
dq.appendleft(0)
dq.append(4)
print(f"\ndeque: {dq}")

# heapq - min heap
heap = [3, 1, 4, 1, 5]
heapq.heapify(heap)
print(f"\nHeap: {heap}")
print(f"Pop smallest: {heapq.heappop(heap)}")

# bisect - binary search
arr = [1, 2, 4, 4, 5]
print(f"\nbisect_left(4): {bisect.bisect_left(arr, 4)}")
print(f"bisect_right(4): {bisect.bisect_right(arr, 4)}")</textarea>
                <div class="code-figure-output" id="outputcode28"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.28:</strong> Master these built-ins for cleaner, faster code.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.29 â€” Union-Find (Disjoint Set)</span>
                    <button class="code-figure-run" onclick="runCode('code29')">â–¶ Run</button>
                </div>
                <textarea id="code29" spellcheck="false">class UnionFind:
    """Union-Find with path compression and union by rank."""
    
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
        self.components = n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # Path compression
        return self.parent[x]
    
    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False
        
        # Union by rank
        if self.rank[px] < self.rank[py]:
            px, py = py, px
        self.parent[py] = px
        if self.rank[px] == self.rank[py]:
            self.rank[px] += 1
        
        self.components -= 1
        return True
    
    def connected(self, x, y):
        return self.find(x) == self.find(y)

# Test: Count connected components
uf = UnionFind(5)
edges = [(0, 1), (1, 2), (3, 4)]
for u, v in edges:
    uf.union(u, v)

print(f"Components after edges {edges}: {uf.components}")
print(f"0 and 2 connected: {uf.connected(0, 2)}")
print(f"0 and 3 connected: {uf.connected(0, 3)}")</textarea>
                <div class="code-figure-output" id="outputcode29"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.29:</strong> Union-Find for connected components and cycle detection.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.30 â€” Trie (Prefix Tree)</span>
                    <button class="code-figure-run" onclick="runCode('code30')">â–¶ Run</button>
                </div>
                <textarea id="code30" spellcheck="false">class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False

class Trie:
    def __init__(self):
        self.root = TrieNode()
    
    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True
    
    def search(self, word):
        node = self._find_node(word)
        return node is not None and node.is_end
    
    def starts_with(self, prefix):
        return self._find_node(prefix) is not None
    
    def _find_node(self, prefix):
        node = self.root
        for char in prefix:
            if char not in node.children:
                return None
            node = node.children[char]
        return node

# Test
trie = Trie()
words = ["apple", "app", "application", "banana"]
for word in words:
    trie.insert(word)

print(f"Search 'app': {trie.search('app')}")
print(f"Search 'appl': {trie.search('appl')}")
print(f"Starts with 'app': {trie.starts_with('app')}")
print(f"Starts with 'ban': {trie.starts_with('ban')}")</textarea>
                <div class="code-figure-output" id="outputcode30"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.30:</strong> Trie for efficient prefix operations and autocomplete.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.31 â€” Interval Tree Basics</span>
                    <button class="code-figure-run" onclick="runCode('code31')">â–¶ Run</button>
                </div>
                <textarea id="code31" spellcheck="false"># Common interval operations

def has_overlap(a, b):
    """Check if two intervals overlap."""
    return a[0] < b[1] and b[0] < a[1]

def merge_intervals(intervals):
    """Merge all overlapping intervals."""
    if not intervals:
        return []
    
    intervals.sort()
    merged = [intervals[0][:]]
    
    for start, end in intervals[1:]:
        if start <= merged[-1][1]:
            merged[-1][1] = max(merged[-1][1], end)
        else:
            merged.append([start, end])
    
    return merged

def insert_interval(intervals, new):
    """Insert and merge a new interval."""
    result = []
    i = 0
    
    # Add all before
    while i < len(intervals) and intervals[i][1] < new[0]:
        result.append(intervals[i])
        i += 1
    
    # Merge overlapping
    while i < len(intervals) and intervals[i][0] <= new[1]:
        new = [min(new[0], intervals[i][0]), max(new[1], intervals[i][1])]
        i += 1
    result.append(new)
    
    # Add remaining
    result.extend(intervals[i:])
    return result

# Tests
print(f"Overlap [1,3] and [2,4]: {has_overlap([1,3], [2,4])}")
print(f"Merge [[1,3],[2,6],[8,10]]: {merge_intervals([[1,3],[2,6],[8,10]])}")
print(f"Insert [4,8] into [[1,3],[6,9]]: {insert_interval([[1,3],[6,9]], [4,8])}")</textarea>
                <div class="code-figure-output" id="outputcode31"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.31:</strong> Interval operations are common in scheduling problems.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.32 â€” Bit Manipulation Essentials</span>
                    <button class="code-figure-run" onclick="runCode('code32')">â–¶ Run</button>
                </div>
                <textarea id="code32" spellcheck="false"># Essential bit manipulation techniques

def count_bits(n):
    """Count number of 1 bits."""
    count = 0
    while n:
        count += n & 1
        n >>= 1
    return count

def is_power_of_two(n):
    """Check if n is power of 2."""
    return n > 0 and (n & (n - 1)) == 0

def single_number(nums):
    """Find element that appears once (others appear twice)."""
    result = 0
    for num in nums:
        result ^= num
    return result

def get_bit(n, i):
    """Get ith bit."""
    return (n >> i) & 1

def set_bit(n, i):
    """Set ith bit to 1."""
    return n | (1 << i)

def clear_bit(n, i):
    """Clear ith bit to 0."""
    return n & ~(1 << i)

# Tests
print(f"Count bits in 11 (1011): {count_bits(11)}")
print(f"Is 16 power of 2: {is_power_of_two(16)}")
print(f"Is 18 power of 2: {is_power_of_two(18)}")
print(f"Single number in [4,1,2,1,2]: {single_number([4,1,2,1,2])}")

n = 10  # 1010
print(f"\nNumber 10 (1010):")
print(f"  Bit 1: {get_bit(n, 1)}")
print(f"  Set bit 0: {set_bit(n, 0)} (1011 = 11)")
print(f"  Clear bit 1: {clear_bit(n, 1)} (1000 = 8)")</textarea>
                <div class="code-figure-output" id="outputcode32"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.32:</strong> Bit manipulation for efficient operations and space savings.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 14.33 â€” Final Complexity Cheatsheet</span>
                    <button class="code-figure-run" onclick="runCode('code33')">â–¶ Run</button>
                </div>
                <textarea id="code33" spellcheck="false">cheatsheet = """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              FINAL EXAM COMPLEXITY CHEATSHEET                  â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ DATA STRUCTURE      â”‚ ACCESS â”‚ SEARCH â”‚ INSERT â”‚ DELETE       â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Array               â”‚  O(1)  â”‚  O(n)  â”‚  O(n)  â”‚  O(n)        â•‘
â•‘ Linked List         â”‚  O(n)  â”‚  O(n)  â”‚  O(1)  â”‚  O(1)        â•‘
â•‘ Hash Table          â”‚  O(1)  â”‚  O(1)  â”‚  O(1)  â”‚  O(1)        â•‘
â•‘ BST (balanced)      â”‚O(logn) â”‚O(logn) â”‚O(logn) â”‚O(logn)       â•‘
â•‘ Heap                â”‚  O(1)  â”‚  O(n)  â”‚O(logn) â”‚O(logn)       â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ ALGORITHM           â”‚ TIME (AVG)    â”‚ TIME (WORST) â”‚ SPACE    â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Binary Search       â”‚ O(log n)      â”‚ O(log n)     â”‚ O(1)     â•‘
â•‘ Merge Sort          â”‚ O(n log n)    â”‚ O(n log n)   â”‚ O(n)     â•‘
â•‘ Quick Sort          â”‚ O(n log n)    â”‚ O(nÂ²)        â”‚ O(log n) â•‘
â•‘ Heap Sort           â”‚ O(n log n)    â”‚ O(n log n)   â”‚ O(1)     â•‘
â•‘ BFS/DFS             â”‚ O(V + E)      â”‚ O(V + E)     â”‚ O(V)     â•‘
â•‘ Dijkstra            â”‚ O((V+E)log V) â”‚ O((V+E)log V)â”‚ O(V)     â•‘
â•‘ Union-Find          â”‚ O(Î±(n)) â‰ˆ O(1)â”‚ O(Î±(n))      â”‚ O(n)     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ PATTERN             â”‚ TYPICAL COMPLEXITY                       â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Two Pointers        â”‚ O(n)                                     â•‘
â•‘ Sliding Window      â”‚ O(n)                                     â•‘
â•‘ Binary Search       â”‚ O(log n)                                 â•‘
â•‘ DP (1D)             â”‚ O(n) or O(n Ã— target)                    â•‘
â•‘ DP (2D)             â”‚ O(n Ã— m)                                 â•‘
â•‘ Backtracking        â”‚ O(2^n) or O(n!)                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
print(cheatsheet)</textarea>
                <div class="code-figure-output" id="outputcode33"></div>
                <div class="code-figure-caption">
                    <strong>Figure 14.33:</strong> Print and memorize this cheatsheet for your exam!
                </div>
            </div>
            
            <div class="summary">
                <div class="summary-title">Final Review Summary</div>
                <ul>
                    <li><strong>Know your data structures:</strong> When to use each and their complexities</li>
                    <li><strong>Recognize patterns:</strong> 10 key patterns cover most problems</li>
                    <li><strong>Practice systematically:</strong> Understand, plan, code, verify</li>
                    <li><strong>Handle edge cases:</strong> Empty, single, duplicates, negative</li>
                    <li><strong>Analyze complexity:</strong> Time and space for every solution</li>
                </ul>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 12: FINAL PRACTICE PROBLEMS -->
        <!-- ============================================== -->
        <section id="exercises">
            <h2>12. Final Practice Problems</h2>
            
            <!-- Exercise 1 -->
            <div class="exercise">
                <div class="exercise-title">Exercise 1: Three Sum</div>
                <p>Find all unique triplets in array that sum to zero. No duplicate triplets.</p>
                <p class="answer">(Hint: Sort array, fix one element, use two pointers for remaining two. Skip duplicates.)</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 1 â€” Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex1')">â–¶ Run</button>
                </div>
                <textarea id="ex1" spellcheck="false"># HINT 1: Sort the array first
# HINT 2: For each i, find pairs in [i+1:] that sum to -nums[i]
# HINT 3: Skip duplicates at all levels

def three_sum(nums):
    # Your code here
    pass

# Test your implementation
# print(three_sum([-1, 0, 1, 2, -1, -4]))
# Expected: [[-1, -1, 2], [-1, 0, 1]]</textarea>
                <div class="code-figure-output" id="outputex1"></div>
            </div>
            
            <!-- Exercise 2 -->
            <div class="exercise">
                <div class="exercise-title">Exercise 2: LRU Cache</div>
                <p>Design a data structure with O(1) get and put operations. When capacity is exceeded, evict least recently used item.</p>
                <p class="answer">(Hint: Use hash map for O(1) access + doubly linked list for O(1) removal/insertion.)</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 2 â€” Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex2')">â–¶ Run</button>
                </div>
                <textarea id="ex2" spellcheck="false"># HINT 1: Hash map: key -> node for O(1) lookup
# HINT 2: Doubly linked list: head = most recent, tail = least recent
# HINT 3: On access, move node to head; on evict, remove tail

class LRUCache:
    def __init__(self, capacity):
        # Your code here
        pass
    
    def get(self, key):
        # Your code here
        pass
    
    def put(self, key, value):
        # Your code here
        pass

# Test your implementation
# cache = LRUCache(2)
# cache.put(1, 1); cache.put(2, 2)
# print(cache.get(1))  # 1
# cache.put(3, 3)      # Evicts key 2
# print(cache.get(2))  # -1</textarea>
                <div class="code-figure-output" id="outputex2"></div>
            </div>
            
            <!-- Exercise 3 -->
            <div class="exercise">
                <div class="exercise-title">Exercise 3: Word Ladder</div>
                <p>Find shortest transformation sequence from beginWord to endWord, changing one letter at a time. Each intermediate word must be in wordList.</p>
                <p class="answer">(Hint: BFS where each word is a node, edges connect words differing by one letter.)</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 3 â€” Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex3')">â–¶ Run</button>
                </div>
                <textarea id="ex3" spellcheck="false"># HINT 1: Use BFS for shortest path
# HINT 2: Generate all possible next words by changing one letter
# HINT 3: Only consider words in wordList

def ladder_length(beginWord, endWord, wordList):
    # Your code here
    pass

# Test your implementation
# print(ladder_length("hit", "cog", ["hot","dot","dog","lot","log","cog"]))
# Expected: 5 (hit -> hot -> dot -> dog -> cog)</textarea>
                <div class="code-figure-output" id="outputex3"></div>
            </div>
            
            <!-- Exercise 4 -->
            <div class="exercise">
                <div class="exercise-title">Exercise 4: Maximum Product Subarray</div>
                <p>Find the contiguous subarray with the largest product.</p>
                <p class="answer">(Hint: Track both max and min products ending at each position. Min can become max with negative number.)</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 4 â€” Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex4')">â–¶ Run</button>
                </div>
                <textarea id="ex4" spellcheck="false"># HINT 1: Unlike sum, product with negative flips sign
# HINT 2: Keep track of both max and min ending at position i
# HINT 3: When num is negative, swap max and min

def max_product(nums):
    # Your code here
    pass

# Test your implementation
# print(max_product([2, 3, -2, 4]))  # 6 (subarray [2, 3])
# print(max_product([-2, 0, -1]))    # 0</textarea>
                <div class="code-figure-output" id="outputex4"></div>
            </div>
            
            <!-- Exercise 5 -->
            <div class="exercise">
                <div class="exercise-title">Exercise 5: Serialize and Deserialize Binary Tree</div>
                <p>Design an algorithm to serialize and deserialize a binary tree.</p>
                <p class="answer">(Hint: Preorder traversal with null markers. Use iterator for deserialization.)</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 5 â€” Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex5')">â–¶ Run</button>
                </div>
                <textarea id="ex5" spellcheck="false"># HINT 1: Preorder: root, left, right
# HINT 2: Use "null" or special marker for None
# HINT 3: Deserialize using iterator over tokens

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def serialize(root):
    # Your code here
    pass

def deserialize(data):
    # Your code here
    pass

# Test your implementation
# root = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5)))
# s = serialize(root)
# print(s)
# new_root = deserialize(s)</textarea>
                <div class="code-figure-output" id="outputex5"></div>
            </div>
        </section>

        <!-- SUBMIT SECTION -->
        <section class="submit-section">
            <h2>Submit Your Work</h2>
            <p>Congratulations on completing the course! Submit your final attendance below.</p>
            
            <div class="form-row">
                <div class="form-group">
                    <label>Student ID</label>
                    <input type="text" id="studentId" placeholder="Enter your student ID">
                </div>
                <div class="form-group">
                    <label>Full Name</label>
                    <input type="text" id="studentName" placeholder="Enter your full name">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>Email (@istun.edu.tr)</label>
                    <input type="email" id="studentEmail" placeholder="your.email@istun.edu.tr">
                </div>
                <div class="form-group">
                    <label>Class Code</label>
                    <input type="text" id="classCode" placeholder="From instructor">
                </div>
            </div>
            <input type="text" id="hp" class="hp" tabindex="-1" autocomplete="off">
            <button class="submit-btn" onclick="submitWork()">Submit Final Attendance</button>
            <div class="submit-status" id="submitStatus"></div>
        </section>
    </main>

    <script>
        const pageLoadTime = Date.now();
        
        async function runCode(codeId) {
            const codeEl = document.getElementById(codeId);
            const outputEl = document.getElementById('output' + codeId);
            const code = codeEl.value;
            outputEl.classList.add('show');
            outputEl.textContent = 'Loading Python...';
            
            try {
                // Wait for PyScript/Pyodide to be ready
                if (!window.pyodideReady) {
                    if (typeof loadPyodide === 'undefined') {
                        // Load Pyodide directly as fallback
                        const script = document.createElement('script');
                        script.src = 'https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js';
                        document.head.appendChild(script);
                        await new Promise((resolve, reject) => {
                            script.onload = resolve;
                            script.onerror = reject;
                            setTimeout(reject, 10000);
                        });
                    }
                    outputEl.textContent = 'Initializing Python (first run may take a moment)...';
                    window.pyodide = await loadPyodide();
                    window.pyodideReady = true;
                }
                
                outputEl.textContent = 'Running...';
                
                // Capture stdout
                window.pyodide.runPython(`
import sys
from io import StringIO
sys.stdout = StringIO()
`);
                
                try {
                    window.pyodide.runPython(code);
                } catch (pyErr) {
                    outputEl.textContent = 'Error: ' + pyErr.message;
                    return;
                }
                
                const output = window.pyodide.runPython('sys.stdout.getvalue()');
                outputEl.textContent = output || '(no output)';
                
            } catch(e) {
                outputEl.textContent = 'Error: ' + e.message;
            }
        }
        
        function submitWork() {
            const status = document.getElementById('submitStatus');
            const data = {
                week: 'Week_14',
                student_id: document.getElementById('studentId').value.trim(),
                student_name: document.getElementById('studentName').value.trim(),
                student_email: document.getElementById('studentEmail').value.trim().toLowerCase(),
                classCode: document.getElementById('classCode').value.trim().toUpperCase(),
                timeOnPage: Math.floor((Date.now() - pageLoadTime) / 1000)
            };
            
            if (document.getElementById('hp').value) {
                status.textContent = 'Submission rejected.';
                status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5';
                return;
            }
            if (data.timeOnPage < 60) {
                status.textContent = 'Please spend more time reviewing the material.';
                status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5';
                return;
            }
            if (!data.student_id || !data.student_name || !data.student_email || !data.classCode) {
                status.textContent = 'All fields are required.';
                status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5';
                return;
            }
            if (!data.student_email.endsWith('@istun.edu.tr')) {
                status.textContent = 'Use your @istun.edu.tr email.';
                status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5';
                return;
            }
            
            status.textContent = 'Submitting...';
            status.style.cssText = 'display:block;background:rgba(124,58,237,0.2);color:#a78bfa';
            
            fetch('https://script.google.com/macros/s/AKfycbzyyvKZRtR7_m05hlB7V-BCBJN3OcOBLjVTFNJ5zNcZFxsOoJMLHLvdUVk4SSqDjtXi/exec', {
                method: 'POST',
                mode: 'cors',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            })
            .then(r => r.json())
            .then(res => {
                status.textContent = res.success ? 'Course completed! Congratulations!' : res.message;
                status.style.cssText = 'display:block;background:rgba(' + (res.success ? '74,222,128' : '239,68,68') + ',0.2);color:' + (res.success ? '#4ade80' : '#fca5a5');
            })
            .catch(() => {
                fetch('https://script.google.com/macros/s/AKfycbzyyvKZRtR7_m05hlB7V-BCBJN3OcOBLjVTFNJ5zNcZFxsOoJMLHLvdUVk4SSqDjtXi/exec', {
                    method: 'POST', mode: 'no-cors',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                }).then(() => {
                    status.textContent = 'Course completed! Congratulations!';
                    status.style.cssText = 'display:block;background:rgba(74,222,128,0.2);color:#4ade80';
                });
            });
        }
    </script>
</body>
</html>
