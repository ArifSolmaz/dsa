<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 03: Arrays, Lists &amp; Strings | DSA Course</title>
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>
    <script type="module">
        // Wait for PyScript to be ready
        const pyReady = new Promise((resolve) => {
            const check = setInterval(() => {
                if (typeof pyscript !== 'undefined' && pyscript.interpreter) {
                    clearInterval(check);
                    resolve();
                }
            }, 100);
            // Timeout after 15 seconds
            setTimeout(() => { clearInterval(check); resolve(); }, 15000);
        });
        window.pyReady = pyReady;
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Crimson Pro', Georgia, serif;
            font-size: 19px;
            background: #faf9f7;
            color: #2c2c2c; 
            line-height: 1.8;
        }
        
        .topbar {
            position: sticky;
            top: 0;
            background: #1a1a2e;
            color: white;
            padding: 12px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }
        .topbar .title { font-family: system-ui, sans-serif; font-size: 0.9rem; font-weight: 500; }
        .topbar a { font-family: system-ui, sans-serif; color: white; text-decoration: none; font-size: 0.85rem; padding: 6px 14px; background: rgba(255,255,255,0.1); border-radius: 5px; }
        .topbar a:hover { background: rgba(255,255,255,0.2); }
        
        .book { max-width: 750px; margin: 0 auto; padding: 60px 40px 100px; }
        
        .chapter-header { text-align: center; padding: 50px 0 60px; border-bottom: 1px solid #ddd; margin-bottom: 50px; }
        .chapter-num { font-family: system-ui, sans-serif; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 3px; color: #7c3aed; margin-bottom: 15px; }
        .chapter-header h1 { font-size: 2.8rem; font-weight: 600; color: #1a1a2e; margin-bottom: 15px; letter-spacing: -0.5px; }
        .chapter-header .subtitle { font-style: italic; color: #666; font-size: 1.1rem; }
        
        h2 { font-size: 1.6rem; font-weight: 600; color: #1a1a2e; margin: 60px 0 25px; padding-top: 30px; border-top: 1px solid #e5e5e5; }
        h2:first-of-type { border-top: none; margin-top: 0; padding-top: 0; }
        h3 { font-size: 1.25rem; font-weight: 600; color: #333; margin: 40px 0 15px; }
        h4 { font-size: 1.05rem; font-weight: 600; color: #555; margin: 30px 0 12px; }
        
        p { margin: 0 0 20px; text-align: justify; hyphens: auto; }
        ul, ol { margin: 20px 0 25px 30px; }
        li { margin: 10px 0; }
        
        code { font-family: 'JetBrains Mono', monospace; font-size: 0.85em; background: #f0eeeb; padding: 2px 6px; border-radius: 3px; color: #7c3aed; }
        .term { font-weight: 600; color: #1a1a2e; }
        
        .definition { background: #f8f7f5; border-left: 4px solid #7c3aed; padding: 20px 25px; margin: 30px 0; }
        .definition-title { font-family: system-ui, sans-serif; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px; color: #7c3aed; margin-bottom: 8px; font-weight: 600; }
        .definition p { margin: 0; }
        
        .margin-note { background: #fffbeb; border: 1px solid #fcd34d; padding: 15px 18px; margin: 25px 0; border-radius: 4px; font-size: 0.9rem; }
        .margin-note::before { content: "üí° "; }
        
        .important { background: #fef2f2; border: 1px solid #fca5a5; padding: 15px 18px; margin: 25px 0; border-radius: 4px; font-size: 0.9rem; }
        .important::before { content: "‚ö†Ô∏è "; }
        
        .example { background: #fafafa; border: 1px solid #e5e5e5; border-radius: 6px; padding: 25px; margin: 30px 0; }
        .example-title { font-family: system-ui, sans-serif; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: #666; margin-bottom: 15px; font-weight: 600; }
        
        .code-figure { margin: 35px 0; border: 1px solid #e0e0e0; border-radius: 6px; overflow: hidden; background: #1e1e2e; }
        .code-figure-header { background: #28283c; padding: 10px 18px; display: flex; justify-content: space-between; align-items: center; }
        .code-figure-label { font-family: system-ui, sans-serif; font-size: 0.75rem; color: #a0a0b0; text-transform: uppercase; letter-spacing: 0.5px; }
        .code-figure-run { font-family: system-ui, sans-serif; background: #7c3aed; color: white; border: none; padding: 5px 14px; border-radius: 4px; font-size: 0.8rem; cursor: pointer; font-weight: 500; }
        .code-figure-run:hover { background: #6d28d9; }
        .code-figure textarea { width: 100%; min-height: 100px; padding: 18px; background: #1e1e2e; color: #e0e0e0; border: none; font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; line-height: 1.6; resize: vertical; }
        .code-figure textarea:focus { outline: none; }
        .code-figure-output { display: none; border-top: 1px solid #28283c; padding: 15px 18px; background: #161622; color: #4ade80; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; white-space: pre-wrap; }
        .code-figure-output.show { display: block; }
        .code-figure-caption { background: #f8f8f8; padding: 12px 18px; font-size: 0.85rem; color: #666; border-top: 1px solid #e0e0e0; }
        .code-figure-caption strong { color: #333; }
        
        .summary { background: linear-gradient(135deg, #7c3aed10, #7c3aed05); border: 1px solid #7c3aed30; border-radius: 8px; padding: 25px 30px; margin: 40px 0; }
        .summary-title { font-family: system-ui, sans-serif; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: #7c3aed; margin-bottom: 12px; font-weight: 600; }
        .summary ul { margin: 0; }
        
        .exercise { background: #f0fdf4; border: 1px solid #bbf7d0; border-radius: 8px; padding: 25px 30px; margin: 40px 0 20px; }
        .exercise-title { font-family: system-ui, sans-serif; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: #16a34a; margin-bottom: 12px; font-weight: 600; }
        .exercise p { margin: 0; }
        .exercise .answer { margin-top: 12px; font-size: 0.9rem; color: #166534; }
        
        table { width: 100%; border-collapse: collapse; margin: 25px 0; font-size: 0.95rem; }
        th, td { border: 1px solid #ddd; padding: 12px 15px; text-align: left; }
        th { background: #f5f5f5; font-weight: 600; }
        
        .submit-section { background: #1a1a2e; color: white; padding: 40px; border-radius: 10px; margin-top: 60px; }
        .submit-section h2 { color: white; border: none; margin: 0 0 20px; padding: 0; font-size: 1.4rem; }
        .submit-section p { color: #a0a0b0; text-align: left; }
        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; font-family: system-ui, sans-serif; font-size: 0.85rem; color: #a0a0b0; margin-bottom: 6px; }
        .form-group input { width: 100%; padding: 12px 14px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 5px; color: white; font-size: 1rem; font-family: system-ui, sans-serif; }
        .form-group input:focus { outline: none; border-color: #7c3aed; }
        .submit-btn { background: #7c3aed; color: white; border: none; padding: 14px 30px; border-radius: 6px; font-size: 1rem; font-weight: 500; cursor: pointer; font-family: system-ui, sans-serif; margin-top: 10px; }
        .submit-btn:hover { background: #6d28d9; }
        .submit-status { margin-top: 15px; padding: 12px; border-radius: 5px; display: none; font-family: system-ui, sans-serif; font-size: 0.9rem; }
        .hp { position: absolute; left: -9999px; }
        
        .toc { background: #f8f7f5; padding: 30px 35px; margin: 0 0 50px; border-radius: 6px; }
        .toc-title { font-family: system-ui, sans-serif; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 2px; color: #888; margin-bottom: 15px; }
        .toc ol { margin: 0; padding-left: 20px; }
        .toc li { margin: 8px 0; }
        .toc a { color: #7c3aed; text-decoration: none; }
        .toc a:hover { text-decoration: underline; }
        
        @media (max-width: 600px) {
            .book { padding: 30px 20px; }
            .chapter-header h1 { font-size: 2rem; }
            h2 { font-size: 1.4rem; }
            .form-row { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <nav class="topbar">
        <span class="title">Data Structures &amp; Algorithms</span>
        <a href="index.html?home=true">‚Üê Course Home</a>
    </nav>
    
    <main class="book">
        <header class="chapter-header">
            <div class="chapter-num">Week Three</div>
            <h1>Arrays, Lists &amp; Strings</h1>
            <p class="subtitle">Sequential data structures and their operations</p>
        </header>
        
        <nav class="toc">
            <div class="toc-title">Contents</div>
            <ol>
                <li><a href="#intro">What are Arrays and Lists?</a></li>
                <li><a href="#python-lists">Python Lists: Dynamic Arrays</a></li>
                <li><a href="#complexity">List Operations and Complexity</a></li>
                <li><a href="#patterns">Common Array Patterns</a></li>
                <li><a href="#strings">String Fundamentals</a></li>
                <li><a href="#string-ops">String Operations and Methods</a></li>
                <li><a href="#string-algos">String Algorithms</a></li>
                <li><a href="#2d-arrays">Working with 2D Arrays</a></li>
                <li><a href="#memory">Memory Considerations</a></li>
                <li><a href="#pitfalls">Common Pitfalls</a></li>
                <li><a href="#exercises">Exercises</a></li>
            </ol>
        </nav>

        <!-- ============================================== -->
        <!-- SECTION 1: WHAT ARE ARRAYS AND LISTS -->
        <!-- ============================================== -->
        <section id="intro">
            <h2>1. What are Arrays and Lists?</h2>
            
            <p>In the previous weeks, we learned about fundamental programming concepts and recursion. Now we turn to the most ubiquitous data structure in computing: the <span class="term">array</span>. Arrays and their Python equivalent‚Äîlists‚Äîform the backbone of virtually every program you'll write.</p>
            
            <div class="definition">
                <div class="definition-title">Definition</div>
                <p>An <span class="term">array</span> is a contiguous block of memory that stores a fixed-size sequence of elements of the same type. Each element can be accessed directly by its numerical <span class="term">index</span> (position), starting from 0. This direct access is called <span class="term">random access</span> and takes O(1) time.</p>
            </div>
            
            <p>The power of arrays comes from their memory layout. Because elements are stored consecutively in memory, the computer can calculate the exact memory address of any element instantly using the formula: <code>address = base_address + index √ó element_size</code>.</p>
            
            <h3>Arrays in Memory</h3>
            
            <div class="example">
                <div class="example-title">Memory Layout of an Array</div>
                <p>Consider an array of 5 integers starting at memory address 1000, where each integer takes 4 bytes:</p>
                <pre style="font-family: 'JetBrains Mono', monospace; font-size: 0.85rem;">
Index:     0      1      2      3      4
Value:   [10]   [20]   [30]   [40]   [50]
Address: 1000   1004   1008   1012   1016

To access arr[3]:
  address = 1000 + 3 √ó 4 = 1012
  ‚Üí Directly read value 40 from address 1012
                </pre>
                <p>This calculation takes constant time regardless of array size‚Äîhence O(1) access.</p>
            </div>
            
            <h3>Arrays vs Lists</h3>
            
            <p>Traditional arrays (as in C, Java) have fixed size and store elements of a single type. Python's <code>list</code> is more flexible:</p>
            
            <table>
                <tr>
                    <th>Feature</th>
                    <th>Traditional Array</th>
                    <th>Python List</th>
                </tr>
                <tr>
                    <td>Size</td>
                    <td>Fixed at creation</td>
                    <td>Dynamic (grows/shrinks)</td>
                </tr>
                <tr>
                    <td>Element types</td>
                    <td>Homogeneous (same type)</td>
                    <td>Heterogeneous (mixed types)</td>
                </tr>
                <tr>
                    <td>Memory</td>
                    <td>Contiguous values</td>
                    <td>Contiguous references</td>
                </tr>
                <tr>
                    <td>Access time</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                </tr>
            </table>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.1 ‚Äî Creating and Accessing Lists</span>
                    <button class="code-figure-run" onclick="runCode('code1')">‚ñ∂ Run</button>
                </div>
                <textarea id="code1" spellcheck="false"># Creating lists in Python
numbers = [10, 20, 30, 40, 50]      # List of integers
mixed = [1, "hello", 3.14, True]    # Mixed types allowed
empty = []                          # Empty list
nested = [[1, 2], [3, 4], [5, 6]]   # Nested lists (2D array)

# Accessing elements by index (O(1) operation)
print(f"First element: {numbers[0]}")      # Index 0
print(f"Third element: {numbers[2]}")      # Index 2
print(f"Last element: {numbers[-1]}")      # Negative index
print(f"Second to last: {numbers[-2]}")

# Accessing nested elements
print(f"Nested [1][0]: {nested[1][0]}")    # Row 1, Column 0 = 3

# Length of list
print(f"Length: {len(numbers)}")</textarea>
                <div class="code-figure-output" id="outputcode1"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.1:</strong> Python lists support O(1) random access using positive or negative indices.
                </div>
            </div>
            
            <div class="margin-note">
                Python uses zero-based indexing: the first element is at index 0, the second at index 1, etc. Negative indices count from the end: -1 is the last element, -2 is second-to-last, and so on.
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 2: PYTHON LISTS -->
        <!-- ============================================== -->
        <section id="python-lists">
            <h2>2. Python Lists: Dynamic Arrays</h2>
            
            <p>Python lists are implemented as <span class="term">dynamic arrays</span>. Unlike fixed-size arrays, they can grow and shrink as needed. Understanding how this works is crucial for writing efficient code.</p>
            
            <div class="definition">
                <div class="definition-title">Definition</div>
                <p>A <span class="term">dynamic array</span> is an array that automatically resizes itself when it runs out of space. When full, it allocates a new, larger array (typically 1.5√ó to 2√ó the current size), copies all elements, and deallocates the old array. This strategy gives O(1) <em>amortized</em> time for appends.</p>
            </div>
            
            <h3>How Dynamic Arrays Grow</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.2 ‚Äî Observing Dynamic Array Growth</span>
                    <button class="code-figure-run" onclick="runCode('code2')">‚ñ∂ Run</button>
                </div>
                <textarea id="code2" spellcheck="false">import sys

# Watch how list memory grows
sizes = []
lst = []

for i in range(20):
    lst.append(i)
    size = sys.getsizeof(lst)
    if not sizes or size != sizes[-1]:
        sizes.append(size)
        print(f"Length {len(lst):2d}: {size} bytes (capacity increased)")
    
print(f"\nFinal list: {lst}")
print(f"\nThe list grew {len(sizes)} times in {len(lst)} appends")
print("Each resize allocates extra space to minimize future resizes")</textarea>
                <div class="code-figure-output" id="outputcode2"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.2:</strong> Python lists over-allocate memory to minimize resizing. Size increases happen less frequently as the list grows.
                </div>
            </div>
            
            <h3>Creating Lists</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.3 ‚Äî Multiple Ways to Create Lists</span>
                    <button class="code-figure-run" onclick="runCode('code3')">‚ñ∂ Run</button>
                </div>
                <textarea id="code3" spellcheck="false"># Method 1: Literal notation
fruits = ["apple", "banana", "cherry"]
print(f"Literal: {fruits}")

# Method 2: list() constructor
chars = list("hello")  # Convert string to list of characters
print(f"From string: {chars}")

# Method 3: List comprehension (Pythonic!)
squares = [x**2 for x in range(10)]
print(f"Squares: {squares}")

evens = [x for x in range(20) if x % 2 == 0]
print(f"Evens: {evens}")

# Method 4: Repetition operator
zeros = [0] * 5
print(f"Five zeros: {zeros}")

# Method 5: range() conversion
one_to_ten = list(range(1, 11))
print(f"1 to 10: {one_to_ten}")

# Method 6: Split a string
words = "hello world python".split()
print(f"Split words: {words}")</textarea>
                <div class="code-figure-output" id="outputcode3"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.3:</strong> Python provides many ways to create lists. List comprehensions are the most Pythonic for transformations.
                </div>
            </div>
            
            <h3>Slicing: Extracting Sublists</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.4 ‚Äî List Slicing</span>
                    <button class="code-figure-run" onclick="runCode('code4')">‚ñ∂ Run</button>
                </div>
                <textarea id="code4" spellcheck="false"># Slicing syntax: list[start:stop:step]
nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print(f"Original: {nums}")
print()

# Basic slicing (stop is EXCLUSIVE)
print(f"nums[2:7]  = {nums[2:7]}")      # Elements 2,3,4,5,6
print(f"nums[:5]   = {nums[:5]}")       # First 5 elements
print(f"nums[5:]   = {nums[5:]}")       # From index 5 to end
print(f"nums[:]    = {nums[:]}")        # Full copy
print()

# With step
print(f"nums[::2]  = {nums[::2]}")      # Every 2nd element
print(f"nums[1::2] = {nums[1::2]}")     # Odd indices
print(f"nums[::-1] = {nums[::-1]}")     # Reversed
print(f"nums[7:2:-1] = {nums[7:2:-1]}") # Backwards from 7 to 3
print()

# Slicing creates a NEW list (shallow copy)
original = [1, 2, 3]
copy = original[:]
copy[0] = 999
print(f"Original after modifying copy: {original}")  # Unchanged!</textarea>
                <div class="code-figure-output" id="outputcode4"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.4:</strong> Slicing uses <code>[start:stop:step]</code> syntax. The stop index is exclusive. Slicing creates a shallow copy.
                </div>
            </div>
            
            <div class="important">
                Slicing creates a <strong>new list</strong> containing copies of the references. For a list of integers or strings, this behaves like a full copy. For a list of lists (or other mutable objects), the inner objects are still shared!
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 3: LIST OPERATIONS AND COMPLEXITY -->
        <!-- ============================================== -->
        <section id="complexity">
            <h2>3. List Operations and Complexity</h2>
            
            <p>Understanding the time complexity of list operations is essential for writing efficient algorithms. Some operations are fast (O(1)), others are slow (O(n)).</p>
            
            <h3>Time Complexity Table</h3>
            
            <table>
                <tr>
                    <th>Operation</th>
                    <th>Example</th>
                    <th>Time</th>
                    <th>Notes</th>
                </tr>
                <tr>
                    <td>Index access</td>
                    <td><code>lst[i]</code></td>
                    <td>O(1)</td>
                    <td>Direct memory calculation</td>
                </tr>
                <tr>
                    <td>Index assignment</td>
                    <td><code>lst[i] = x</code></td>
                    <td>O(1)</td>
                    <td>Direct memory write</td>
                </tr>
                <tr>
                    <td>Append</td>
                    <td><code>lst.append(x)</code></td>
                    <td>O(1)*</td>
                    <td>Amortized; occasional O(n) resize</td>
                </tr>
                <tr>
                    <td>Pop last</td>
                    <td><code>lst.pop()</code></td>
                    <td>O(1)</td>
                    <td>Remove from end</td>
                </tr>
                <tr>
                    <td>Pop at index</td>
                    <td><code>lst.pop(i)</code></td>
                    <td>O(n)</td>
                    <td>Must shift elements</td>
                </tr>
                <tr>
                    <td>Insert</td>
                    <td><code>lst.insert(i, x)</code></td>
                    <td>O(n)</td>
                    <td>Must shift elements right</td>
                </tr>
                <tr>
                    <td>Delete</td>
                    <td><code>del lst[i]</code></td>
                    <td>O(n)</td>
                    <td>Must shift elements left</td>
                </tr>
                <tr>
                    <td>Membership</td>
                    <td><code>x in lst</code></td>
                    <td>O(n)</td>
                    <td>Linear search</td>
                </tr>
                <tr>
                    <td>Length</td>
                    <td><code>len(lst)</code></td>
                    <td>O(1)</td>
                    <td>Stored as attribute</td>
                </tr>
                <tr>
                    <td>Slice</td>
                    <td><code>lst[a:b]</code></td>
                    <td>O(b-a)</td>
                    <td>Copies k elements</td>
                </tr>
                <tr>
                    <td>Concatenate</td>
                    <td><code>lst1 + lst2</code></td>
                    <td>O(n+m)</td>
                    <td>Creates new list</td>
                </tr>
                <tr>
                    <td>Sort</td>
                    <td><code>lst.sort()</code></td>
                    <td>O(n log n)</td>
                    <td>Timsort algorithm</td>
                </tr>
                <tr>
                    <td>Reverse</td>
                    <td><code>lst.reverse()</code></td>
                    <td>O(n)</td>
                    <td>In-place swap</td>
                </tr>
                <tr>
                    <td>Copy</td>
                    <td><code>lst.copy()</code></td>
                    <td>O(n)</td>
                    <td>Shallow copy</td>
                </tr>
            </table>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.5 ‚Äî Demonstrating Operation Complexities</span>
                    <button class="code-figure-run" onclick="runCode('code5')">‚ñ∂ Run</button>
                </div>
                <textarea id="code5" spellcheck="false">import time

def measure_time(func, *args):
    """Measure execution time of a function."""
    start = time.perf_counter()
    result = func(*args)
    end = time.perf_counter()
    return (end - start) * 1000  # milliseconds

# Compare append vs insert at beginning
n = 10000

# Append at end: O(1) amortized
lst1 = []
time1 = measure_time(lambda: [lst1.append(i) for i in range(n)])
print(f"Append {n} elements: {time1:.2f} ms")

# Insert at beginning: O(n) each time = O(n¬≤) total!
lst2 = []
time2 = measure_time(lambda: [lst2.insert(0, i) for i in range(n)])
print(f"Insert at front {n} elements: {time2:.2f} ms")

print(f"\nInsert at front is {time2/time1:.1f}x slower!")
print("This is because insert(0, x) shifts ALL elements each time.")</textarea>
                <div class="code-figure-output" id="outputcode5"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.5:</strong> Appending is O(1), but inserting at the front is O(n) per operation‚Äîa huge difference at scale.
                </div>
            </div>
            
            <h3>Membership Testing: List vs Set</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.6 ‚Äî List vs Set Membership</span>
                    <button class="code-figure-run" onclick="runCode('code6')">‚ñ∂ Run</button>
                </div>
                <textarea id="code6" spellcheck="false">import time

n = 100000
data_list = list(range(n))
data_set = set(range(n))

# Search for elements (worst case: not found)
test_values = [-1, -2, -3, -4, -5]  # Not in collections

# List membership: O(n) - must check every element
start = time.perf_counter()
for v in test_values:
    _ = v in data_list
list_time = (time.perf_counter() - start) * 1000

# Set membership: O(1) average - hash lookup
start = time.perf_counter()
for v in test_values:
    _ = v in data_set
set_time = (time.perf_counter() - start) * 1000

print(f"Collection size: {n:,}")
print(f"List 'in' check: {list_time:.3f} ms")
print(f"Set 'in' check:  {set_time:.3f} ms")
print(f"\nSet is {list_time/set_time:.0f}x faster for membership tests!")
print("\nLesson: Use sets when you need frequent membership checks.")</textarea>
                <div class="code-figure-output" id="outputcode6"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.6:</strong> Set membership is O(1) vs O(n) for lists. Convert to a set if you need repeated lookups.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.7 ‚Äî Common List Methods</span>
                    <button class="code-figure-run" onclick="runCode('code7')">‚ñ∂ Run</button>
                </div>
                <textarea id="code7" spellcheck="false"># Modifying lists
nums = [3, 1, 4, 1, 5, 9, 2, 6]
print(f"Original: {nums}")

# append() - O(1) amortized
nums.append(5)
print(f"After append(5): {nums}")

# extend() - O(k) where k is length of iterable
nums.extend([3, 5])
print(f"After extend([3, 5]): {nums}")

# insert() - O(n)
nums.insert(0, 0)
print(f"After insert(0, 0): {nums}")

# remove() - O(n), removes first occurrence
nums.remove(5)
print(f"After remove(5): {nums}")

# pop() - O(1) for last, O(n) for others
last = nums.pop()
print(f"After pop(): {nums}, removed: {last}")

first = nums.pop(0)
print(f"After pop(0): {nums}, removed: {first}")

# Searching
nums = [3, 1, 4, 1, 5, 9, 2, 6]
print(f"\nSearching in {nums}:")
print(f"  index(4): {nums.index(4)}")      # First occurrence
print(f"  count(1): {nums.count(1)}")      # Count occurrences

# Sorting and reversing
nums_copy = nums.copy()
nums_copy.sort()
print(f"\nSorted: {nums_copy}")

nums_copy.sort(reverse=True)
print(f"Reverse sorted: {nums_copy}")

nums_copy.reverse()
print(f"Reversed again: {nums_copy}")</textarea>
                <div class="code-figure-output" id="outputcode7"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.7:</strong> Common list methods and their usage. Note which ones modify in-place vs return new lists.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 4: COMMON ARRAY PATTERNS -->
        <!-- ============================================== -->
        <section id="patterns">
            <h2>4. Common Array Patterns</h2>
            
            <p>Many array problems can be solved using a small set of patterns. Mastering these patterns makes you much more effective at solving algorithmic problems.</p>
            
            <h3>Pattern A: Linear Scan</h3>
            
            <p>The simplest pattern: iterate through the array once, processing each element. Time complexity: O(n).</p>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.8 ‚Äî Linear Scan Pattern</span>
                    <button class="code-figure-run" onclick="runCode('code8')">‚ñ∂ Run</button>
                </div>
                <textarea id="code8" spellcheck="false"># Linear scan: O(n) time, O(1) space

def find_max(arr):
    """Find maximum element with linear scan."""
    if not arr:
        return None
    max_val = arr[0]
    for x in arr[1:]:
        if x > max_val:
            max_val = x
    return max_val

def find_second_max(arr):
    """Find second largest element."""
    if len(arr) < 2:
        return None
    first = second = float('-inf')
    for x in arr:
        if x > first:
            second = first
            first = x
        elif x > second and x != first:
            second = x
    return second if second != float('-inf') else None

def count_positives(arr):
    """Count positive numbers."""
    count = 0
    for x in arr:
        if x > 0:
            count += 1
    return count

# Tests
nums = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
print(f"Array: {nums}")
print(f"Maximum: {find_max(nums)}")
print(f"Second maximum: {find_second_max(nums)}")
print(f"Positive count: {count_positives(nums)}")</textarea>
                <div class="code-figure-output" id="outputcode8"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.8:</strong> Linear scan processes each element once. Track running values (max, count, sum) as you go.
                </div>
            </div>
            
            <h3>Pattern B: Two Pointers</h3>
            
            <p>Use two indices that move toward each other or in the same direction. Often reduces O(n¬≤) to O(n).</p>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.9 ‚Äî Two Pointers Pattern</span>
                    <button class="code-figure-run" onclick="runCode('code9')">‚ñ∂ Run</button>
                </div>
                <textarea id="code9" spellcheck="false"># Two pointers: often O(n) time, O(1) space

def reverse_in_place(arr):
    """Reverse array using two pointers."""
    left, right = 0, len(arr) - 1
    while left < right:
        arr[left], arr[right] = arr[right], arr[left]
        left += 1
        right -= 1
    return arr

def is_palindrome(s):
    """Check if string is palindrome using two pointers."""
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True

def two_sum_sorted(arr, target):
    """Find two numbers that sum to target in sorted array."""
    left, right = 0, len(arr) - 1
    while left < right:
        current_sum = arr[left] + arr[right]
        if current_sum == target:
            return (left, right)
        elif current_sum < target:
            left += 1    # Need larger sum
        else:
            right -= 1   # Need smaller sum
    return None

# Tests
nums = [1, 2, 3, 4, 5]
print(f"Original: {nums}")
print(f"Reversed: {reverse_in_place(nums.copy())}")

print(f"\nis_palindrome('racecar'): {is_palindrome('racecar')}")
print(f"is_palindrome('hello'): {is_palindrome('hello')}")

sorted_arr = [1, 2, 4, 6, 8, 10]
print(f"\ntwo_sum_sorted({sorted_arr}, 10): {two_sum_sorted(sorted_arr, 10)}")</textarea>
                <div class="code-figure-output" id="outputcode9"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.9:</strong> Two pointers from opposite ends is ideal for palindrome checks, reversal, and sorted-array problems.
                </div>
            </div>
            
            <h3>Pattern C: Sliding Window</h3>
            
            <p>Maintain a "window" of elements and slide it across the array. Perfect for substring/subarray problems.</p>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.10 ‚Äî Sliding Window Pattern</span>
                    <button class="code-figure-run" onclick="runCode('code10')">‚ñ∂ Run</button>
                </div>
                <textarea id="code10" spellcheck="false"># Sliding window: O(n) time, O(1) or O(k) space

def max_sum_subarray(arr, k):
    """Find maximum sum of any k consecutive elements."""
    if len(arr) < k:
        return None
    
    # Initialize window
    window_sum = sum(arr[:k])
    max_sum = window_sum
    
    # Slide window: add new element, remove old element
    for i in range(k, len(arr)):
        window_sum += arr[i] - arr[i - k]
        max_sum = max(max_sum, window_sum)
    
    return max_sum

def longest_unique_substring(s):
    """Find length of longest substring without repeating chars."""
    seen = {}          # char -> last index
    max_length = 0
    start = 0          # Window start
    
    for end, char in enumerate(s):
        if char in seen and seen[char] >= start:
            start = seen[char] + 1  # Move window past duplicate
        seen[char] = end
        max_length = max(max_length, end - start + 1)
    
    return max_length

# Tests
arr = [2, 1, 5, 1, 3, 2]
print(f"Array: {arr}")
print(f"Max sum of 3 consecutive: {max_sum_subarray(arr, 3)}")

s = "abcabcbb"
print(f"\nString: '{s}'")
print(f"Longest unique substring length: {longest_unique_substring(s)}")

s2 = "pwwkew"
print(f"\nString: '{s2}'")
print(f"Longest unique substring length: {longest_unique_substring(s2)}")</textarea>
                <div class="code-figure-output" id="outputcode10"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.10:</strong> Sliding window maintains a running computation, updating efficiently as the window moves.
                </div>
            </div>
            
            <h3>Pattern D: Frequency Counting</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.11 ‚Äî Frequency Counting Pattern</span>
                    <button class="code-figure-run" onclick="runCode('code11')">‚ñ∂ Run</button>
                </div>
                <textarea id="code11" spellcheck="false"># Frequency counting: O(n) time, O(k) space (k = unique elements)
from collections import Counter

def find_majority(arr):
    """Find element appearing more than n/2 times."""
    counts = {}
    for x in arr:
        counts[x] = counts.get(x, 0) + 1
        if counts[x] > len(arr) // 2:
            return x
    return None

def find_duplicates(arr):
    """Find all duplicates in array."""
    counts = Counter(arr)
    return [x for x, c in counts.items() if c > 1]

def are_anagrams(s1, s2):
    """Check if two strings are anagrams."""
    if len(s1) != len(s2):
        return False
    return Counter(s1) == Counter(s2)

def first_unique_char(s):
    """Find first non-repeating character."""
    counts = Counter(s)
    for i, char in enumerate(s):
        if counts[char] == 1:
            return i
    return -1

# Tests
arr = [2, 2, 1, 1, 1, 2, 2]
print(f"Array: {arr}")
print(f"Majority element: {find_majority(arr)}")

arr2 = [1, 2, 3, 2, 4, 3, 5]
print(f"\nArray: {arr2}")
print(f"Duplicates: {find_duplicates(arr2)}")

print(f"\nare_anagrams('listen', 'silent'): {are_anagrams('listen', 'silent')}")
print(f"are_anagrams('hello', 'world'): {are_anagrams('hello', 'world')}")

print(f"\nfirst_unique_char('leetcode'): {first_unique_char('leetcode')}")</textarea>
                <div class="code-figure-output" id="outputcode11"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.11:</strong> Frequency counting uses a dictionary/Counter to track occurrences. Essential for anagrams, duplicates, and majority elements.
                </div>
            </div>
            
            <h3>Pattern E: Prefix Sum</h3>
            
            <p>Precompute cumulative sums to answer range sum queries in O(1) after O(n) preprocessing.</p>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.30 ‚Äî Prefix Sum Pattern</span>
                    <button class="code-figure-run" onclick="runCode('code12a')">‚ñ∂ Run</button>
                </div>
                <textarea id="code12a" spellcheck="false"># Prefix sum: O(n) preprocessing, O(1) range queries

def build_prefix_sum(arr):
    """Build prefix sum array. prefix[i] = sum of arr[0:i]"""
    prefix = [0] * (len(arr) + 1)
    for i in range(len(arr)):
        prefix[i + 1] = prefix[i] + arr[i]
    return prefix

def range_sum(prefix, left, right):
    """Sum of arr[left:right+1] using prefix sums."""
    return prefix[right + 1] - prefix[left]

def subarray_sum_equals_k(arr, k):
    """Count subarrays with sum equal to k."""
    count = 0
    prefix_sum = 0
    seen = {0: 1}  # prefix_sum -> count
    
    for num in arr:
        prefix_sum += num
        # If prefix_sum - k exists, we found subarrays summing to k
        if prefix_sum - k in seen:
            count += seen[prefix_sum - k]
        seen[prefix_sum] = seen.get(prefix_sum, 0) + 1
    
    return count

# Tests
arr = [1, 2, 3, 4, 5]
prefix = build_prefix_sum(arr)
print(f"Array: {arr}")
print(f"Prefix sums: {prefix}")
print(f"Sum of arr[1:4] = {range_sum(prefix, 1, 3)}")  # 2+3+4 = 9

arr2 = [1, 1, 1]
print(f"\nSubarrays with sum=2 in {arr2}: {subarray_sum_equals_k(arr2, 2)}")</textarea>
                <div class="code-figure-output" id="outputcode12a"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.30:</strong> Prefix sums enable O(1) range sum queries after O(n) preprocessing.
                </div>
            </div>
            
            <h3>Pattern F: In-place Array Modification</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.31 ‚Äî In-place Modifications</span>
                    <button class="code-figure-run" onclick="runCode('code12b')">‚ñ∂ Run</button>
                </div>
                <textarea id="code12b" spellcheck="false"># In-place modifications: O(1) extra space

def remove_duplicates_sorted(arr):
    """Remove duplicates from sorted array in-place. Return new length."""
    if not arr:
        return 0
    
    write_idx = 1
    for read_idx in range(1, len(arr)):
        if arr[read_idx] != arr[read_idx - 1]:
            arr[write_idx] = arr[read_idx]
            write_idx += 1
    
    return write_idx

def partition(arr, pivot):
    """Partition array around pivot value (Dutch National Flag)."""
    low, mid, high = 0, 0, len(arr) - 1
    
    while mid <= high:
        if arr[mid] < pivot:
            arr[low], arr[mid] = arr[mid], arr[low]
            low += 1
            mid += 1
        elif arr[mid] > pivot:
            arr[mid], arr[high] = arr[high], arr[mid]
            high -= 1
        else:
            mid += 1
    return arr

# Tests
arr = [1, 1, 2, 2, 2, 3, 4, 4, 5]
print(f"Original: {arr}")
new_len = remove_duplicates_sorted(arr)
print(f"After remove_duplicates: {arr[:new_len]} (length={new_len})")

arr2 = [3, 1, 4, 1, 5, 9, 2, 6]
print(f"\nPartition {arr2} around 4:")
print(f"Result: {partition(arr2.copy(), 4)}")</textarea>
                <div class="code-figure-output" id="outputcode12b"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.31:</strong> In-place algorithms use O(1) extra space by carefully managing read/write pointers.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 5: STRING FUNDAMENTALS -->
        <!-- ============================================== -->
        <section id="strings">
            <h2>5. String Fundamentals</h2>
            
            <p>Strings in Python are sequences of characters, similar to lists in many ways but with one crucial difference: strings are <span class="term">immutable</span>.</p>
            
            <div class="definition">
                <div class="definition-title">Definition</div>
                <p>A <span class="term">string</span> is an immutable sequence of Unicode characters. <span class="term">Immutable</span> means once created, a string cannot be modified‚Äîany "modification" actually creates a new string object.</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.30 ‚Äî String Immutability</span>
                    <button class="code-figure-run" onclick="runCode('code12')">‚ñ∂ Run</button>
                </div>
                <textarea id="code12" spellcheck="false"># Strings are immutable
s = "hello"
print(f"Original string: '{s}'")
print(f"Memory id: {id(s)}")

# This creates a NEW string, doesn't modify the original
s = s + " world"
print(f"\nAfter concatenation: '{s}'")
print(f"Memory id: {id(s)}")  # Different id!

# You CANNOT modify individual characters
s = "hello"
try:
    s[0] = 'H'  # This will raise an error
except TypeError as e:
    print(f"\nError: {e}")

# Instead, create a new string
s = 'H' + s[1:]
print(f"Workaround result: '{s}'")</textarea>
                <div class="code-figure-output" id="outputcode12"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.30:</strong> Strings cannot be modified in place. Every "modification" creates a new string object.
                </div>
            </div>
            
            <div class="important">
                Because strings are immutable, concatenating strings in a loop is O(n¬≤) in the worst case! Each concatenation creates a new string and copies all previous characters. Use <code>join()</code> instead.
            </div>
            
            <h3>String Creation and Indexing</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.31 ‚Äî String Basics</span>
                    <button class="code-figure-run" onclick="runCode('code13')">‚ñ∂ Run</button>
                </div>
                <textarea id="code13" spellcheck="false"># Creating strings
single = 'Hello'
double = "Hello"
triple = '''Multi
line
string'''
raw = r"C:\new\folder"  # Raw string, no escaping

print(f"Single: {single}")
print(f"Double: {double}")
print(f"Triple: {triple}")
print(f"Raw: {raw}")

# Indexing (same as lists)
s = "Python"
print(f"\nString: '{s}'")
print(f"s[0]  = '{s[0]}'")   # First character
print(f"s[-1] = '{s[-1]}'")  # Last character
print(f"s[1:4] = '{s[1:4]}'") # Slice
print(f"s[::-1] = '{s[::-1]}'") # Reversed

# Iterating
print("\nCharacters:")
for i, char in enumerate(s):
    print(f"  s[{i}] = '{char}'")</textarea>
                <div class="code-figure-output" id="outputcode13"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.31:</strong> Strings support indexing and slicing just like lists, but they're immutable.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 6: STRING OPERATIONS -->
        <!-- ============================================== -->
        <section id="string-ops">
            <h2>6. String Operations and Methods</h2>
            
            <p>Python strings have a rich set of built-in methods for searching, transforming, and parsing text.</p>
            
            <h3>Searching and Finding</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.30 ‚Äî String Searching</span>
                    <button class="code-figure-run" onclick="runCode('code14')">‚ñ∂ Run</button>
                </div>
                <textarea id="code14" spellcheck="false">s = "hello world, hello python"

# Membership test
print(f"'world' in s: {'world' in s}")
print(f"'java' in s: {'java' in s}")

# find() - returns index or -1
print(f"\ns.find('hello'): {s.find('hello')}")
print(f"s.find('hello', 5): {s.find('hello', 5)}")  # Start from index 5
print(f"s.find('java'): {s.find('java')}")  # -1 if not found

# index() - like find() but raises ValueError if not found
print(f"\ns.index('world'): {s.index('world')}")

# count() - count occurrences
print(f"\ns.count('hello'): {s.count('hello')}")
print(f"s.count('l'): {s.count('l')}")

# startswith() and endswith()
print(f"\ns.startswith('hello'): {s.startswith('hello')}")
print(f"s.endswith('python'): {s.endswith('python')}")</textarea>
                <div class="code-figure-output" id="outputcode14"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.30:</strong> String searching methods. Use <code>find()</code> when you want -1 for not found; use <code>index()</code> when absence should raise an error.
                </div>
            </div>
            
            <h3>Transformations</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.31 ‚Äî String Transformations</span>
                    <button class="code-figure-run" onclick="runCode('code15')">‚ñ∂ Run</button>
                </div>
                <textarea id="code15" spellcheck="false">s = "  Hello, World!  "
print(f"Original: '{s}'")

# Case transformations
print(f"lower(): '{s.lower()}'")
print(f"upper(): '{s.upper()}'")
print(f"capitalize(): '{s.capitalize()}'")
print(f"title(): '{s.title()}'")
print(f"swapcase(): '{s.swapcase()}'")

# Whitespace handling
print(f"\nstrip(): '{s.strip()}'")
print(f"lstrip(): '{s.lstrip()}'")
print(f"rstrip(): '{s.rstrip()}'")

# Replacement
print(f"\nreplace('World', 'Python'): '{s.replace('World', 'Python')}'")

# Alignment and padding
text = "Python"
print(f"\nPadding '{text}':")
print(f"center(20, '-'): '{text.center(20, '-')}'")
print(f"ljust(20, '.'): '{text.ljust(20, '.')}'")
print(f"rjust(20, '.'): '{text.rjust(20, '.')}'")
print(f"zfill(10): '{text.zfill(10)}'")</textarea>
                <div class="code-figure-output" id="outputcode15"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.31:</strong> All string methods return new strings. The original is never modified.
                </div>
            </div>
            
            <h3>Splitting and Joining</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.30 ‚Äî Split and Join</span>
                    <button class="code-figure-run" onclick="runCode('code16')">‚ñ∂ Run</button>
                </div>
                <textarea id="code16" spellcheck="false"># split() - string to list
sentence = "Python is awesome"
words = sentence.split()
print(f"split(): {words}")

csv_line = "apple,banana,cherry"
fruits = csv_line.split(',')
print(f"split(','): {fruits}")

# split with maxsplit
text = "a:b:c:d:e"
print(f"split(':', 2): {text.split(':', 2)}")

# splitlines()
multiline = "Line 1\nLine 2\nLine 3"
lines = multiline.splitlines()
print(f"splitlines(): {lines}")

# join() - list to string (EFFICIENT!)
words = ['Python', 'is', 'awesome']
print(f"\njoin with space: '{' '.join(words)}'")
print(f"join with dash: '{'-'.join(words)}'")
print(f"join with nothing: '{''.join(words)}'")

# IMPORTANT: join() is O(n), concatenation in loop is O(n¬≤)
# BAD: s = ''; for w in words: s += w + ' '
# GOOD: ' '.join(words)</textarea>
                <div class="code-figure-output" id="outputcode16"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.30:</strong> Use <code>split()</code> to parse strings and <code>join()</code> to combine them efficiently.
                </div>
            </div>
            
            <h3>Validation Methods</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.31 ‚Äî String Validation</span>
                    <button class="code-figure-run" onclick="runCode('code17')">‚ñ∂ Run</button>
                </div>
                <textarea id="code17" spellcheck="false"># Validation methods return True/False
test_strings = ["Hello", "hello123", "12345", "   ", "Hello World", ""]

print(f"{'String':<15} {'alpha':<7} {'alnum':<7} {'digit':<7} {'space':<7}")
print("-" * 45)

for s in test_strings:
    display = f"'{s}'" if s else "''"
    print(f"{display:<15} {str(s.isalpha()):<7} {str(s.isalnum()):<7} "
          f"{str(s.isdigit()):<7} {str(s.isspace()):<7}")

# Other useful checks
s = "Hello World"
print(f"\n'{s}':")
print(f"  islower(): {s.islower()}")
print(f"  isupper(): {s.isupper()}")
print(f"  istitle(): {s.istitle()}")  # Title Case?

num = "12345"
print(f"\n'{num}':")
print(f"  isdecimal(): {num.isdecimal()}")
print(f"  isnumeric(): {num.isnumeric()}")</textarea>
                <div class="code-figure-output" id="outputcode17"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.31:</strong> Validation methods help check string content without manual iteration.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 7: STRING ALGORITHMS -->
        <!-- ============================================== -->
        <section id="string-algos">
            <h2>7. String Algorithms</h2>
            
            <p>Let's implement some common string algorithms that appear frequently in interviews and real-world applications.</p>
            
            <h3>Palindrome Variations</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.30 ‚Äî Palindrome Algorithms</span>
                    <button class="code-figure-run" onclick="runCode('code18')">‚ñ∂ Run</button>
                </div>
                <textarea id="code18" spellcheck="false"># Various palindrome checks

def is_palindrome_simple(s):
    """Simple palindrome check using slicing."""
    return s == s[::-1]

def is_palindrome_two_pointer(s):
    """Palindrome check using two pointers (O(1) extra space)."""
    left, right = 0, len(s) - 1
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True

def is_palindrome_alphanumeric(s):
    """Check palindrome ignoring non-alphanumeric characters."""
    # Filter and lowercase
    filtered = ''.join(c.lower() for c in s if c.isalnum())
    return filtered == filtered[::-1]

def longest_palindrome_substring(s):
    """Find longest palindromic substring using expand around center."""
    if len(s) < 2:
        return s
    
    def expand(left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left + 1:right]
    
    longest = ""
    for i in range(len(s)):
        # Odd length palindrome
        p1 = expand(i, i)
        # Even length palindrome
        p2 = expand(i, i + 1)
        longest = max(longest, p1, p2, key=len)
    
    return longest

# Tests
print("Simple palindromes:")
for s in ["racecar", "hello", "level", "noon"]:
    print(f"  '{s}': {is_palindrome_simple(s)}")

print("\nWith special characters:")
test = "A man, a plan, a canal: Panama"
print(f"  '{test}': {is_palindrome_alphanumeric(test)}")

print("\nLongest palindrome substring:")
for s in ["babad", "cbbd", "racecarxyz"]:
    print(f"  '{s}' -> '{longest_palindrome_substring(s)}'")</textarea>
                <div class="code-figure-output" id="outputcode18"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.30:</strong> Palindrome algorithms ranging from simple to finding the longest palindromic substring.
                </div>
            </div>
            
            <h3>Anagram Detection</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.31 ‚Äî Anagram Algorithms</span>
                    <button class="code-figure-run" onclick="runCode('code19')">‚ñ∂ Run</button>
                </div>
                <textarea id="code19" spellcheck="false">from collections import Counter

def are_anagrams_sort(s1, s2):
    """Check anagrams by sorting. O(n log n) time."""
    return sorted(s1.lower()) == sorted(s2.lower())

def are_anagrams_count(s1, s2):
    """Check anagrams by counting. O(n) time."""
    return Counter(s1.lower()) == Counter(s2.lower())

def group_anagrams(words):
    """Group anagrams together."""
    groups = {}
    for word in words:
        # Use sorted letters as key
        key = ''.join(sorted(word.lower()))
        if key not in groups:
            groups[key] = []
        groups[key].append(word)
    return list(groups.values())

# Tests
print("Anagram checks:")
pairs = [("listen", "silent"), ("hello", "world"), ("Debit card", "Bad credit")]
for s1, s2 in pairs:
    result = are_anagrams_count(s1.replace(" ", ""), s2.replace(" ", ""))
    print(f"  '{s1}' & '{s2}': {result}")

print("\nGroup anagrams:")
words = ["eat", "tea", "tan", "ate", "nat", "bat"]
groups = group_anagrams(words)
print(f"  Input: {words}")
print(f"  Groups: {groups}")</textarea>
                <div class="code-figure-output" id="outputcode19"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.31:</strong> Anagram detection using sorting or counting. Grouping anagrams uses sorted strings as dictionary keys.
                </div>
            </div>
            
            <h3>String Compression</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.30 ‚Äî String Compression</span>
                    <button class="code-figure-run" onclick="runCode('code20')">‚ñ∂ Run</button>
                </div>
                <textarea id="code20" spellcheck="false">def compress_string(s):
    """
    Compress string using run-length encoding.
    "aabbbcccc" -> "a2b3c4"
    Only return compressed if shorter than original.
    """
    if not s:
        return s
    
    result = []
    count = 1
    
    for i in range(1, len(s)):
        if s[i] == s[i-1]:
            count += 1
        else:
            result.append(s[i-1] + str(count))
            count = 1
    
    # Don't forget the last character
    result.append(s[-1] + str(count))
    
    compressed = ''.join(result)
    return compressed if len(compressed) < len(s) else s

def decompress_string(s):
    """Decompress run-length encoded string."""
    result = []
    i = 0
    while i < len(s):
        char = s[i]
        i += 1
        # Read all following digits
        num = ''
        while i < len(s) and s[i].isdigit():
            num += s[i]
            i += 1
        result.append(char * int(num))
    return ''.join(result)

# Tests
test_cases = ["aabbbcccc", "abcd", "aaaaaaaaaaaa", "aabbcc"]
print("String compression:")
for s in test_cases:
    compressed = compress_string(s)
    print(f"  '{s}' -> '{compressed}' (saved: {len(s) - len(compressed)} chars)")

print("\nDecompression:")
compressed = "a2b3c4"
print(f"  '{compressed}' -> '{decompress_string(compressed)}'")</textarea>
                <div class="code-figure-output" id="outputcode20"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.30:</strong> Run-length encoding compresses repeated characters. Only useful when there are many repetitions.
                </div>
            </div>
            
            <h3>String Pattern Matching</h3>
            
            <p>Searching for patterns within strings is a fundamental operation with many applications including text search, data validation, and parsing.</p>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.30a ‚Äî Pattern Matching</span>
                    <button class="code-figure-run" onclick="runCode('code20a')">‚ñ∂ Run</button>
                </div>
                <textarea id="code20a" spellcheck="false"># Pattern matching algorithms

def find_all_occurrences(text, pattern):
    """Find all starting indices of pattern in text."""
    indices = []
    start = 0
    while True:
        idx = text.find(pattern, start)
        if idx == -1:
            break
        indices.append(idx)
        start = idx + 1
    return indices

def is_subsequence(s, t):
    """
    Check if s is a subsequence of t.
    (Can we delete chars from t to get s?)
    """
    s_idx = 0
    for char in t:
        if s_idx < len(s) and char == s[s_idx]:
            s_idx += 1
    return s_idx == len(s)

def word_pattern(pattern, s):
    """Check if s follows the pattern (bijection)."""
    words = s.split()
    if len(pattern) != len(words):
        return False
    
    p_to_w, w_to_p = {}, {}
    for p, w in zip(pattern, words):
        if p in p_to_w and p_to_w[p] != w:
            return False
        if w in w_to_p and w_to_p[w] != p:
            return False
        p_to_w[p] = w
        w_to_p[w] = p
    return True

# Tests
text = "abababab"
print(f"Finding 'aba' in '{text}':")
print(f"  Indices: {find_all_occurrences(text, 'aba')}")

print(f"\nSubsequence tests:")
print(f"  is_subsequence('ace', 'abcde'): {is_subsequence('ace', 'abcde')}")
print(f"  is_subsequence('aec', 'abcde'): {is_subsequence('aec', 'abcde')}")

print(f"\nWord pattern:")
print(f"  word_pattern('abba', 'dog cat cat dog'): {word_pattern('abba', 'dog cat cat dog')}")</textarea>
                <div class="code-figure-output" id="outputcode20a"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.30a:</strong> Pattern matching includes finding occurrences, subsequence checking, and word pattern validation.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 8: 2D ARRAYS -->
        <!-- ============================================== -->
        <section id="2d-arrays">
            <h2>8. Working with 2D Arrays</h2>
            
            <p>Many problems involve matrices (2D arrays). In Python, we represent these as lists of lists.</p>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.31 ‚Äî Creating 2D Arrays</span>
                    <button class="code-figure-run" onclick="runCode('code21')">‚ñ∂ Run</button>
                </div>
                <textarea id="code21" spellcheck="false"># Creating 2D arrays

# Method 1: Literal
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# Method 2: List comprehension (correct way!)
rows, cols = 3, 4
grid = [[0 for _ in range(cols)] for _ in range(rows)]

# WRONG way - creates shared references!
bad_grid = [[0] * cols] * rows
bad_grid[0][0] = 99
print(f"Bad grid (shared rows): {bad_grid}")  # All rows changed!

# Accessing elements
print(f"\nMatrix: {matrix}")
print(f"matrix[1][2] = {matrix[1][2]}")  # Row 1, Col 2 = 6

# Dimensions
rows = len(matrix)
cols = len(matrix[0]) if matrix else 0
print(f"Dimensions: {rows} x {cols}")</textarea>
                <div class="code-figure-output" id="outputcode21"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.31:</strong> Always use list comprehension for 2D arrays. The <code>[[0]*n]*m</code> pattern creates shared references!
                </div>
            </div>
            
            <div class="important">
                Never use <code>[[0] * cols] * rows</code> to create a 2D array! This creates rows copies of the <em>same</em> inner list. Changes to one row affect all rows. Always use <code>[[0 for _ in range(cols)] for _ in range(rows)]</code>.
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.30 ‚Äî Traversing 2D Arrays</span>
                    <button class="code-figure-run" onclick="runCode('code22')">‚ñ∂ Run</button>
                </div>
                <textarea id="code22" spellcheck="false">matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# Row-by-row traversal
print("Row-by-row:")
for row in matrix:
    print(f"  {row}")

# With indices
print("\nWith indices:")
for i in range(len(matrix)):
    for j in range(len(matrix[0])):
        print(f"  matrix[{i}][{j}] = {matrix[i][j]}")

# Column-by-column traversal
print("\nColumn-by-column:")
for j in range(len(matrix[0])):
    column = [matrix[i][j] for i in range(len(matrix))]
    print(f"  Column {j}: {column}")

# Diagonal traversal
print("\nMain diagonal:")
diag = [matrix[i][i] for i in range(min(len(matrix), len(matrix[0])))]
print(f"  {diag}")

# Anti-diagonal
print("\nAnti-diagonal:")
n = len(matrix)
anti_diag = [matrix[i][n-1-i] for i in range(n)]
print(f"  {anti_diag}")</textarea>
                <div class="code-figure-output" id="outputcode22"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.30:</strong> Different traversal patterns for 2D arrays: row-wise, column-wise, and diagonal.
                </div>
            </div>
            
            <h3>Matrix Operations</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.31 ‚Äî Matrix Transformations</span>
                    <button class="code-figure-run" onclick="runCode('code23')">‚ñ∂ Run</button>
                </div>
                <textarea id="code23" spellcheck="false">def print_matrix(m, name="Matrix"):
    print(f"{name}:")
    for row in m:
        print(f"  {row}")

def transpose(matrix):
    """Transpose matrix (swap rows and columns)."""
    rows, cols = len(matrix), len(matrix[0])
    return [[matrix[i][j] for i in range(rows)] for j in range(cols)]

def rotate_90_clockwise(matrix):
    """Rotate matrix 90 degrees clockwise."""
    n = len(matrix)
    # Transpose, then reverse each row
    transposed = transpose(matrix)
    return [row[::-1] for row in transposed]

def rotate_90_counterclockwise(matrix):
    """Rotate matrix 90 degrees counter-clockwise."""
    n = len(matrix)
    # Transpose, then reverse each column
    transposed = transpose(matrix)
    return transposed[::-1]

# Test
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

print_matrix(matrix, "Original")
print()
print_matrix(transpose(matrix), "Transposed")
print()
print_matrix(rotate_90_clockwise(matrix), "Rotated 90¬∞ CW")
print()
print_matrix(rotate_90_counterclockwise(matrix), "Rotated 90¬∞ CCW")</textarea>
                <div class="code-figure-output" id="outputcode23"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.31:</strong> Matrix transformations: transpose swaps rows/columns; rotation combines transpose with reversal.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 9: MEMORY CONSIDERATIONS -->
        <!-- ============================================== -->
        <section id="memory">
            <h2>9. Memory Considerations</h2>
            
            <p>Understanding memory usage helps write efficient code, especially when working with large datasets.</p>
            
            <h3>Lists vs Arrays</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.30 ‚Äî Memory Comparison</span>
                    <button class="code-figure-run" onclick="runCode('code24')">‚ñ∂ Run</button>
                </div>
                <textarea id="code24" spellcheck="false">import sys
from array import array

n = 10000

# Python list stores references to objects
python_list = list(range(n))

# array.array stores values directly (like C arrays)
int_array = array('i', range(n))  # 'i' = signed int

print(f"Storing {n} integers:")
print(f"  Python list: {sys.getsizeof(python_list):,} bytes")
print(f"  array.array: {sys.getsizeof(int_array):,} bytes")
print(f"  Ratio: {sys.getsizeof(python_list) / sys.getsizeof(int_array):.2f}x")

# For numerical work, consider NumPy
try:
    import numpy as np
    numpy_array = np.arange(n, dtype=np.int32)
    print(f"  NumPy array: {numpy_array.nbytes:,} bytes")
except ImportError:
    print("  NumPy not available")

print("\nNote: Python lists are flexible but memory-inefficient.")
print("Use array.array or NumPy for large numerical data.")</textarea>
                <div class="code-figure-output" id="outputcode24"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.30:</strong> Python lists store object references, adding overhead. Use <code>array.array</code> or NumPy for memory-efficient numerical storage.
                </div>
            </div>
            
            <h3>String Concatenation Efficiency</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.31 ‚Äî Efficient String Building</span>
                    <button class="code-figure-run" onclick="runCode('code25')">‚ñ∂ Run</button>
                </div>
                <textarea id="code25" spellcheck="false">import time

n = 10000
words = ["word"] * n

# BAD: Concatenation in loop - O(n¬≤)!
start = time.perf_counter()
result = ""
for w in words:
    result += w + " "
bad_time = time.perf_counter() - start

# GOOD: Using join() - O(n)
start = time.perf_counter()
result = " ".join(words)
good_time = time.perf_counter() - start

print(f"Concatenating {n} strings:")
print(f"  Using += : {bad_time*1000:.2f} ms")
print(f"  Using join(): {good_time*1000:.2f} ms")
print(f"  join() is {bad_time/good_time:.1f}x faster")

# ALSO GOOD: Using list then join
start = time.perf_counter()
parts = []
for w in words:
    parts.append(w)
result = " ".join(parts)
list_time = time.perf_counter() - start
print(f"  Build list then join: {list_time*1000:.2f} ms")</textarea>
                <div class="code-figure-output" id="outputcode25"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.31:</strong> String concatenation with += is O(n¬≤) due to copying. Use <code>join()</code> for O(n) performance.
                </div>
            </div>
            
            <h3>Shallow vs Deep Copy</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.30 ‚Äî Copy Behavior</span>
                    <button class="code-figure-run" onclick="runCode('code26')">‚ñ∂ Run</button>
                </div>
                <textarea id="code26" spellcheck="false">import copy

# Simple list: shallow copy is sufficient
original = [1, 2, 3]
shallow = original.copy()  # or original[:] or list(original)
shallow[0] = 999
print(f"Simple list:")
print(f"  Original: {original}")  # Unchanged
print(f"  Shallow copy: {shallow}")

# Nested list: shallow copy shares inner objects!
nested = [[1, 2], [3, 4]]
shallow = nested.copy()
shallow[0][0] = 999
print(f"\nNested list with shallow copy:")
print(f"  Original: {nested}")    # CHANGED!
print(f"  Shallow: {shallow}")

# Nested list: deep copy creates independent copies
nested = [[1, 2], [3, 4]]
deep = copy.deepcopy(nested)
deep[0][0] = 999
print(f"\nNested list with deep copy:")
print(f"  Original: {nested}")    # Unchanged
print(f"  Deep copy: {deep}")</textarea>
                <div class="code-figure-output" id="outputcode26"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.30:</strong> Shallow copy shares nested objects. Use <code>copy.deepcopy()</code> for truly independent nested copies.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 10: COMMON PITFALLS -->
        <!-- ============================================== -->
        <section id="pitfalls">
            <h2>10. Common Pitfalls</h2>
            
            <h3>Pitfall 1: Modifying List While Iterating</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.31 ‚Äî Don't Modify While Iterating</span>
                    <button class="code-figure-run" onclick="runCode('code27')">‚ñ∂ Run</button>
                </div>
                <textarea id="code27" spellcheck="false"># BAD: Modifying list while iterating
nums = [1, 2, 3, 4, 5]
print(f"Original: {nums}")

# This skips elements!
bad_result = nums.copy()
for x in bad_result:
    if x % 2 == 0:
        bad_result.remove(x)
print(f"BAD (remove during iteration): {bad_result}")  # Wrong!

# GOOD: Create new list
nums = [1, 2, 3, 4, 5]
good_result = [x for x in nums if x % 2 != 0]
print(f"GOOD (list comprehension): {good_result}")

# GOOD: Iterate over copy
nums = [1, 2, 3, 4, 5]
for x in nums.copy():  # Iterate over copy
    if x % 2 == 0:
        nums.remove(x)
print(f"GOOD (iterate over copy): {nums}")</textarea>
                <div class="code-figure-output" id="outputcode27"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.31:</strong> Removing elements while iterating causes skipped elements. Use list comprehension or iterate over a copy.
                </div>
            </div>
            
            <h3>Pitfall 2: Default Mutable Arguments</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.30 ‚Äî Mutable Default Arguments</span>
                    <button class="code-figure-run" onclick="runCode('code28')">‚ñ∂ Run</button>
                </div>
                <textarea id="code28" spellcheck="false"># BAD: Mutable default argument
def bad_append(item, lst=[]):
    lst.append(item)
    return lst

print("BAD function:")
print(f"  bad_append(1): {bad_append(1)}")
print(f"  bad_append(2): {bad_append(2)}")  # Unexpected!
print(f"  bad_append(3): {bad_append(3)}")  # Keeps growing!

# GOOD: Use None as default
def good_append(item, lst=None):
    if lst is None:
        lst = []
    lst.append(item)
    return lst

print("\nGOOD function:")
print(f"  good_append(1): {good_append(1)}")
print(f"  good_append(2): {good_append(2)}")
print(f"  good_append(3): {good_append(3)}")</textarea>
                <div class="code-figure-output" id="outputcode28"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.30:</strong> Default mutable arguments are shared across calls! Use <code>None</code> and create new objects inside the function.
                </div>
            </div>
            
            <h3>Pitfall 3: Off-By-One Errors</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 3.31 ‚Äî Off-By-One Errors</span>
                    <button class="code-figure-run" onclick="runCode('code29')">‚ñ∂ Run</button>
                </div>
                <textarea id="code29" spellcheck="false">arr = [10, 20, 30, 40, 50]
n = len(arr)

print("Common off-by-one mistakes:")

# Mistake 1: Using <= instead of <
print("\n1. Loop bounds:")
print(f"   WRONG: for i in range(n+1)  # Goes to index {n}, out of bounds!")
print(f"   RIGHT: for i in range(n)    # Goes to index {n-1}")

# Mistake 2: Forgetting that range() is exclusive
print("\n2. Range is exclusive:")
print(f"   range(1, 5) = {list(range(1, 5))}  # 5 is NOT included")
print(f"   range(5)    = {list(range(5))}     # Indices 0-4")

# Mistake 3: Slice end is exclusive
print("\n3. Slice end is exclusive:")
print(f"   arr[1:3] = {arr[1:3]}  # Elements at indices 1, 2 (not 3)")

# Mistake 4: Two-pointer meeting condition
print("\n4. Two-pointer condition:")
print(f"   WRONG: while left <= right  # May process middle element twice")
print(f"   RIGHT: while left < right   # Each element processed once")</textarea>
                <div class="code-figure-output" id="outputcode29"></div>
                <div class="code-figure-caption">
                    <strong>Figure 3.31:</strong> Off-by-one errors are the most common bugs. Remember: range() and slices have exclusive end bounds.
                </div>
            </div>
            
            <div class="summary">
                <div class="summary-title">Key Takeaways</div>
                <ul>
                    <li><strong>Arrays</strong> provide O(1) random access via direct memory addressing</li>
                    <li><strong>Python lists</strong> are dynamic arrays that grow automatically with O(1) amortized append</li>
                    <li><strong>Insert/delete at arbitrary positions</strong> is O(n) due to element shifting</li>
                    <li><strong>Membership testing</strong> is O(n) for lists, O(1) for sets‚Äîconvert if needed</li>
                    <li><strong>Four patterns</strong>: linear scan, two pointers, sliding window, frequency counting</li>
                    <li><strong>Strings are immutable</strong>‚Äîuse join() for efficient concatenation</li>
                    <li><strong>2D arrays</strong>: use <code>[[0]*n for _ in range(m)]</code>, never <code>[[0]*n]*m</code></li>
                </ul>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 11: EXERCISES -->
        <!-- ============================================== -->
        <section id="exercises">
            <h2>11. Exercises</h2>
            
            <!-- Exercise 1 -->
            <div class="exercise">
                <div class="exercise-title">Exercise 1: Two Sum</div>
                <p>Write <code>two_sum(nums, target)</code> that returns indices of two numbers that add up to target. Assume exactly one solution exists.</p>
                <p class="answer">(Answer: two_sum([2, 7, 11, 15], 9) = (0, 1), two_sum([3, 2, 4], 6) = (1, 2))</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 1 ‚Äî Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex1')">‚ñ∂ Run</button>
                </div>
                <textarea id="ex1" spellcheck="false"># HINT 1: Use a dictionary to store {value: index}
# HINT 2: For each num, check if (target - num) exists in dictionary
# HINT 3: This gives O(n) time instead of O(n¬≤) brute force

def two_sum(nums, target):
    # Your code here
    pass

# Test your function
# print(f"two_sum([2, 7, 11, 15], 9) = {two_sum([2, 7, 11, 15], 9)}")
# print(f"two_sum([3, 2, 4], 6) = {two_sum([3, 2, 4], 6)}")
# print(f"two_sum([3, 3], 6) = {two_sum([3, 3], 6)}")</textarea>
                <div class="code-figure-output" id="outputex1"></div>
            </div>
            
            <!-- Exercise 2 -->
            <div class="exercise">
                <div class="exercise-title">Exercise 2: Move Zeros</div>
                <p>Write <code>move_zeros(nums)</code> that moves all 0's to the end while maintaining the relative order of non-zero elements. Modify in-place.</p>
                <p class="answer">(Answer: [0, 1, 0, 3, 12] ‚Üí [1, 3, 12, 0, 0])</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 2 ‚Äî Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex2')">‚ñ∂ Run</button>
                </div>
                <textarea id="ex2" spellcheck="false"># HINT 1: Use two-pointer technique
# HINT 2: One pointer for current position, one for where to place non-zeros
# HINT 3: After placing all non-zeros, fill rest with zeros

def move_zeros(nums):
    # Your code here
    pass

# Test your function
# arr = [0, 1, 0, 3, 12]
# move_zeros(arr)
# print(f"After move_zeros: {arr}")  # [1, 3, 12, 0, 0]</textarea>
                <div class="code-figure-output" id="outputex2"></div>
            </div>
            
            <!-- Exercise 3 -->
            <div class="exercise">
                <div class="exercise-title">Exercise 3: Valid Parentheses</div>
                <p>Write <code>is_valid(s)</code> that checks if a string of brackets <code>()[]</code>{} is valid (properly opened and closed).</p>
                <p class="answer">(Answer: "()" ‚Üí True, "()[]{}" ‚Üí True, "(]" ‚Üí False, "([)]" ‚Üí False, "{[]}" ‚Üí True)</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 3 ‚Äî Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex3')">‚ñ∂ Run</button>
                </div>
                <textarea id="ex3" spellcheck="false"># HINT 1: Use a stack (list)
# HINT 2: Push opening brackets, pop and match for closing brackets
# HINT 3: Create a mapping: ')' -> '(', ']' -> '[', '}' -> '{'

def is_valid(s):
    # Your code here
    pass

# Test your function
# for s in ["()", "()[]{}", "(]", "([)]", "{[]}"]:
#     print(f"is_valid('{s}'): {is_valid(s)}")</textarea>
                <div class="code-figure-output" id="outputex3"></div>
            </div>
            
            <!-- Exercise 4 -->
            <div class="exercise">
                <div class="exercise-title">Exercise 4: Rotate Array</div>
                <p>Write <code>rotate(nums, k)</code> that rotates array to the right by k steps. Modify in-place.</p>
                <p class="answer">(Answer: [1,2,3,4,5,6,7] rotated by 3 ‚Üí [5,6,7,1,2,3,4])</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 4 ‚Äî Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex4')">‚ñ∂ Run</button>
                </div>
                <textarea id="ex4" spellcheck="false"># HINT 1: k might be larger than array length - use k % len(nums)
# HINT 2: Method 1: Reverse entire array, then reverse first k, then reverse rest
# HINT 3: Method 2: Use slicing (creates new list though)

def rotate(nums, k):
    # Your code here
    pass

# Test your function
# arr = [1, 2, 3, 4, 5, 6, 7]
# rotate(arr, 3)
# print(f"After rotate by 3: {arr}")  # [5, 6, 7, 1, 2, 3, 4]</textarea>
                <div class="code-figure-output" id="outputex4"></div>
            </div>
            
            <!-- Exercise 5 -->
            <div class="exercise">
                <div class="exercise-title">Exercise 5: Longest Common Prefix</div>
                <p>Write <code>longest_common_prefix(strs)</code> that finds the longest common prefix among an array of strings.</p>
                <p class="answer">(Answer: ["flower", "flow", "flight"] ‚Üí "fl", ["dog", "racecar", "car"] ‚Üí "")</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 5 ‚Äî Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex5')">‚ñ∂ Run</button>
                </div>
                <textarea id="ex5" spellcheck="false"># HINT 1: Compare characters at each position across all strings
# HINT 2: Stop when characters don't match or you reach end of shortest string
# HINT 3: Edge case: empty list should return ""

def longest_common_prefix(strs):
    # Your code here
    pass

# Test your function
# print(f"LCP of ['flower', 'flow', 'flight']: '{longest_common_prefix(['flower', 'flow', 'flight'])}'")
# print(f"LCP of ['dog', 'racecar', 'car']: '{longest_common_prefix(['dog', 'racecar', 'car'])}'")
# print(f"LCP of ['abc']: '{longest_common_prefix(['abc'])}'")
# print(f"LCP of []: '{longest_common_prefix([])}'")
</textarea>
                <div class="code-figure-output" id="outputex5"></div>
            </div>
        </section>

        <!-- SUBMIT SECTION -->
        <section class="submit-section">
            <h2>Submit Your Work</h2>
            <p>After completing the exercises, submit your attendance below.</p>
            
            <div class="form-row">
                <div class="form-group">
                    <label>Student ID</label>
                    <input type="text" id="studentId" placeholder="Enter your student ID">
                </div>
                <div class="form-group">
                    <label>Full Name</label>
                    <input type="text" id="studentName" placeholder="Enter your full name">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>Email (@istun.edu.tr)</label>
                    <input type="email" id="studentEmail" placeholder="your.email@istun.edu.tr">
                </div>
                <div class="form-group">
                    <label>Class Code</label>
                    <input type="text" id="classCode" placeholder="From instructor">
                </div>
            </div>
            <input type="text" id="hp" class="hp" tabindex="-1" autocomplete="off">
            <button class="submit-btn" onclick="submitWork()">Submit Attendance</button>
            <div class="submit-status" id="submitStatus"></div>
        </section>
    </main>

    <script>
        const pageLoadTime = Date.now();
        
        async function runCode(codeId) {
            const codeEl = document.getElementById(codeId);
            const outputEl = document.getElementById('output' + codeId);
            const code = codeEl.value;
            outputEl.classList.add('show');
            outputEl.textContent = 'Loading Python...';
            
            try {
                // Wait for PyScript/Pyodide to be ready
                if (!window.pyodideReady) {
                    if (typeof loadPyodide === 'undefined') {
                        // Load Pyodide directly as fallback
                        const script = document.createElement('script');
                        script.src = 'https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js';
                        document.head.appendChild(script);
                        await new Promise((resolve, reject) => {
                            script.onload = resolve;
                            script.onerror = reject;
                            setTimeout(reject, 10000);
                        });
                    }
                    outputEl.textContent = 'Initializing Python (first run may take a moment)...';
                    window.pyodide = await loadPyodide();
                    window.pyodideReady = true;
                }
                
                outputEl.textContent = 'Running...';
                
                // Capture stdout
                window.pyodide.runPython(`
import sys
from io import StringIO
sys.stdout = StringIO()
`);
                
                try {
                    window.pyodide.runPython(code);
                } catch (pyErr) {
                    outputEl.textContent = 'Error: ' + pyErr.message;
                    return;
                }
                
                const output = window.pyodide.runPython('sys.stdout.getvalue()');
                outputEl.textContent = output || '(no output)';
                
            } catch(e) {
                outputEl.textContent = 'Error: ' + e.message;
            }
        }
        
        function submitWork() {
            const status = document.getElementById('submitStatus');
            const data = {
                week: 'Week_03',
                student_id: document.getElementById('studentId').value.trim(),
                student_name: document.getElementById('studentName').value.trim(),
                student_email: document.getElementById('studentEmail').value.trim().toLowerCase(),
                classCode: document.getElementById('classCode').value.trim().toUpperCase(),
                timeOnPage: Math.floor((Date.now() - pageLoadTime) / 1000)
            };
            
            if (document.getElementById('hp').value) {
                status.textContent = 'Submission rejected.';
                status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5';
                return;
            }
            if (data.timeOnPage < 60) {
                status.textContent = 'Please spend more time reviewing the material.';
                status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5';
                return;
            }
            if (!data.student_id || !data.student_name || !data.student_email || !data.classCode) {
                status.textContent = 'All fields are required.';
                status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5';
                return;
            }
            if (!data.student_email.endsWith('@istun.edu.tr')) {
                status.textContent = 'Use your @istun.edu.tr email.';
                status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5';
                return;
            }
            
            status.textContent = 'Submitting...';
            status.style.cssText = 'display:block;background:rgba(124,58,237,0.2);color:#a78bfa';
            
            const scriptUrl = 'https://script.google.com/macros/s/AKfycbzyyvKZRtR7_m05hlB7V-BCBJN3OcOBLjVTFNJ5zNcZFxsOoJMLHLvdUVk4SSqDjtXi/exec';
            
            fetch(scriptUrl, {
                method: 'POST',
                mode: 'cors',
                cache: 'no-cache',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify(data)
            })
            .then(response => response.json())
            .then(res => {
                if (res.success) {
                    status.textContent = 'Submitted successfully!';
                    status.style.cssText = 'display:block;background:rgba(74,222,128,0.2);color:#4ade80';
                } else {
                    status.textContent = res.message || 'Submission failed. Please try again.';
                    status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5';
                }
            })
            .catch(error => {
                console.error('Fetch error:', error);
                // Fallback: try no-cors mode (won't get response but will send data)
                fetch(scriptUrl, {
                    method: 'POST',
                    mode: 'no-cors',
                    cache: 'no-cache',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify(data)
                })
                .then(() => {
                    status.textContent = 'Request sent. Check your email for confirmation.';
                    status.style.cssText = 'display:block;background:rgba(251,191,36,0.2);color:#fbbf24';
                })
                .catch(() => {
                    status.textContent = 'Connection error. Please try again.';
                    status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5';
                });
            });
        }
    </script>
</body>
</html>
