<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 11: Searching Algorithms | DSA Course</title>
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>
    <script type="module">
        // Wait for PyScript to be ready
        const pyReady = new Promise((resolve) => {
            const check = setInterval(() => {
                if (typeof pyscript !== 'undefined' && pyscript.interpreter) {
                    clearInterval(check);
                    resolve();
                }
            }, 100);
            // Timeout after 15 seconds
            setTimeout(() => { clearInterval(check); resolve(); }, 15000);
        });
        window.pyReady = pyReady;
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Crimson Pro', Georgia, serif;
            font-size: 19px;
            background: #faf9f7;
            color: #2c2c2c; 
            line-height: 1.8;
        }
        
        .topbar {
            position: sticky;
            top: 0;
            background: #1a1a2e;
            color: white;
            padding: 12px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }
        .topbar .title { font-family: system-ui, sans-serif; font-size: 0.9rem; font-weight: 500; }
        .topbar a { font-family: system-ui, sans-serif; color: white; text-decoration: none; font-size: 0.85rem; padding: 6px 14px; background: rgba(255,255,255,0.1); border-radius: 5px; }
        .topbar a:hover { background: rgba(255,255,255,0.2); }
        
        .book { max-width: 750px; margin: 0 auto; padding: 60px 40px 100px; }
        
        .chapter-header { text-align: center; padding: 50px 0 60px; border-bottom: 1px solid #ddd; margin-bottom: 50px; }
        .chapter-num { font-family: system-ui, sans-serif; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 3px; color: #7c3aed; margin-bottom: 15px; }
        .chapter-header h1 { font-size: 2.8rem; font-weight: 600; color: #1a1a2e; margin-bottom: 15px; letter-spacing: -0.5px; }
        .chapter-header .subtitle { font-style: italic; color: #666; font-size: 1.1rem; }
        
        h2 { font-size: 1.6rem; font-weight: 600; color: #1a1a2e; margin: 60px 0 25px; padding-top: 30px; border-top: 1px solid #e5e5e5; }
        h2:first-of-type { border-top: none; margin-top: 0; padding-top: 0; }
        h3 { font-size: 1.25rem; font-weight: 600; color: #333; margin: 40px 0 15px; }
        h4 { font-size: 1.05rem; font-weight: 600; color: #555; margin: 30px 0 12px; }
        
        p { margin: 0 0 20px; text-align: justify; hyphens: auto; }
        ul, ol { margin: 20px 0 25px 30px; }
        li { margin: 10px 0; }
        
        code { font-family: 'JetBrains Mono', monospace; font-size: 0.85em; background: #f0eeeb; padding: 2px 6px; border-radius: 3px; color: #7c3aed; }
        .term { font-weight: 600; color: #1a1a2e; }
        
        .definition { background: #f8f7f5; border-left: 4px solid #7c3aed; padding: 20px 25px; margin: 30px 0; }
        .definition-title { font-family: system-ui, sans-serif; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px; color: #7c3aed; margin-bottom: 8px; font-weight: 600; }
        .definition p { margin: 0; }
        
        .margin-note { background: #fffbeb; border: 1px solid #fcd34d; padding: 15px 18px; margin: 25px 0; border-radius: 4px; font-size: 0.9rem; }
        .margin-note::before { content: "üí° "; }
        
        .important { background: #fef2f2; border: 1px solid #fca5a5; padding: 15px 18px; margin: 25px 0; border-radius: 4px; font-size: 0.9rem; }
        .important::before { content: "‚ö†Ô∏è "; }
        
        .example { background: #fafafa; border: 1px solid #e5e5e5; border-radius: 6px; padding: 25px; margin: 30px 0; }
        .example-title { font-family: system-ui, sans-serif; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: #666; margin-bottom: 15px; font-weight: 600; }
        
        .code-figure { margin: 35px 0; border: 1px solid #e0e0e0; border-radius: 6px; overflow: hidden; background: #1e1e2e; }
        .code-figure-header { background: #28283c; padding: 10px 18px; display: flex; justify-content: space-between; align-items: center; }
        .code-figure-label { font-family: system-ui, sans-serif; font-size: 0.75rem; color: #a0a0b0; text-transform: uppercase; letter-spacing: 0.5px; }
        .code-figure-run { font-family: system-ui, sans-serif; background: #7c3aed; color: white; border: none; padding: 5px 14px; border-radius: 4px; font-size: 0.8rem; cursor: pointer; font-weight: 500; }
        .code-figure-run:hover { background: #6d28d9; }
        .code-figure textarea { width: 100%; min-height: 100px; padding: 18px; background: #1e1e2e; color: #e0e0e0; border: none; font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; line-height: 1.6; resize: vertical; }
        .code-figure textarea:focus { outline: none; }
        .code-figure-output { display: none; border-top: 1px solid #28283c; padding: 15px 18px; background: #161622; color: #4ade80; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; white-space: pre-wrap; }
        .code-figure-output.show { display: block; }
        .code-figure-caption { background: #f8f8f8; padding: 12px 18px; font-size: 0.85rem; color: #666; border-top: 1px solid #e0e0e0; }
        .code-figure-caption strong { color: #333; }
        
        .summary { background: linear-gradient(135deg, #7c3aed10, #7c3aed05); border: 1px solid #7c3aed30; border-radius: 8px; padding: 25px 30px; margin: 40px 0; }
        .summary-title { font-family: system-ui, sans-serif; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: #7c3aed; margin-bottom: 12px; font-weight: 600; }
        .summary ul { margin: 0; }
        
        .exercise { background: #f0fdf4; border: 1px solid #bbf7d0; border-radius: 8px; padding: 25px 30px; margin: 40px 0 20px; }
        .exercise-title { font-family: system-ui, sans-serif; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: #16a34a; margin-bottom: 12px; font-weight: 600; }
        .exercise p { margin: 0; }
        .exercise .answer { margin-top: 12px; font-size: 0.9rem; color: #166534; }
        
        table { width: 100%; border-collapse: collapse; margin: 25px 0; font-size: 0.95rem; }
        th, td { border: 1px solid #ddd; padding: 12px 15px; text-align: left; }
        th { background: #f5f5f5; font-weight: 600; }
        
        .submit-section { background: #1a1a2e; color: white; padding: 40px; border-radius: 10px; margin-top: 60px; }
        .submit-section h2 { color: white; border: none; margin: 0 0 20px; padding: 0; font-size: 1.4rem; }
        .submit-section p { color: #a0a0b0; text-align: left; }
        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; font-family: system-ui, sans-serif; font-size: 0.85rem; color: #a0a0b0; margin-bottom: 6px; }
        .form-group input { width: 100%; padding: 12px 14px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 5px; color: white; font-size: 1rem; font-family: system-ui, sans-serif; }
        .form-group input:focus { outline: none; border-color: #7c3aed; }
        .submit-btn { background: #7c3aed; color: white; border: none; padding: 14px 30px; border-radius: 6px; font-size: 1rem; font-weight: 500; cursor: pointer; font-family: system-ui, sans-serif; margin-top: 10px; }
        .submit-btn:hover { background: #6d28d9; }
        .submit-status { margin-top: 15px; padding: 12px; border-radius: 5px; display: none; font-family: system-ui, sans-serif; font-size: 0.9rem; }
        .hp { position: absolute; left: -9999px; }
        
        .toc { background: #f8f7f5; padding: 30px 35px; margin: 0 0 50px; border-radius: 6px; }
        .toc-title { font-family: system-ui, sans-serif; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 2px; color: #888; margin-bottom: 15px; }
        .toc ol { margin: 0; padding-left: 20px; }
        .toc li { margin: 8px 0; }
        .toc a { color: #7c3aed; text-decoration: none; }
        .toc a:hover { text-decoration: underline; }
        
        @media (max-width: 600px) {
            .book { padding: 30px 20px; }
            .chapter-header h1 { font-size: 2rem; }
            h2 { font-size: 1.4rem; }
            .form-row { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <nav class="topbar">
        <span class="title">Data Structures &amp; Algorithms</span>
        <a href="index.html?home=true">‚Üê Course Home</a>
    </nav>
    
    <main class="book">
        <header class="chapter-header">
            <div class="chapter-num">Week Eleven</div>
            <h1>Searching Algorithms</h1>
            <p class="subtitle">Finding elements efficiently in data structures</p>
        </header>
        
        <nav class="toc">
            <div class="toc-title">Contents</div>
            <ol>
                <li><a href="#intro">Introduction to Searching</a></li>
                <li><a href="#linear">Linear Search</a></li>
                <li><a href="#binary">Binary Search</a></li>
                <li><a href="#variants">Binary Search Variants</a></li>
                <li><a href="#rotated">Search in Rotated Arrays</a></li>
                <li><a href="#2d">Search in 2D Arrays</a></li>
                <li><a href="#trees">Search in Trees</a></li>
                <li><a href="#graphs">Search in Graphs</a></li>
                <li><a href="#bisect">Python's bisect Module</a></li>
                <li><a href="#patterns">Common Patterns</a></li>
                <li><a href="#pitfalls">Common Pitfalls</a></li>
                <li><a href="#exercises">Exercises</a></li>
            </ol>
        </nav>

        <!-- ============================================== -->
        <!-- SECTION 1: INTRODUCTION TO SEARCHING -->
        <!-- ============================================== -->
        <section id="intro">
            <h2>1. Introduction to Searching</h2>
            
            <p>Searching is a fundamental operation‚Äîfinding a target element or determining its absence. The choice of algorithm depends on whether data is sorted, the data structure used, and whether we need exact matches or ranges. Efficient searching is crucial for databases, file systems, and countless applications.</p>
            
            <div class="definition">
                <div class="definition-title">Definition</div>
                <p>A <span class="term">search algorithm</span> finds the position of a target value within a data structure. Key metrics include time complexity, space complexity, and whether the algorithm requires sorted data. Search can return an index, a boolean, or the element itself.</p>
            </div>
            
            <h3>Search Algorithm Comparison</h3>
            
            <table>
                <tr>
                    <th>Algorithm</th>
                    <th>Time</th>
                    <th>Space</th>
                    <th>Requires Sorted</th>
                    <th>Data Structure</th>
                </tr>
                <tr>
                    <td>Linear Search</td>
                    <td>O(n)</td>
                    <td>O(1)</td>
                    <td>No</td>
                    <td>Any sequence</td>
                </tr>
                <tr>
                    <td>Binary Search</td>
                    <td>O(log n)</td>
                    <td>O(1)</td>
                    <td>Yes</td>
                    <td>Array</td>
                </tr>
                <tr>
                    <td>Hash Table</td>
                    <td>O(1) avg</td>
                    <td>O(n)</td>
                    <td>No</td>
                    <td>Hash table</td>
                </tr>
                <tr>
                    <td>BST Search</td>
                    <td>O(log n) avg</td>
                    <td>O(1)</td>
                    <td>Inherent</td>
                    <td>BST</td>
                </tr>
                <tr>
                    <td>BFS/DFS</td>
                    <td>O(V + E)</td>
                    <td>O(V)</td>
                    <td>No</td>
                    <td>Graph</td>
                </tr>
            </table>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.1 ‚Äî Search Performance Comparison</span>
                    <button class="code-figure-run" onclick="runCode('code1')">‚ñ∂ Run</button>
                </div>
                <textarea id="code1" spellcheck="false">import time
import random

def linear_search(arr, target):
    for i, val in enumerate(arr):
        if val == target:
            return i
    return -1

def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# Compare performance
n = 100000
arr = list(range(n))
target = n - 1  # Worst case for linear

# Linear search
start = time.perf_counter()
linear_search(arr, target)
linear_time = time.perf_counter() - start

# Binary search
start = time.perf_counter()
binary_search(arr, target)
binary_time = time.perf_counter() - start

print(f"Searching for {target} in {n} elements:")
print(f"  Linear search: {linear_time*1000:.3f} ms")
print(f"  Binary search: {binary_time*1000:.6f} ms")
print(f"  Speedup: {linear_time/binary_time:.0f}x")</textarea>
                <div class="code-figure-output" id="outputcode1"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.1:</strong> Binary search is exponentially faster than linear search for large sorted arrays.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 2: LINEAR SEARCH -->
        <!-- ============================================== -->
        <section id="linear">
            <h2>2. Linear Search</h2>
            
            <div class="definition">
                <div class="definition-title">Definition</div>
                <p><span class="term">Linear Search</span> (or sequential search) examines each element in order until finding the target or reaching the end. Simple but inefficient for large datasets‚ÄîO(n) time. Works on any collection, sorted or not.</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.2 ‚Äî Linear Search Variations</span>
                    <button class="code-figure-run" onclick="runCode('code2')">‚ñ∂ Run</button>
                </div>
                <textarea id="code2" spellcheck="false">def linear_search(arr, target):
    """Basic linear search - O(n) time, O(1) space."""
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1

def linear_search_all(arr, target):
    """Find all occurrences of target."""
    indices = []
    for i, val in enumerate(arr):
        if val == target:
            indices.append(i)
    return indices

def linear_search_condition(arr, condition):
    """Find first element satisfying condition."""
    for i, val in enumerate(arr):
        if condition(val):
            return i, val
    return -1, None

# Test
arr = [4, 2, 7, 1, 9, 2, 5, 2]
print(f"Array: {arr}")
print(f"Index of 7: {linear_search(arr, 7)}")
print(f"All indices of 2: {linear_search_all(arr, 2)}")

idx, val = linear_search_condition(arr, lambda x: x > 5)
print(f"First element > 5: {val} at index {idx}")</textarea>
                <div class="code-figure-output" id="outputcode2"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.2:</strong> Linear search is versatile‚Äîcan find first, all, or conditional matches.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.3 ‚Äî Python's Built-in Search</span>
                    <button class="code-figure-run" onclick="runCode('code3')">‚ñ∂ Run</button>
                </div>
                <textarea id="code3" spellcheck="false"># Python's built-in search methods (all O(n) for lists)

arr = [4, 2, 7, 1, 9, 2, 5]

# in operator - checks existence
print(f"7 in arr: {7 in arr}")
print(f"10 in arr: {10 in arr}")

# index() - returns first index (raises ValueError if not found)
print(f"arr.index(2): {arr.index(2)}")

# count() - counts occurrences
print(f"arr.count(2): {arr.count(2)}")

# Using try/except for safe index lookup
def safe_index(arr, target):
    try:
        return arr.index(target)
    except ValueError:
        return -1

print(f"safe_index(arr, 10): {safe_index(arr, 10)}")

# For sets and dicts, 'in' is O(1)!
s = set(arr)
print(f"\n7 in set: {7 in s}  (O(1))")</textarea>
                <div class="code-figure-output" id="outputcode3"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.3:</strong> Python's 'in' operator is O(n) for lists but O(1) for sets and dicts.
                </div>
            </div>
            
            <div class="margin-note">
                When to use linear search: unsorted data, small arrays (n < 100), linked lists, or when you need to check every element anyway.
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 3: BINARY SEARCH -->
        <!-- ============================================== -->
        <section id="binary">
            <h2>3. Binary Search</h2>
            
            <div class="definition">
                <div class="definition-title">Definition</div>
                <p><span class="term">Binary Search</span> repeatedly divides a sorted array in half, comparing the target to the middle element. Each comparison eliminates half the remaining elements, achieving O(log n) time. Requires random access (arrays, not linked lists).</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.4 ‚Äî Binary Search Iterative</span>
                    <button class="code-figure-run" onclick="runCode('code4')">‚ñ∂ Run</button>
                </div>
                <textarea id="code4" spellcheck="false">def binary_search(arr, target):
    """
    Binary Search - O(log n) time, O(1) space.
    Returns index of target, or -1 if not found.
    """
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2  # Avoid overflow
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1

# Trace execution
arr = [1, 3, 5, 7, 9, 11, 13, 15]
target = 7
print(f"Array: {arr}")
print(f"Searching for {target}:\n")

left, right = 0, len(arr) - 1
step = 1
while left <= right:
    mid = (left + right) // 2
    print(f"Step {step}: left={left}, right={right}, mid={mid}, arr[mid]={arr[mid]}")
    if arr[mid] == target:
        print(f"Found at index {mid}!")
        break
    elif arr[mid] < target:
        left = mid + 1
    else:
        right = mid - 1
    step += 1</textarea>
                <div class="code-figure-output" id="outputcode4"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.4:</strong> Each step halves the search space. For n=8 elements, at most 3 comparisons.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.5 ‚Äî Binary Search Recursive</span>
                    <button class="code-figure-run" onclick="runCode('code5')">‚ñ∂ Run</button>
                </div>
                <textarea id="code5" spellcheck="false">def binary_search_recursive(arr, target, left=0, right=None):
    """
    Recursive binary search - O(log n) time, O(log n) space.
    Space is due to recursion stack.
    """
    if right is None:
        right = len(arr) - 1
    
    if left > right:
        return -1
    
    mid = (left + right) // 2
    
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)

# Test
arr = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
print(f"Array: {arr}")
print(f"Index of 10: {binary_search_recursive(arr, 10)}")
print(f"Index of 15: {binary_search_recursive(arr, 15)}")
print(f"Index of 2: {binary_search_recursive(arr, 2)}")
print(f"Index of 20: {binary_search_recursive(arr, 20)}")</textarea>
                <div class="code-figure-output" id="outputcode5"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.5:</strong> Recursive version is elegant but uses O(log n) stack space.
                </div>
            </div>
            
            <div class="important">
                <strong>Binary Search Requirements:</strong><br>
                ‚Ä¢ Array must be sorted<br>
                ‚Ä¢ Need random access (index-based)<br>
                ‚Ä¢ Use <code>left + (right - left) // 2</code> to avoid integer overflow in other languages
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 4: BINARY SEARCH VARIANTS -->
        <!-- ============================================== -->
        <section id="variants">
            <h2>4. Binary Search Variants</h2>
            
            <h3>Finding Boundaries</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.6 ‚Äî Lower and Upper Bound</span>
                    <button class="code-figure-run" onclick="runCode('code6')">‚ñ∂ Run</button>
                </div>
                <textarea id="code6" spellcheck="false">def lower_bound(arr, target):
    """
    Find first index where arr[i] >= target.
    Returns len(arr) if all elements < target.
    """
    left, right = 0, len(arr)
    
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid
    
    return left

def upper_bound(arr, target):
    """
    Find first index where arr[i] > target.
    Returns len(arr) if all elements <= target.
    """
    left, right = 0, len(arr)
    
    while left < right:
        mid = (left + right) // 2
        if arr[mid] <= target:
            left = mid + 1
        else:
            right = mid
    
    return left

# Test with duplicates
arr = [1, 2, 2, 2, 3, 4, 5]
print(f"Array: {arr}")
print(f"\nFor target=2:")
print(f"  Lower bound (first >=): {lower_bound(arr, 2)}")
print(f"  Upper bound (first >):  {upper_bound(arr, 2)}")
print(f"  Count of 2s: {upper_bound(arr, 2) - lower_bound(arr, 2)}")</textarea>
                <div class="code-figure-output" id="outputcode6"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.6:</strong> Lower/upper bounds find insertion points and handle duplicates.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.7 ‚Äî Find First and Last Position</span>
                    <button class="code-figure-run" onclick="runCode('code7')">‚ñ∂ Run</button>
                </div>
                <textarea id="code7" spellcheck="false">def search_range(arr, target):
    """
    Find first and last position of target in sorted array.
    Returns [-1, -1] if not found.
    """
    def find_first(arr, target):
        left, right = 0, len(arr) - 1
        result = -1
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] == target:
                result = mid
                right = mid - 1  # Keep searching left
            elif arr[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return result
    
    def find_last(arr, target):
        left, right = 0, len(arr) - 1
        result = -1
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] == target:
                result = mid
                left = mid + 1  # Keep searching right
            elif arr[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return result
    
    return [find_first(arr, target), find_last(arr, target)]

# Test
arr = [5, 7, 7, 8, 8, 8, 10]
print(f"Array: {arr}")
print(f"Range of 8: {search_range(arr, 8)}")
print(f"Range of 7: {search_range(arr, 7)}")
print(f"Range of 6: {search_range(arr, 6)}")</textarea>
                <div class="code-figure-output" id="outputcode7"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.7:</strong> Two binary searches find first and last occurrence of a value.
                </div>
            </div>
            
            <h3>Finding Minimum/Maximum</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.8 ‚Äî Find Peak Element</span>
                    <button class="code-figure-run" onclick="runCode('code8')">‚ñ∂ Run</button>
                </div>
                <textarea id="code8" spellcheck="false">def find_peak_element(arr):
    """
    Find a peak element where arr[i] > arr[i-1] and arr[i] > arr[i+1].
    Multiple peaks may exist; return any one.
    """
    left, right = 0, len(arr) - 1
    
    while left < right:
        mid = (left + right) // 2
        
        if arr[mid] > arr[mid + 1]:
            # Peak is on left side (or at mid)
            right = mid
        else:
            # Peak is on right side
            left = mid + 1
    
    return left

# Test
arr = [1, 2, 3, 1]
print(f"Array: {arr}")
print(f"Peak index: {find_peak_element(arr)}")
print(f"Peak value: {arr[find_peak_element(arr)]}")

arr = [1, 2, 1, 3, 5, 6, 4]
print(f"\nArray: {arr}")
idx = find_peak_element(arr)
print(f"Peak index: {idx}, value: {arr[idx]}")</textarea>
                <div class="code-figure-output" id="outputcode8"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.8:</strong> Binary search finds peak by following the ascending slope.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.9 ‚Äî Find Minimum in Rotated Array</span>
                    <button class="code-figure-run" onclick="runCode('code9')">‚ñ∂ Run</button>
                </div>
                <textarea id="code9" spellcheck="false">def find_min_rotated(arr):
    """
    Find minimum in rotated sorted array (no duplicates).
    Array was sorted, then rotated at some pivot.
    """
    left, right = 0, len(arr) - 1
    
    while left < right:
        mid = (left + right) // 2
        
        if arr[mid] > arr[right]:
            # Minimum is in right half
            left = mid + 1
        else:
            # Minimum is in left half (or at mid)
            right = mid
    
    return arr[left]

# Test
arr = [4, 5, 6, 7, 0, 1, 2]
print(f"Rotated array: {arr}")
print(f"Minimum: {find_min_rotated(arr)}")

arr = [3, 4, 5, 1, 2]
print(f"\nRotated array: {arr}")
print(f"Minimum: {find_min_rotated(arr)}")</textarea>
                <div class="code-figure-output" id="outputcode9"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.9:</strong> In rotated array, compare mid with right to find which half contains minimum.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 5: SEARCH IN ROTATED ARRAYS -->
        <!-- ============================================== -->
        <section id="rotated">
            <h2>5. Search in Rotated Arrays</h2>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.10 ‚Äî Search in Rotated Array</span>
                    <button class="code-figure-run" onclick="runCode('code10')">‚ñ∂ Run</button>
                </div>
                <textarea id="code10" spellcheck="false">def search_rotated(arr, target):
    """
    Search in rotated sorted array (no duplicates).
    One half is always sorted; use that to determine which half.
    """
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        
        # Left half is sorted
        if arr[left] <= arr[mid]:
            if arr[left] <= target < arr[mid]:
                right = mid - 1
            else:
                left = mid + 1
        # Right half is sorted
        else:
            if arr[mid] < target <= arr[right]:
                left = mid + 1
            else:
                right = mid - 1
    
    return -1

# Test
arr = [4, 5, 6, 7, 0, 1, 2]
print(f"Array: {arr}")
print(f"Index of 0: {search_rotated(arr, 0)}")
print(f"Index of 6: {search_rotated(arr, 6)}")
print(f"Index of 3: {search_rotated(arr, 3)}")</textarea>
                <div class="code-figure-output" id="outputcode10"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.10:</strong> Determine which half is sorted, then check if target is in that half.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.11 ‚Äî Search in Rotated Array with Duplicates</span>
                    <button class="code-figure-run" onclick="runCode('code11')">‚ñ∂ Run</button>
                </div>
                <textarea id="code11" spellcheck="false">def search_rotated_duplicates(arr, target):
    """
    Search in rotated sorted array WITH duplicates.
    Worst case O(n) when many duplicates.
    """
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return True
        
        # Handle duplicates - shrink search space
        if arr[left] == arr[mid] == arr[right]:
            left += 1
            right -= 1
        # Left half is sorted
        elif arr[left] <= arr[mid]:
            if arr[left] <= target < arr[mid]:
                right = mid - 1
            else:
                left = mid + 1
        # Right half is sorted
        else:
            if arr[mid] < target <= arr[right]:
                left = mid + 1
            else:
                right = mid - 1
    
    return False

# Test
arr = [2, 5, 6, 0, 0, 1, 2]
print(f"Array: {arr}")
print(f"Contains 0: {search_rotated_duplicates(arr, 0)}")
print(f"Contains 3: {search_rotated_duplicates(arr, 3)}")

arr = [1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1]
print(f"\nArray with many duplicates: {arr}")
print(f"Contains 2: {search_rotated_duplicates(arr, 2)}")</textarea>
                <div class="code-figure-output" id="outputcode11"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.11:</strong> Duplicates require handling the case where left == mid == right.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 6: SEARCH IN 2D ARRAYS -->
        <!-- ============================================== -->
        <section id="2d">
            <h2>6. Search in 2D Arrays</h2>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.12 ‚Äî Search 2D Matrix (Sorted Rows)</span>
                    <button class="code-figure-run" onclick="runCode('code12')">‚ñ∂ Run</button>
                </div>
                <textarea id="code12" spellcheck="false">def search_matrix(matrix, target):
    """
    Search in 2D matrix where:
    - Each row is sorted
    - First element of each row > last element of previous row
    Treat as flattened sorted array.
    """
    if not matrix or not matrix[0]:
        return False
    
    rows, cols = len(matrix), len(matrix[0])
    left, right = 0, rows * cols - 1
    
    while left <= right:
        mid = (left + right) // 2
        # Convert 1D index to 2D
        row, col = mid // cols, mid % cols
        val = matrix[row][col]
        
        if val == target:
            return True
        elif val < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return False

# Test
matrix = [
    [1,  3,  5,  7],
    [10, 11, 16, 20],
    [23, 30, 34, 60]
]
print("Matrix:")
for row in matrix:
    print(f"  {row}")

print(f"\nSearch 3: {search_matrix(matrix, 3)}")
print(f"Search 13: {search_matrix(matrix, 13)}")</textarea>
                <div class="code-figure-output" id="outputcode12"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.12:</strong> Fully sorted 2D matrix can be treated as 1D array for binary search.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.13 ‚Äî Search 2D Matrix II (Row/Col Sorted)</span>
                    <button class="code-figure-run" onclick="runCode('code13')">‚ñ∂ Run</button>
                </div>
                <textarea id="code13" spellcheck="false">def search_matrix_ii(matrix, target):
    """
    Search in 2D matrix where:
    - Each row is sorted left to right
    - Each column is sorted top to bottom
    Start from top-right (or bottom-left) corner.
    """
    if not matrix or not matrix[0]:
        return False
    
    rows, cols = len(matrix), len(matrix[0])
    row, col = 0, cols - 1  # Start top-right
    
    while row < rows and col >= 0:
        if matrix[row][col] == target:
            return True
        elif matrix[row][col] > target:
            col -= 1  # Go left
        else:
            row += 1  # Go down
    
    return False

# Test
matrix = [
    [1,  4,  7,  11, 15],
    [2,  5,  8,  12, 19],
    [3,  6,  9,  16, 22],
    [10, 13, 14, 17, 24],
    [18, 21, 23, 26, 30]
]
print("Matrix (rows and columns sorted):")
for row in matrix:
    print(f"  {row}")

print(f"\nSearch 5: {search_matrix_ii(matrix, 5)}")
print(f"Search 20: {search_matrix_ii(matrix, 20)}")</textarea>
                <div class="code-figure-output" id="outputcode13"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.13:</strong> Start from corner‚Äîeach step eliminates a row or column. O(m + n) time.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.14 ‚Äî Kth Smallest in Sorted Matrix</span>
                    <button class="code-figure-run" onclick="runCode('code14')">‚ñ∂ Run</button>
                </div>
                <textarea id="code14" spellcheck="false">def kth_smallest_matrix(matrix, k):
    """
    Find kth smallest element in row/column sorted matrix.
    Binary search on value range, count elements <= mid.
    """
    n = len(matrix)
    
    def count_less_equal(target):
        """Count elements <= target using staircase search."""
        count = 0
        row, col = n - 1, 0  # Start bottom-left
        while row >= 0 and col < n:
            if matrix[row][col] <= target:
                count += row + 1  # All elements in this column
                col += 1
            else:
                row -= 1
        return count
    
    # Binary search on value
    left, right = matrix[0][0], matrix[n-1][n-1]
    
    while left < right:
        mid = (left + right) // 2
        if count_less_equal(mid) < k:
            left = mid + 1
        else:
            right = mid
    
    return left

# Test
matrix = [
    [1,  5,  9],
    [10, 11, 13],
    [12, 13, 15]
]
print("Matrix:")
for row in matrix:
    print(f"  {row}")

for k in [1, 5, 8]:
    print(f"  {k}th smallest: {kth_smallest_matrix(matrix, k)}")</textarea>
                <div class="code-figure-output" id="outputcode14"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.14:</strong> Binary search on value range combined with counting achieves O(n log(max-min)).
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 7: SEARCH IN TREES -->
        <!-- ============================================== -->
        <section id="trees">
            <h2>7. Search in Trees</h2>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.15 ‚Äî BST Search</span>
                    <button class="code-figure-run" onclick="runCode('code15')">‚ñ∂ Run</button>
                </div>
                <textarea id="code15" spellcheck="false">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def search_bst(root, target):
    """
    Search in Binary Search Tree - O(h) time where h is height.
    O(log n) for balanced tree, O(n) for skewed tree.
    """
    while root:
        if target == root.val:
            return root
        elif target < root.val:
            root = root.left
        else:
            root = root.right
    return None

def search_bst_recursive(root, target):
    """Recursive BST search."""
    if not root or root.val == target:
        return root
    if target < root.val:
        return search_bst_recursive(root.left, target)
    return search_bst_recursive(root.right, target)

# Build BST:     5
#              /   \
#             3     7
#            / \   / \
#           2   4 6   8

root = TreeNode(5)
root.left = TreeNode(3, TreeNode(2), TreeNode(4))
root.right = TreeNode(7, TreeNode(6), TreeNode(8))

print("BST: [5, 3, 7, 2, 4, 6, 8]")
for target in [4, 9]:
    result = search_bst(root, target)
    print(f"Search {target}: {'Found' if result else 'Not found'}")</textarea>
                <div class="code-figure-output" id="outputcode15"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.15:</strong> BST search follows left/right based on comparison‚Äîlike binary search in arrays.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.16 ‚Äî Find Closest Value in BST</span>
                    <button class="code-figure-run" onclick="runCode('code16')">‚ñ∂ Run</button>
                </div>
                <textarea id="code16" spellcheck="false">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def closest_value(root, target):
    """Find value in BST closest to target."""
    closest = root.val
    
    while root:
        if abs(root.val - target) < abs(closest - target):
            closest = root.val
        
        if target < root.val:
            root = root.left
        elif target > root.val:
            root = root.right
        else:
            return root.val  # Exact match
    
    return closest

# Build BST
root = TreeNode(4)
root.left = TreeNode(2, TreeNode(1), TreeNode(3))
root.right = TreeNode(5)

print("BST: [4, 2, 5, 1, 3]")
for target in [3.7, 2.5, 4.5, 0.1]:
    print(f"Closest to {target}: {closest_value(root, target)}")</textarea>
                <div class="code-figure-output" id="outputcode16"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.16:</strong> Track closest seen while traversing towards target.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.17 ‚Äî Validate BST</span>
                    <button class="code-figure-run" onclick="runCode('code17')">‚ñ∂ Run</button>
                </div>
                <textarea id="code17" spellcheck="false">class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def is_valid_bst(root, min_val=float('-inf'), max_val=float('inf')):
    """
    Validate Binary Search Tree.
    Each node must be within valid range based on ancestors.
    """
    if not root:
        return True
    
    if root.val <= min_val or root.val >= max_val:
        return False
    
    return (is_valid_bst(root.left, min_val, root.val) and
            is_valid_bst(root.right, root.val, max_val))

# Valid BST
root1 = TreeNode(2, TreeNode(1), TreeNode(3))
print(f"[2, 1, 3] is valid BST: {is_valid_bst(root1)}")

# Invalid BST
root2 = TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))
print(f"[5, 1, 4, null, null, 3, 6] is valid BST: {is_valid_bst(root2)}")</textarea>
                <div class="code-figure-output" id="outputcode17"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.17:</strong> Pass valid range to each subtree‚Äîleft must be less than root, right must be greater.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 8: SEARCH IN GRAPHS -->
        <!-- ============================================== -->
        <section id="graphs">
            <h2>8. Search in Graphs</h2>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.18 ‚Äî BFS Shortest Path</span>
                    <button class="code-figure-run" onclick="runCode('code18')">‚ñ∂ Run</button>
                </div>
                <textarea id="code18" spellcheck="false">from collections import deque

def bfs_shortest_path(graph, start, target):
    """
    BFS finds shortest path in unweighted graph.
    Returns path and distance, or (None, -1) if not found.
    """
    if start == target:
        return [start], 0
    
    visited = {start}
    queue = deque([(start, [start])])
    
    while queue:
        node, path = queue.popleft()
        
        for neighbor in graph[node]:
            if neighbor == target:
                return path + [neighbor], len(path)
            
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    
    return None, -1

# Test
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

path, dist = bfs_shortest_path(graph, 'A', 'F')
print(f"Shortest A to F: {path}, distance: {dist}")

path, dist = bfs_shortest_path(graph, 'D', 'F')
print(f"Shortest D to F: {path}, distance: {dist}")</textarea>
                <div class="code-figure-output" id="outputcode18"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.18:</strong> BFS explores level by level, guaranteeing shortest path in unweighted graphs.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.19 ‚Äî DFS Path Existence</span>
                    <button class="code-figure-run" onclick="runCode('code19')">‚ñ∂ Run</button>
                </div>
                <textarea id="code19" spellcheck="false">def dfs_path_exists(graph, start, target, visited=None):
    """
    DFS checks if path exists between two nodes.
    Returns True/False (not shortest path).
    """
    if visited is None:
        visited = set()
    
    if start == target:
        return True
    
    visited.add(start)
    
    for neighbor in graph.get(start, []):
        if neighbor not in visited:
            if dfs_path_exists(graph, neighbor, target, visited):
                return True
    
    return False

# Test
graph = {
    'A': ['B', 'C'],
    'B': ['D'],
    'C': ['E'],
    'D': [],
    'E': ['F'],
    'F': []
}

print(f"Path A to F exists: {dfs_path_exists(graph, 'A', 'F')}")
print(f"Path A to D exists: {dfs_path_exists(graph, 'A', 'D')}")
print(f"Path D to A exists: {dfs_path_exists(graph, 'D', 'A')}")</textarea>
                <div class="code-figure-output" id="outputcode19"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.19:</strong> DFS uses recursion/stack to explore paths deeply before backtracking.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.20 ‚Äî Binary Search on Answer</span>
                    <button class="code-figure-run" onclick="runCode('code20')">‚ñ∂ Run</button>
                </div>
                <textarea id="code20" spellcheck="false">def can_finish_in_days(weights, capacity, days):
    """Check if we can ship all weights within given days."""
    current_load = 0
    days_needed = 1
    
    for w in weights:
        if current_load + w > capacity:
            days_needed += 1
            current_load = w
        else:
            current_load += w
    
    return days_needed <= days

def ship_within_days(weights, days):
    """
    Find minimum ship capacity to ship all packages within days.
    Binary search on the answer (capacity).
    """
    # Minimum: largest single package
    # Maximum: sum of all packages
    left = max(weights)
    right = sum(weights)
    
    while left < right:
        mid = (left + right) // 2
        if can_finish_in_days(weights, mid, days):
            right = mid
        else:
            left = mid + 1
    
    return left

# Test
weights = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
days = 5
print(f"Weights: {weights}")
print(f"Days: {days}")
print(f"Minimum capacity: {ship_within_days(weights, days)}")</textarea>
                <div class="code-figure-output" id="outputcode20"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.20:</strong> Binary search on answer: search the solution space, not the data.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 9: PYTHON'S BISECT MODULE -->
        <!-- ============================================== -->
        <section id="bisect">
            <h2>9. Python's bisect Module</h2>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.21 ‚Äî bisect_left and bisect_right</span>
                    <button class="code-figure-run" onclick="runCode('code21')">‚ñ∂ Run</button>
                </div>
                <textarea id="code21" spellcheck="false">import bisect

arr = [1, 2, 2, 2, 3, 4, 5]
print(f"Array: {arr}")

# bisect_left: insertion point for leftmost position
print(f"\nbisect_left(arr, 2): {bisect.bisect_left(arr, 2)}")
print(f"bisect_left(arr, 2.5): {bisect.bisect_left(arr, 2.5)}")

# bisect_right (or bisect): insertion point for rightmost position
print(f"\nbisect_right(arr, 2): {bisect.bisect_right(arr, 2)}")
print(f"bisect(arr, 2): {bisect.bisect(arr, 2)}")  # Same as bisect_right

# Count occurrences using both
def count_occurrences(arr, x):
    return bisect.bisect_right(arr, x) - bisect.bisect_left(arr, x)

print(f"\nCount of 2: {count_occurrences(arr, 2)}")

# Find exact match (or -1)
def binary_search_bisect(arr, x):
    i = bisect.bisect_left(arr, x)
    if i < len(arr) and arr[i] == x:
        return i
    return -1

print(f"Index of 3: {binary_search_bisect(arr, 3)}")
print(f"Index of 6: {binary_search_bisect(arr, 6)}")</textarea>
                <div class="code-figure-output" id="outputcode21"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.21:</strong> bisect_left finds first position, bisect_right finds after last position.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.22 ‚Äî insort for Sorted Insertion</span>
                    <button class="code-figure-run" onclick="runCode('code22')">‚ñ∂ Run</button>
                </div>
                <textarea id="code22" spellcheck="false">import bisect

# insort maintains sorted order during insertion
arr = [1, 3, 5, 7, 9]
print(f"Original: {arr}")

bisect.insort(arr, 4)
print(f"After insort(4): {arr}")

bisect.insort(arr, 0)
print(f"After insort(0): {arr}")

bisect.insort(arr, 10)
print(f"After insort(10): {arr}")

# insort_left vs insort_right for duplicates
arr = [1, 2, 2, 2, 3]
bisect.insort_left(arr, 2)  # Insert before existing 2s
print(f"\ninsort_left(2): {arr}")

arr = [1, 2, 2, 2, 3]
bisect.insort_right(arr, 2)  # Insert after existing 2s
print(f"insort_right(2): {arr}")</textarea>
                <div class="code-figure-output" id="outputcode22"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.22:</strong> insort combines finding position and inserting in one call.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.23 ‚Äî Custom Key with bisect</span>
                    <button class="code-figure-run" onclick="runCode('code23')">‚ñ∂ Run</button>
                </div>
                <textarea id="code23" spellcheck="false">import bisect

# Sort by custom key - need to maintain separate key list
data = [(1, 'a'), (3, 'c'), (5, 'e'), (7, 'g')]
keys = [x[0] for x in data]  # Extract keys

# Find where to insert (4, 'd')
new_item = (4, 'd')
idx = bisect.bisect_left(keys, new_item[0])
data.insert(idx, new_item)
keys.insert(idx, new_item[0])

print(f"After inserting {new_item}: {data}")

# Python 3.10+ has key parameter
# bisect.bisect_left(data, 4, key=lambda x: x[0])

# Alternative: use a wrapper class
class KeyWrapper:
    def __init__(self, item, key):
        self.item = item
        self.key = key(item)
    def __lt__(self, other):
        return self.key < other.key

# Example with objects sorted by attribute
students = [('Alice', 85), ('Bob', 90), ('Carol', 78)]
students.sort(key=lambda x: x[1])
print(f"\nStudents by grade: {students}")</textarea>
                <div class="code-figure-output" id="outputcode23"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.23:</strong> Custom keys require maintaining a separate key list or using a wrapper.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 10: COMMON PATTERNS -->
        <!-- ============================================== -->
        <section id="patterns">
            <h2>10. Common Patterns</h2>
            
            <h3>Pattern 1: Binary Search Template</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.24 ‚Äî Universal Binary Search Template</span>
                    <button class="code-figure-run" onclick="runCode('code24')">‚ñ∂ Run</button>
                </div>
                <textarea id="code24" spellcheck="false">def binary_search_template(arr, target):
    """
    Universal template for binary search problems.
    Find minimum index where condition(mid) is True.
    """
    left, right = 0, len(arr)  # [left, right) search space
    
    def condition(mid):
        # Define based on problem
        return arr[mid] >= target
    
    while left < right:
        mid = left + (right - left) // 2
        if condition(mid):
            right = mid
        else:
            left = mid + 1
    
    return left

# Example: Find first element >= target (lower bound)
arr = [1, 3, 5, 7, 9, 11]
print(f"Array: {arr}")
print(f"First >= 6: index {binary_search_template(arr, 6)}")
print(f"First >= 7: index {binary_search_template(arr, 7)}")

# The template can be adapted:
# - For exact match: check arr[result] == target
# - For upper bound: change condition to arr[mid] > target
# - For last occurrence: change to find first > target, then subtract 1</textarea>
                <div class="code-figure-output" id="outputcode24"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.24:</strong> The template finds the boundary where condition changes from False to True.
                </div>
            </div>
            
            <h3>Pattern 2: Search on Answer</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.25 ‚Äî Split Array Largest Sum</span>
                    <button class="code-figure-run" onclick="runCode('code25')">‚ñ∂ Run</button>
                </div>
                <textarea id="code25" spellcheck="false">def split_array(nums, k):
    """
    Split array into k subarrays to minimize largest sum.
    Binary search on the answer (max sum).
    """
    def can_split(max_sum):
        """Can we split into <= k subarrays with this max_sum?"""
        count = 1
        current_sum = 0
        for num in nums:
            if current_sum + num > max_sum:
                count += 1
                current_sum = num
            else:
                current_sum += num
        return count <= k
    
    left = max(nums)  # At least largest element
    right = sum(nums)  # At most entire array
    
    while left < right:
        mid = (left + right) // 2
        if can_split(mid):
            right = mid
        else:
            left = mid + 1
    
    return left

# Test
nums = [7, 2, 5, 10, 8]
k = 2
print(f"Array: {nums}, k={k}")
print(f"Minimum largest sum: {split_array(nums, k)}")
# Split: [7, 2, 5] and [10, 8] with sums 14 and 18</textarea>
                <div class="code-figure-output" id="outputcode25"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.25:</strong> When asked to minimize/maximize something, binary search on that value.
                </div>
            </div>
            
            <h3>Pattern 3: Two Pointers + Binary Search</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.26 ‚Äî Find K Closest Elements</span>
                    <button class="code-figure-run" onclick="runCode('code26')">‚ñ∂ Run</button>
                </div>
                <textarea id="code26" spellcheck="false">def find_closest_elements(arr, k, x):
    """
    Find k closest elements to x in sorted array.
    Binary search + two pointers.
    """
    # Binary search for window start
    left, right = 0, len(arr) - k
    
    while left < right:
        mid = (left + right) // 2
        # Compare distances at window boundaries
        if x - arr[mid] > arr[mid + k] - x:
            left = mid + 1
        else:
            right = mid
    
    return arr[left:left + k]

# Test
arr = [1, 2, 3, 4, 5]
print(f"Array: {arr}")
print(f"3 closest to 3: {find_closest_elements(arr, 3, 3)}")
print(f"3 closest to -1: {find_closest_elements(arr, 3, -1)}")

arr = [1, 1, 1, 10, 10, 10]
print(f"\nArray: {arr}")
print(f"3 closest to 9: {find_closest_elements(arr, 3, 9)}")</textarea>
                <div class="code-figure-output" id="outputcode26"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.26:</strong> Binary search finds optimal window position by comparing distances.
                </div>
            </div>
            
            <h3>Pattern 4: Exponential Search</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.27 ‚Äî Exponential Search</span>
                    <button class="code-figure-run" onclick="runCode('code27')">‚ñ∂ Run</button>
                </div>
                <textarea id="code27" spellcheck="false">def exponential_search(arr, target):
    """
    Find target using exponential search.
    Good when target is near beginning of large array.
    """
    if arr[0] == target:
        return 0
    
    # Find range where target might exist
    bound = 1
    while bound < len(arr) and arr[bound] < target:
        bound *= 2
    
    # Binary search in found range
    left = bound // 2
    right = min(bound, len(arr) - 1)
    
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1

# Test
arr = list(range(1000))
print(f"Array: [0, 1, 2, ..., 999]")
print(f"Index of 5: {exponential_search(arr, 5)}")
print(f"Index of 500: {exponential_search(arr, 500)}")</textarea>
                <div class="code-figure-output" id="outputcode27"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.27:</strong> Exponential search doubles bound until exceeding target, then binary searches.
                </div>
            </div>
            
            <h3>Pattern 5: Ternary Search</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.28 ‚Äî Ternary Search for Unimodal Function</span>
                    <button class="code-figure-run" onclick="runCode('code28')">‚ñ∂ Run</button>
                </div>
                <textarea id="code28" spellcheck="false">def ternary_search_max(f, left, right, epsilon=1e-9):
    """
    Find maximum of unimodal function.
    Function first increases then decreases.
    """
    while right - left > epsilon:
        m1 = left + (right - left) / 3
        m2 = right - (right - left) / 3
        
        if f(m1) < f(m2):
            left = m1
        else:
            right = m2
    
    return (left + right) / 2

# Test with parabola y = -(x-3)^2 + 10 (max at x=3)
f = lambda x: -(x - 3) ** 2 + 10

max_x = ternary_search_max(f, 0, 10)
print(f"Function: -(x-3)^2 + 10")
print(f"Maximum at x = {max_x:.6f}")
print(f"Maximum value = {f(max_x):.6f}")</textarea>
                <div class="code-figure-output" id="outputcode28"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.28:</strong> Ternary search finds extrema in unimodal functions by eliminating 1/3 each step.
                </div>
            </div>
            
            <div class="summary">
                <div class="summary-title">Key Takeaways</div>
                <ul>
                    <li><strong>Linear search:</strong> O(n), works on any data, simple but slow</li>
                    <li><strong>Binary search:</strong> O(log n), requires sorted array with random access</li>
                    <li><strong>Search on answer:</strong> Binary search the solution space, not just data</li>
                    <li><strong>BST search:</strong> O(h) where h is height, O(log n) for balanced trees</li>
                    <li><strong>Graph search:</strong> BFS for shortest path, DFS for path existence</li>
                    <li><strong>bisect module:</strong> Production-ready binary search in Python</li>
                </ul>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 11: PITFALLS -->
        <!-- ============================================== -->
        <section id="pitfalls">
            <h2>11. Common Pitfalls</h2>
            
            <h3>Pitfall 1: Off-by-One Errors</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.29 ‚Äî Binary Search Boundary Conditions</span>
                    <button class="code-figure-run" onclick="runCode('code29')">‚ñ∂ Run</button>
                </div>
                <textarea id="code29" spellcheck="false"># Three common binary search patterns:

def pattern1_exact(arr, target):
    """Find exact match: left <= right, mid¬±1"""
    left, right = 0, len(arr) - 1
    while left <= right:  # <= for inclusive
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

def pattern2_lower(arr, target):
    """Find lower bound: left < right, right = mid"""
    left, right = 0, len(arr)  # right = len for insertion point
    while left < right:  # < because right is exclusive
        mid = (left + right) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid  # Don't skip mid
    return left

def pattern3_last(arr, target):
    """Find last occurrence: modify lower bound"""
    left, right = 0, len(arr)
    while left < right:
        mid = (left + right) // 2
        if arr[mid] <= target:
            left = mid + 1
        else:
            right = mid
    return left - 1 if left > 0 and arr[left-1] == target else -1

arr = [1, 2, 2, 2, 3, 4]
print(f"Array: {arr}")
print(f"Exact match for 2: {pattern1_exact(arr, 2)}")
print(f"Lower bound for 2: {pattern2_lower(arr, 2)}")
print(f"Last occurrence of 2: {pattern3_last(arr, 2)}")</textarea>
                <div class="code-figure-output" id="outputcode29"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.29:</strong> Different patterns require different boundary conditions‚Äîbe consistent!
                </div>
            </div>
            
            <h3>Pitfall 2: Integer Overflow (in other languages)</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.30 ‚Äî Safe Mid Calculation</span>
                    <button class="code-figure-run" onclick="runCode('code30')">‚ñ∂ Run</button>
                </div>
                <textarea id="code30" spellcheck="false"># In Python, integers have arbitrary precision - no overflow
# But in C/Java, (left + right) can overflow!

# WRONG in C/Java (but fine in Python):
# mid = (left + right) / 2

# SAFE in all languages:
# mid = left + (right - left) // 2

# Or using bit manipulation:
# mid = (left + right) >> 1  # Still can overflow in C/Java
# mid = left + ((right - left) >> 1)  # Safe

# Python example showing both work:
left = 10**18
right = 10**18 + 100

mid1 = (left + right) // 2
mid2 = left + (right - left) // 2

print(f"left = {left}")
print(f"right = {right}")
print(f"(left + right) // 2 = {mid1}")
print(f"left + (right - left) // 2 = {mid2}")
print(f"Both equal: {mid1 == mid2}")</textarea>
                <div class="code-figure-output" id="outputcode30"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.30:</strong> Use left + (right - left) // 2 for portability to other languages.
                </div>
            </div>
            
            <h3>Pitfall 3: Infinite Loop</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.31 ‚Äî Avoiding Infinite Loops</span>
                    <button class="code-figure-run" onclick="runCode('code31')">‚ñ∂ Run</button>
                </div>
                <textarea id="code31" spellcheck="false"># WRONG: Can cause infinite loop
def bad_binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < target:
            left = mid  # WRONG! Should be mid + 1
        else:
            right = mid
    return left

# When left = 0, right = 1, mid = 0
# If arr[0] < target, left stays 0 forever!

# RIGHT: Ensure progress each iteration
def good_binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < target:
            left = mid + 1  # CORRECT: Always makes progress
        else:
            right = mid
    return left

print("Testing on [1, 3, 5, 7]:")
arr = [1, 3, 5, 7]
print(f"Search for 4: index {good_binary_search(arr, 4)}")

# Rule: At least one of left or right must change each iteration</textarea>
                <div class="code-figure-output" id="outputcode31"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.31:</strong> When left < right, use left = mid + 1 to ensure progress.
                </div>
            </div>
            
            <h3>Pitfall 4: Searching Unsorted Array</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.32 ‚Äî Verify Sorted Before Binary Search</span>
                    <button class="code-figure-run" onclick="runCode('code32')">‚ñ∂ Run</button>
                </div>
                <textarea id="code32" spellcheck="false">def binary_search_safe(arr, target):
    """Binary search with sorted check (for debugging)."""
    # Verify sorted (O(n) - only for debugging!)
    assert all(arr[i] <= arr[i+1] for i in range(len(arr)-1)), \
           "Array must be sorted!"
    
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# Test with sorted array
arr = [1, 3, 5, 7, 9]
print(f"Sorted array: {arr}")
print(f"Search 5: {binary_search_safe(arr, 5)}")

# Test with unsorted array
arr = [3, 1, 4, 1, 5]
print(f"\nUnsorted array: {arr}")
try:
    binary_search_safe(arr, 4)
except AssertionError as e:
    print(f"Error: {e}")</textarea>
                <div class="code-figure-output" id="outputcode32"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.32:</strong> Binary search on unsorted array gives incorrect results‚Äîverify during debugging.
                </div>
            </div>
            
            <h3>Pitfall 5: Empty Array</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 11.33 ‚Äî Handle Edge Cases</span>
                    <button class="code-figure-run" onclick="runCode('code33')">‚ñ∂ Run</button>
                </div>
                <textarea id="code33" spellcheck="false">def binary_search_robust(arr, target):
    """Binary search handling edge cases."""
    # Handle empty array
    if not arr:
        return -1
    
    # Handle single element
    if len(arr) == 1:
        return 0 if arr[0] == target else -1
    
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1

# Test edge cases
print(f"Empty array []: {binary_search_robust([], 5)}")
print(f"Single [5] search 5: {binary_search_robust([5], 5)}")
print(f"Single [5] search 3: {binary_search_robust([5], 3)}")
print(f"Two elements [1,3] search 3: {binary_search_robust([1,3], 3)}")</textarea>
                <div class="code-figure-output" id="outputcode33"></div>
                <div class="code-figure-caption">
                    <strong>Figure 11.33:</strong> Always handle empty arrays and single-element arrays explicitly.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 12: EXERCISES -->
        <!-- ============================================== -->
        <section id="exercises">
            <h2>12. Exercises</h2>
            
            <!-- Exercise 1 -->
            <div class="exercise">
                <div class="exercise-title">Exercise 1: Search Insert Position</div>
                <p>Given a sorted array and target, return index if found, else the index where it would be inserted to keep sorted order.</p>
                <p class="answer">(Hint: This is exactly lower bound‚Äîfind first position where arr[i] >= target)</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 1 ‚Äî Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex1')">‚ñ∂ Run</button>
                </div>
                <textarea id="ex1" spellcheck="false"># HINT 1: Use left < right pattern with right = len(arr)
# HINT 2: If arr[mid] < target, move left = mid + 1
# HINT 3: Otherwise, right = mid

def search_insert(nums, target):
    # Your code here
    pass

# Test your implementation
# print(search_insert([1,3,5,6], 5))  # 2
# print(search_insert([1,3,5,6], 2))  # 1
# print(search_insert([1,3,5,6], 7))  # 4</textarea>
                <div class="code-figure-output" id="outputex1"></div>
            </div>
            
            <!-- Exercise 2 -->
            <div class="exercise">
                <div class="exercise-title">Exercise 2: Find First Bad Version</div>
                <p>You have n versions [1, 2, ..., n]. Given a function isBadVersion(v) that returns True if v is bad, find the first bad version. All versions after a bad version are also bad.</p>
                <p class="answer">(Hint: Binary search for boundary where isBadVersion changes from False to True)</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 2 ‚Äî Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex2')">‚ñ∂ Run</button>
                </div>
                <textarea id="ex2" spellcheck="false"># HINT 1: Search space is [1, n]
# HINT 2: If isBadVersion(mid), first bad is at or before mid
# HINT 3: If not bad, first bad is after mid

def first_bad_version(n, is_bad_version):
    # Your code here
    pass

# Test your implementation
# def is_bad(v): return v >= 4  # 4 is first bad
# print(first_bad_version(5, is_bad))  # 4</textarea>
                <div class="code-figure-output" id="outputex2"></div>
            </div>
            
            <!-- Exercise 3 -->
            <div class="exercise">
                <div class="exercise-title">Exercise 3: Sqrt(x)</div>
                <p>Compute the square root of x rounded down to the nearest integer. Do not use built-in sqrt functions.</p>
                <p class="answer">(Hint: Binary search for largest integer n where n*n <= x)</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 3 ‚Äî Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex3')">‚ñ∂ Run</button>
                </div>
                <textarea id="ex3" spellcheck="false"># HINT 1: Search space is [0, x]
# HINT 2: If mid*mid <= x, answer is at least mid
# HINT 3: Track the best valid answer seen

def my_sqrt(x):
    # Your code here
    pass

# Test your implementation
# print(my_sqrt(4))   # 2
# print(my_sqrt(8))   # 2 (sqrt(8) ‚âà 2.83)
# print(my_sqrt(16))  # 4</textarea>
                <div class="code-figure-output" id="outputex3"></div>
            </div>
            
            <!-- Exercise 4 -->
            <div class="exercise">
                <div class="exercise-title">Exercise 4: Find Minimum in Rotated Sorted Array II</div>
                <p>Find minimum in rotated sorted array that may contain duplicates.</p>
                <p class="answer">(Hint: When arr[mid] == arr[right], can't determine which half‚Äîshrink by 1)</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 4 ‚Äî Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex4')">‚ñ∂ Run</button>
                </div>
                <textarea id="ex4" spellcheck="false"># HINT 1: Compare mid with right
# HINT 2: If arr[mid] > arr[right], min is on right
# HINT 3: If arr[mid] < arr[right], min is on left
# HINT 4: If equal, just do right -= 1

def find_min_duplicates(nums):
    # Your code here
    pass

# Test your implementation
# print(find_min_duplicates([2,2,2,0,1]))  # 0
# print(find_min_duplicates([1,1,1,1,1]))  # 1</textarea>
                <div class="code-figure-output" id="outputex4"></div>
            </div>
            
            <!-- Exercise 5 -->
            <div class="exercise">
                <div class="exercise-title">Exercise 5: Koko Eating Bananas</div>
                <p>Koko has n piles of bananas. She can eat k bananas per hour. Each hour she chooses a pile and eats k bananas (or the whole pile if less than k). Find minimum k to finish within h hours.</p>
                <p class="answer">(Hint: Binary search on k. For each k, calculate hours needed using ceiling division)</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 5 ‚Äî Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex5')">‚ñ∂ Run</button>
                </div>
                <textarea id="ex5" spellcheck="false"># HINT 1: k ranges from 1 to max(piles)
# HINT 2: Hours for pile p at speed k: (p + k - 1) // k (ceiling division)
# HINT 3: Find minimum k where total hours <= h

def min_eating_speed(piles, h):
    # Your code here
    pass

# Test your implementation
# print(min_eating_speed([3,6,7,11], 8))  # 4
# print(min_eating_speed([30,11,23,4,20], 5))  # 30</textarea>
                <div class="code-figure-output" id="outputex5"></div>
            </div>
        </section>

        <!-- SUBMIT SECTION -->
        <section class="submit-section">
            <h2>Submit Your Work</h2>
            <p>After completing the exercises, submit your attendance below.</p>
            
            <div class="form-row">
                <div class="form-group">
                    <label>Student ID</label>
                    <input type="text" id="studentId" placeholder="Enter your student ID">
                </div>
                <div class="form-group">
                    <label>Full Name</label>
                    <input type="text" id="studentName" placeholder="Enter your full name">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>Email (@istun.edu.tr)</label>
                    <input type="email" id="studentEmail" placeholder="your.email@istun.edu.tr">
                </div>
                <div class="form-group">
                    <label>Class Code</label>
                    <input type="text" id="classCode" placeholder="From instructor">
                </div>
            </div>
            <input type="text" id="hp" class="hp" tabindex="-1" autocomplete="off">
            <button class="submit-btn" onclick="submitWork()">Submit Attendance</button>
            <div class="submit-status" id="submitStatus"></div>
        </section>
    </main>

    <script>
        const pageLoadTime = Date.now();
        
        async function runCode(codeId) {
            const codeEl = document.getElementById(codeId);
            const outputEl = document.getElementById('output' + codeId);
            const code = codeEl.value;
            outputEl.classList.add('show');
            outputEl.textContent = 'Loading Python...';
            
            try {
                // Wait for PyScript/Pyodide to be ready
                if (!window.pyodideReady) {
                    if (typeof loadPyodide === 'undefined') {
                        // Load Pyodide directly as fallback
                        const script = document.createElement('script');
                        script.src = 'https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js';
                        document.head.appendChild(script);
                        await new Promise((resolve, reject) => {
                            script.onload = resolve;
                            script.onerror = reject;
                            setTimeout(reject, 10000);
                        });
                    }
                    outputEl.textContent = 'Initializing Python (first run may take a moment)...';
                    window.pyodide = await loadPyodide();
                    window.pyodideReady = true;
                }
                
                outputEl.textContent = 'Running...';
                
                // Capture stdout
                window.pyodide.runPython(`
import sys
from io import StringIO
sys.stdout = StringIO()
`);
                
                try {
                    window.pyodide.runPython(code);
                } catch (pyErr) {
                    outputEl.textContent = 'Error: ' + pyErr.message;
                    return;
                }
                
                const output = window.pyodide.runPython('sys.stdout.getvalue()');
                outputEl.textContent = output || '(no output)';
                
            } catch(e) {
                outputEl.textContent = 'Error: ' + e.message;
            }
        }
        
        function submitWork() {
            const status = document.getElementById('submitStatus');
            const data = {
                week: 'Week_11',
                student_id: document.getElementById('studentId').value.trim(),
                student_name: document.getElementById('studentName').value.trim(),
                student_email: document.getElementById('studentEmail').value.trim().toLowerCase(),
                classCode: document.getElementById('classCode').value.trim().toUpperCase(),
                timeOnPage: Math.floor((Date.now() - pageLoadTime) / 1000)
            };
            
            if (document.getElementById('hp').value) {
                status.textContent = 'Submission rejected.';
                status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5';
                return;
            }
            if (data.timeOnPage < 60) {
                status.textContent = 'Please spend more time reviewing the material.';
                status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5';
                return;
            }
            if (!data.student_id || !data.student_name || !data.student_email || !data.classCode) {
                status.textContent = 'All fields are required.';
                status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5';
                return;
            }
            if (!data.student_email.endsWith('@istun.edu.tr')) {
                status.textContent = 'Use your @istun.edu.tr email.';
                status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5';
                return;
            }
            
            status.textContent = 'Submitting...';
            status.style.cssText = 'display:block;background:rgba(124,58,237,0.2);color:#a78bfa';
            
            const scriptUrl = 'https://script.google.com/macros/s/AKfycbzyyvKZRtR7_m05hlB7V-BCBJN3OcOBLjVTFNJ5zNcZFxsOoJMLHLvdUVk4SSqDjtXi/exec';
            
            fetch(scriptUrl, {
                method: 'POST',
                mode: 'cors',
                cache: 'no-cache',
                headers: { 'Content-Type': 'text/plain' },
                body: JSON.stringify(data)
            })
            .then(response => response.json())
            .then(res => {
                if (res.success) {
                    status.textContent = 'Submitted successfully!';
                    status.style.cssText = 'display:block;background:rgba(74,222,128,0.2);color:#4ade80';
                } else {
                    status.textContent = res.message || 'Submission failed. Please try again.';
                    status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5';
                }
            })
            .catch(error => {
                console.error('Fetch error:', error);
                // Fallback: try no-cors mode (won't get response but will send data)
                fetch(scriptUrl, {
                    method: 'POST',
                    mode: 'no-cors',
                    cache: 'no-cache',
                    headers: { 'Content-Type': 'text/plain' },
                    body: JSON.stringify(data)
                })
                .then(() => {
                    status.textContent = 'Request sent. Check your email for confirmation.';
                    status.style.cssText = 'display:block;background:rgba(251,191,36,0.2);color:#fbbf24';
                })
                .catch(() => {
                    status.textContent = 'Connection error. Please try again.';
                    status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5';
                });
            });
        }
    </script>
</body>
</html>
