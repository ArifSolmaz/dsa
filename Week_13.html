<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 13: Greedy Algorithms | DSA Course</title>
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>
    <script type="module">
        // Wait for PyScript to be ready
        const pyReady = new Promise((resolve) => {
            const check = setInterval(() => {
                if (typeof pyscript !== 'undefined' && pyscript.interpreter) {
                    clearInterval(check);
                    resolve();
                }
            }, 100);
            // Timeout after 15 seconds
            setTimeout(() => { clearInterval(check); resolve(); }, 15000);
        });
        window.pyReady = pyReady;
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Crimson Pro', Georgia, serif;
            font-size: 19px;
            background: #faf9f7;
            color: #2c2c2c; 
            line-height: 1.8;
        }
        
        .topbar {
            position: sticky;
            top: 0;
            background: #1a1a2e;
            color: white;
            padding: 12px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }
        .topbar .title { font-family: system-ui, sans-serif; font-size: 0.9rem; font-weight: 500; }
        .topbar a { font-family: system-ui, sans-serif; color: white; text-decoration: none; font-size: 0.85rem; padding: 6px 14px; background: rgba(255,255,255,0.1); border-radius: 5px; }
        .topbar a:hover { background: rgba(255,255,255,0.2); }
        
        .book { max-width: 750px; margin: 0 auto; padding: 60px 40px 100px; }
        
        .chapter-header { text-align: center; padding: 50px 0 60px; border-bottom: 1px solid #ddd; margin-bottom: 50px; }
        .chapter-num { font-family: system-ui, sans-serif; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 3px; color: #7c3aed; margin-bottom: 15px; }
        .chapter-header h1 { font-size: 2.8rem; font-weight: 600; color: #1a1a2e; margin-bottom: 15px; letter-spacing: -0.5px; }
        .chapter-header .subtitle { font-style: italic; color: #666; font-size: 1.1rem; }
        
        h2 { font-size: 1.6rem; font-weight: 600; color: #1a1a2e; margin: 60px 0 25px; padding-top: 30px; border-top: 1px solid #e5e5e5; }
        h2:first-of-type { border-top: none; margin-top: 0; padding-top: 0; }
        h3 { font-size: 1.25rem; font-weight: 600; color: #333; margin: 40px 0 15px; }
        h4 { font-size: 1.05rem; font-weight: 600; color: #555; margin: 30px 0 12px; }
        
        p { margin: 0 0 20px; text-align: justify; hyphens: auto; }
        ul, ol { margin: 20px 0 25px 30px; }
        li { margin: 10px 0; }
        
        code { font-family: 'JetBrains Mono', monospace; font-size: 0.85em; background: #f0eeeb; padding: 2px 6px; border-radius: 3px; color: #7c3aed; }
        .term { font-weight: 600; color: #1a1a2e; }
        
        .definition { background: #f8f7f5; border-left: 4px solid #7c3aed; padding: 20px 25px; margin: 30px 0; }
        .definition-title { font-family: system-ui, sans-serif; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px; color: #7c3aed; margin-bottom: 8px; font-weight: 600; }
        .definition p { margin: 0; }
        
        .margin-note { background: #fffbeb; border: 1px solid #fcd34d; padding: 15px 18px; margin: 25px 0; border-radius: 4px; font-size: 0.9rem; }
        .margin-note::before { content: "üí° "; }
        
        .important { background: #fef2f2; border: 1px solid #fca5a5; padding: 15px 18px; margin: 25px 0; border-radius: 4px; font-size: 0.9rem; }
        .important::before { content: "‚ö†Ô∏è "; }
        
        .example { background: #fafafa; border: 1px solid #e5e5e5; border-radius: 6px; padding: 25px; margin: 30px 0; }
        .example-title { font-family: system-ui, sans-serif; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: #666; margin-bottom: 15px; font-weight: 600; }
        
        .code-figure { margin: 35px 0; border: 1px solid #e0e0e0; border-radius: 6px; overflow: hidden; background: #1e1e2e; }
        .code-figure-header { background: #28283c; padding: 10px 18px; display: flex; justify-content: space-between; align-items: center; }
        .code-figure-label { font-family: system-ui, sans-serif; font-size: 0.75rem; color: #a0a0b0; text-transform: uppercase; letter-spacing: 0.5px; }
        .code-figure-run { font-family: system-ui, sans-serif; background: #7c3aed; color: white; border: none; padding: 5px 14px; border-radius: 4px; font-size: 0.8rem; cursor: pointer; font-weight: 500; }
        .code-figure-run:hover { background: #6d28d9; }
        .code-figure textarea { width: 100%; min-height: 100px; padding: 18px; background: #1e1e2e; color: #e0e0e0; border: none; font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; line-height: 1.6; resize: vertical; }
        .code-figure textarea:focus { outline: none; }
        .code-figure-output { display: none; border-top: 1px solid #28283c; padding: 15px 18px; background: #161622; color: #4ade80; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; white-space: pre-wrap; }
        .code-figure-output.show { display: block; }
        .code-figure-caption { background: #f8f8f8; padding: 12px 18px; font-size: 0.85rem; color: #666; border-top: 1px solid #e0e0e0; }
        .code-figure-caption strong { color: #333; }
        
        .summary { background: linear-gradient(135deg, #7c3aed10, #7c3aed05); border: 1px solid #7c3aed30; border-radius: 8px; padding: 25px 30px; margin: 40px 0; }
        .summary-title { font-family: system-ui, sans-serif; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: #7c3aed; margin-bottom: 12px; font-weight: 600; }
        .summary ul { margin: 0; }
        
        .exercise { background: #f0fdf4; border: 1px solid #bbf7d0; border-radius: 8px; padding: 25px 30px; margin: 40px 0 20px; }
        .exercise-title { font-family: system-ui, sans-serif; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: #16a34a; margin-bottom: 12px; font-weight: 600; }
        .exercise p { margin: 0; }
        .exercise .answer { margin-top: 12px; font-size: 0.9rem; color: #166534; }
        .exercise-description { margin-bottom: 15px; }
        
        /* Hint System */
        .hint-section { margin-top: 15px; padding-top: 15px; border-top: 1px dashed #bbf7d0; }
        .hint-toggle { background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; padding: 8px 16px; border-radius: 20px; font-size: 0.8rem; cursor: pointer; font-family: system-ui, sans-serif; font-weight: 500; transition: all 0.3s ease; margin-right: 8px; margin-bottom: 8px; }
        .hint-toggle:hover { background: linear-gradient(135deg, #059669, #047857); transform: translateY(-1px); }
        .hint-toggle.revealed { background: #6b7280; }
        .hint-content { display: none; background: white; border: 1px solid #d1fae5; border-radius: 8px; padding: 15px 20px; margin-top: 12px; font-size: 0.9rem; color: #065f46; line-height: 1.6; }
        .hint-content.show { display: block; animation: fadeIn 0.3s ease; }
        .hint-content code { background: #d1fae5; color: #065f46; padding: 2px 6px; border-radius: 3px; font-size: 0.85em; }
        .hint-content pre { background: #1e1e2e; color: #e0e0e0; padding: 12px 15px; border-radius: 6px; margin: 10px 0; overflow-x: auto; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }
        .paste-warning { color: #f87171; font-size: 12px; margin-top: 5px; font-family: system-ui, sans-serif; }
        
        table { width: 100%; border-collapse: collapse; margin: 25px 0; font-size: 0.95rem; }
        th, td { border: 1px solid #ddd; padding: 12px 15px; text-align: left; }
        th { background: #f5f5f5; font-weight: 600; }
        
        .submit-section { background: #1a1a2e; color: white; padding: 40px; border-radius: 10px; margin-top: 60px; }
        .submit-section h2 { color: white; border: none; margin: 0 0 20px; padding: 0; font-size: 1.4rem; }
        .submit-section p { color: #a0a0b0; text-align: left; }
        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; font-family: system-ui, sans-serif; font-size: 0.85rem; color: #a0a0b0; margin-bottom: 6px; }
        .form-group input { width: 100%; padding: 12px 14px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 5px; color: white; font-size: 1rem; font-family: system-ui, sans-serif; }
        .form-group input:focus { outline: none; border-color: #7c3aed; }
        .submit-btn { background: #7c3aed; color: white; border: none; padding: 14px 30px; border-radius: 6px; font-size: 1rem; font-weight: 500; cursor: pointer; font-family: system-ui, sans-serif; margin-top: 10px; }
        .submit-btn:hover { background: #6d28d9; }
        .submit-status { margin-top: 15px; padding: 12px; border-radius: 5px; display: none; font-family: system-ui, sans-serif; font-size: 0.9rem; }
        .hp { position: absolute; left: -9999px; }
        
        .toc { background: #f8f7f5; padding: 30px 35px; margin: 0 0 50px; border-radius: 6px; }
        .toc-title { font-family: system-ui, sans-serif; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 2px; color: #888; margin-bottom: 15px; }
        .toc ol { margin: 0; padding-left: 20px; }
        .toc li { margin: 8px 0; }
        .toc a { color: #7c3aed; text-decoration: none; }
        .toc a:hover { text-decoration: underline; }
        
        @media (max-width: 600px) {
            .book { padding: 30px 20px; }
            .chapter-header h1 { font-size: 2rem; }
            h2 { font-size: 1.4rem; }
            .form-row { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <nav class="topbar">
        <span class="title">Data Structures &amp; Algorithms</span>
        <a href="index.html?home=true">‚Üê Course Home</a>
    </nav>
    
    <main class="book">
        <header class="chapter-header">
            <div class="chapter-num">Week Thirteen</div>
            <h1>Greedy Algorithms</h1>
            <p class="subtitle">Making locally optimal choices to find global solutions</p>
        </header>
        
        <nav class="toc">
            <div class="toc-title">Contents</div>
            <ol>
                <li><a href="#intro">Introduction to Greedy Algorithms</a></li>
                <li><a href="#vs-dp">Greedy vs Dynamic Programming</a></li>
                <li><a href="#activity">Activity Selection</a></li>
                <li><a href="#intervals">Interval Problems</a></li>
                <li><a href="#knapsack">Fractional Knapsack</a></li>
                <li><a href="#huffman">Huffman Coding</a></li>
                <li><a href="#mst">Minimum Spanning Trees</a></li>
                <li><a href="#dijkstra">Dijkstra's Shortest Path</a></li>
                <li><a href="#scheduling">Task Scheduling</a></li>
                <li><a href="#patterns">Common Patterns</a></li>
                <li><a href="#pitfalls">Common Pitfalls</a></li>
                <li><a href="#exercises">Exercises</a></li>
            </ol>
        </nav>

        <!-- ============================================== -->
        <!-- SECTION 1: INTRODUCTION TO GREEDY ALGORITHMS -->
        <!-- ============================================== -->
        <section id="intro">
            <h2>1. Introduction to Greedy Algorithms</h2>
            
            <p>Greedy algorithms build solutions piece by piece, always choosing the option that looks best at the moment. Unlike dynamic programming which considers all possibilities, greedy makes an irrevocable decision at each step. When applicable, greedy algorithms are typically simpler and more efficient than DP.</p>
            
            <div class="definition">
                <div class="definition-title">Definition</div>
                <p>A <span class="term">greedy algorithm</span> makes the locally optimal choice at each step, hoping this leads to a globally optimal solution. For greedy to work, the problem must exhibit <span class="term">greedy choice property</span> (local optimal leads to global optimal) and <span class="term">optimal substructure</span> (optimal solution contains optimal solutions to subproblems).</p>
            </div>
            
            <h3>When Does Greedy Work?</h3>
            
            <table>
                <tr>
                    <th>Property</th>
                    <th>Description</th>
                    <th>Example</th>
                </tr>
                <tr>
                    <td>Greedy Choice Property</td>
                    <td>Local best choice is part of global solution</td>
                    <td>Activity selection: earliest finish time</td>
                </tr>
                <tr>
                    <td>Optimal Substructure</td>
                    <td>Optimal solution built from optimal subproblems</td>
                    <td>MST: removing edge leaves smaller MST</td>
                </tr>
                <tr>
                    <td>No Overlapping Subproblems</td>
                    <td>Each choice independent of others</td>
                    <td>Coin change with standard denominations</td>
                </tr>
            </table>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.1 ‚Äî Greedy Coin Change (Standard Denominations)</span>
                    <button class="code-figure-run" onclick="runCode('code1')">‚ñ∂ Run</button>
                </div>
                <textarea id="code1" spellcheck="false">def coin_change_greedy(coins, amount):
    """
    Greedy coin change - works for standard denominations.
    Always pick largest coin that fits.
    """
    coins = sorted(coins, reverse=True)  # Largest first
    result = []
    remaining = amount
    
    for coin in coins:
        while remaining >= coin:
            result.append(coin)
            remaining -= coin
    
    if remaining == 0:
        return result
    return None  # Can't make exact change

# Standard US coins - greedy works!
coins = [25, 10, 5, 1]
amount = 63
result = coin_change_greedy(coins, amount)
print(f"Amount: {amount} cents")
print(f"Coins used: {result}")
print(f"Number of coins: {len(result)}")

# Greedy FAILS for non-standard denominations
coins = [1, 3, 4]
amount = 6
greedy_result = coin_change_greedy(coins, amount)
print(f"\nNon-standard coins {coins}, amount {amount}:")
print(f"Greedy: {greedy_result} ({len(greedy_result)} coins)")
print(f"Optimal: [3, 3] (2 coins) - Greedy fails!")</textarea>
                <div class="code-figure-output" id="outputcode1"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.1:</strong> Greedy works for standard coins but fails for arbitrary denominations.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 2: GREEDY VS DYNAMIC PROGRAMMING -->
        <!-- ============================================== -->
        <section id="vs-dp">
            <h2>2. Greedy vs Dynamic Programming</h2>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.2 ‚Äî Comparing Greedy and DP</span>
                    <button class="code-figure-run" onclick="runCode('code2')">‚ñ∂ Run</button>
                </div>
                <textarea id="code2" spellcheck="false"># Problem: Maximize value with weight constraint

def fractional_knapsack(items, capacity):
    """
    Greedy works for FRACTIONAL knapsack.
    Take items by value/weight ratio.
    """
    # Sort by value per weight (descending)
    items = sorted(items, key=lambda x: x[1]/x[0], reverse=True)
    
    total_value = 0
    remaining = capacity
    
    for weight, value in items:
        if remaining >= weight:
            total_value += value
            remaining -= weight
        else:
            # Take fraction
            total_value += value * (remaining / weight)
            break
    
    return total_value

def knapsack_01_dp(items, capacity):
    """
    DP required for 0/1 knapsack.
    Can't take fractions of items.
    """
    n = len(items)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        weight, value = items[i - 1]
        for w in range(capacity + 1):
            dp[i][w] = dp[i - 1][w]
            if weight <= w:
                dp[i][w] = max(dp[i][w], dp[i - 1][w - weight] + value)
    
    return dp[n][capacity]

# Test: (weight, value) pairs
items = [(10, 60), (20, 100), (30, 120)]
capacity = 50

print(f"Items (weight, value): {items}")
print(f"Capacity: {capacity}")
print(f"\nFractional Knapsack (Greedy): {fractional_knapsack(items, capacity)}")
print(f"0/1 Knapsack (DP): {knapsack_01_dp(items, capacity)}")</textarea>
                <div class="code-figure-output" id="outputcode2"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.2:</strong> Fractional knapsack allows greedy; 0/1 knapsack requires DP.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.3 ‚Äî When Greedy Fails: Optimal Path</span>
                    <button class="code-figure-run" onclick="runCode('code3')">‚ñ∂ Run</button>
                </div>
                <textarea id="code3" spellcheck="false"># Greedy fails for finding longest path in DAG

def greedy_path(graph, start, end):
    """Greedy: always go to neighbor with highest edge weight."""
    path = [start]
    total = 0
    current = start
    
    while current != end:
        neighbors = graph.get(current, {})
        if not neighbors:
            return None, 0
        # Greedy: pick highest weight edge
        next_node = max(neighbors, key=neighbors.get)
        total += neighbors[next_node]
        path.append(next_node)
        current = next_node
    
    return path, total

def dp_longest_path(graph, start, end):
    """DP: consider all paths."""
    from functools import lru_cache
    
    @lru_cache(maxsize=None)
    def longest(node):
        if node == end:
            return 0, [end]
        
        best_dist = float('-inf')
        best_path = None
        
        for neighbor, weight in graph.get(node, {}).items():
            dist, path = longest(neighbor)
            if dist + weight > best_dist:
                best_dist = dist + weight
                best_path = [node] + path
        
        return best_dist, best_path
    
    return longest(start)

# Graph where greedy fails
graph = {
    'A': {'B': 1, 'C': 100},
    'B': {'D': 1000},
    'C': {'D': 1}
}

print("Graph: A->B(1), A->C(100), B->D(1000), C->D(1)")
print(f"\nGreedy path A‚ÜíD: {greedy_path(graph, 'A', 'D')}")
print(f"Optimal path A‚ÜíD: {dp_longest_path(graph, 'A', 'D')}")
print("\nGreedy chose C because 100 > 1, but missed B‚ÜíD(1000)!")</textarea>
                <div class="code-figure-output" id="outputcode3"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.3:</strong> Greedy's local choice (100 > 1) misses the globally optimal path.
                </div>
            </div>
            
            <div class="important">
                <strong>Greedy vs DP Decision Guide:</strong><br>
                ‚Ä¢ Can partial solutions be extended? ‚Üí Try Greedy<br>
                ‚Ä¢ Need to consider all combinations? ‚Üí Use DP<br>
                ‚Ä¢ Local best always globally best? ‚Üí Greedy works<br>
                ‚Ä¢ Overlapping subproblems? ‚Üí DP with memoization
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 3: ACTIVITY SELECTION -->
        <!-- ============================================== -->
        <section id="activity">
            <h2>3. Activity Selection</h2>
            
            <div class="definition">
                <div class="definition-title">Definition</div>
                <p>The <span class="term">activity selection problem</span> asks: given activities with start and end times, select the maximum number of non-overlapping activities. The greedy approach is to always select the activity that finishes earliest.</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.4 ‚Äî Activity Selection (Maximum Activities)</span>
                    <button class="code-figure-run" onclick="runCode('code4')">‚ñ∂ Run</button>
                </div>
                <textarea id="code4" spellcheck="false">def activity_selection(activities):
    """
    Select maximum non-overlapping activities.
    Greedy: always pick activity that ends earliest.
    Time: O(n log n) for sorting
    """
    # Sort by end time
    activities = sorted(activities, key=lambda x: x[1])
    
    selected = [activities[0]]
    last_end = activities[0][1]
    
    for start, end in activities[1:]:
        if start >= last_end:  # No overlap
            selected.append((start, end))
            last_end = end
    
    return selected

# Test
activities = [(1, 4), (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10), (8, 11), (8, 12), (2, 14), (12, 16)]
print("Activities (start, end):")
for i, act in enumerate(activities):
    print(f"  {i}: {act}")

selected = activity_selection(activities)
print(f"\nSelected activities: {selected}")
print(f"Maximum count: {len(selected)}")</textarea>
                <div class="code-figure-output" id="outputcode4"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.4:</strong> Earliest finish time guarantees maximum activities.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.5 ‚Äî Why Earliest Finish Time Works</span>
                    <button class="code-figure-run" onclick="runCode('code5')">‚ñ∂ Run</button>
                </div>
                <textarea id="code5" spellcheck="false">def visualize_activity_selection(activities):
    """Visualize the greedy choice."""
    activities = sorted(activities, key=lambda x: x[1])
    
    print("Timeline (sorted by end time):")
    print("-" * 50)
    
    selected = []
    last_end = -1
    
    for i, (start, end) in enumerate(activities):
        timeline = ['.'] * 20
        for t in range(start, min(end, 20)):
            timeline[t] = '#'
        
        status = ""
        if start >= last_end:
            selected.append((start, end))
            last_end = end
            status = " ‚úì SELECTED"
        else:
            status = " ‚úó overlaps"
        
        print(f"{i}: {''.join(timeline)} ({start}-{end}){status}")
    
    print("-" * 50)
    print(f"Selected {len(selected)} activities")

activities = [(0, 3), (1, 4), (3, 5), (4, 7), (5, 8), (7, 10)]
visualize_activity_selection(activities)</textarea>
                <div class="code-figure-output" id="outputcode5"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.5:</strong> Each selection leaves maximum room for future activities.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 4: INTERVAL PROBLEMS -->
        <!-- ============================================== -->
        <section id="intervals">
            <h2>4. Interval Problems</h2>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.6 ‚Äî Merge Intervals</span>
                    <button class="code-figure-run" onclick="runCode('code6')">‚ñ∂ Run</button>
                </div>
                <textarea id="code6" spellcheck="false">def merge_intervals(intervals):
    """
    Merge overlapping intervals.
    Greedy: sort by start, extend or add new interval.
    """
    if not intervals:
        return []
    
    # Sort by start time
    intervals.sort(key=lambda x: x[0])
    
    merged = [intervals[0]]
    
    for start, end in intervals[1:]:
        if start <= merged[-1][1]:  # Overlapping
            merged[-1][1] = max(merged[-1][1], end)
        else:
            merged.append([start, end])
    
    return merged

# Test
intervals = [[1, 3], [2, 6], [8, 10], [15, 18]]
print(f"Original: {intervals}")
print(f"Merged:   {merge_intervals(intervals)}")

intervals = [[1, 4], [4, 5]]
print(f"\nOriginal: {intervals}")
print(f"Merged:   {merge_intervals(intervals)}")</textarea>
                <div class="code-figure-output" id="outputcode6"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.6:</strong> Sort by start, greedily extend current interval or start new one.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.7 ‚Äî Non-Overlapping Intervals (Minimum Removals)</span>
                    <button class="code-figure-run" onclick="runCode('code7')">‚ñ∂ Run</button>
                </div>
                <textarea id="code7" spellcheck="false">def erase_overlap_intervals(intervals):
    """
    Minimum intervals to remove for no overlap.
    Equivalent to: max non-overlapping = n - removals
    """
    if not intervals:
        return 0
    
    # Sort by end time (same as activity selection)
    intervals.sort(key=lambda x: x[1])
    
    count = 1  # Keep first interval
    last_end = intervals[0][1]
    
    for start, end in intervals[1:]:
        if start >= last_end:  # No overlap
            count += 1
            last_end = end
        # else: skip (remove) this interval
    
    return len(intervals) - count

# Test
intervals = [[1, 2], [2, 3], [3, 4], [1, 3]]
print(f"Intervals: {intervals}")
print(f"Remove {erase_overlap_intervals(intervals)} to eliminate overlaps")

intervals = [[1, 2], [1, 2], [1, 2]]
print(f"\nIntervals: {intervals}")
print(f"Remove {erase_overlap_intervals(intervals)} to eliminate overlaps")</textarea>
                <div class="code-figure-output" id="outputcode7"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.7:</strong> Minimum removals = total - maximum non-overlapping.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.8 ‚Äî Meeting Rooms II (Minimum Rooms)</span>
                    <button class="code-figure-run" onclick="runCode('code8')">‚ñ∂ Run</button>
                </div>
                <textarea id="code8" spellcheck="false">import heapq

def min_meeting_rooms(intervals):
    """
    Minimum conference rooms needed.
    Greedy with heap: track when rooms become free.
    """
    if not intervals:
        return 0
    
    # Sort by start time
    intervals.sort(key=lambda x: x[0])
    
    # Min-heap of end times (when rooms free up)
    rooms = []
    heapq.heappush(rooms, intervals[0][1])
    
    for start, end in intervals[1:]:
        # If earliest ending room is free
        if start >= rooms[0]:
            heapq.heappop(rooms)  # Reuse room
        
        heapq.heappush(rooms, end)
    
    return len(rooms)

# Alternative: sweep line algorithm
def min_meeting_rooms_sweep(intervals):
    """Sweep line: track concurrent meetings."""
    events = []
    for start, end in intervals:
        events.append((start, 1))   # Meeting starts
        events.append((end, -1))    # Meeting ends
    
    events.sort()
    
    max_rooms = current = 0
    for time, delta in events:
        current += delta
        max_rooms = max(max_rooms, current)
    
    return max_rooms

# Test
intervals = [[0, 30], [5, 10], [15, 20]]
print(f"Meetings: {intervals}")
print(f"Minimum rooms (heap): {min_meeting_rooms(intervals)}")
print(f"Minimum rooms (sweep): {min_meeting_rooms_sweep(intervals)}")</textarea>
                <div class="code-figure-output" id="outputcode8"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.8:</strong> Heap tracks room availability; sweep line counts concurrent events.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.9 ‚Äî Insert Interval</span>
                    <button class="code-figure-run" onclick="runCode('code9')">‚ñ∂ Run</button>
                </div>
                <textarea id="code9" spellcheck="false">def insert_interval(intervals, new_interval):
    """
    Insert new interval into sorted list, merge if needed.
    """
    result = []
    i = 0
    n = len(intervals)
    
    # Add all intervals that end before new one starts
    while i < n and intervals[i][1] < new_interval[0]:
        result.append(intervals[i])
        i += 1
    
    # Merge overlapping intervals
    while i < n and intervals[i][0] <= new_interval[1]:
        new_interval[0] = min(new_interval[0], intervals[i][0])
        new_interval[1] = max(new_interval[1], intervals[i][1])
        i += 1
    
    result.append(new_interval)
    
    # Add remaining intervals
    while i < n:
        result.append(intervals[i])
        i += 1
    
    return result

# Test
intervals = [[1, 3], [6, 9]]
new = [2, 5]
print(f"Intervals: {intervals}")
print(f"Insert: {new}")
print(f"Result: {insert_interval(intervals, new)}")

intervals = [[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]]
new = [4, 8]
print(f"\nIntervals: {intervals}")
print(f"Insert: {new}")
print(f"Result: {insert_interval(intervals, new)}")</textarea>
                <div class="code-figure-output" id="outputcode9"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.9:</strong> Three phases: add before, merge overlapping, add after.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 5: FRACTIONAL KNAPSACK -->
        <!-- ============================================== -->
        <section id="knapsack">
            <h2>5. Fractional Knapsack</h2>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.10 ‚Äî Fractional Knapsack</span>
                    <button class="code-figure-run" onclick="runCode('code10')">‚ñ∂ Run</button>
                </div>
                <textarea id="code10" spellcheck="false">def fractional_knapsack_detailed(items, capacity):
    """
    Fractional knapsack with detailed output.
    items: list of (weight, value) tuples
    """
    # Calculate value per unit weight
    items_with_ratio = []
    for i, (w, v) in enumerate(items):
        items_with_ratio.append((v / w, w, v, i))
    
    # Sort by ratio descending
    items_with_ratio.sort(reverse=True)
    
    total_value = 0
    remaining = capacity
    taken = []
    
    for ratio, weight, value, idx in items_with_ratio:
        if remaining >= weight:
            # Take entire item
            total_value += value
            taken.append((idx, 1.0, value))
            remaining -= weight
        elif remaining > 0:
            # Take fraction
            fraction = remaining / weight
            gained = value * fraction
            total_value += gained
            taken.append((idx, fraction, gained))
            remaining = 0
            break
    
    return total_value, taken

# Test
items = [(10, 60), (20, 100), (30, 120)]  # (weight, value)
capacity = 50

print(f"Items (weight, value):")
for i, (w, v) in enumerate(items):
    print(f"  {i}: weight={w}, value={v}, ratio={v/w:.2f}")

print(f"\nCapacity: {capacity}")
total, taken = fractional_knapsack_detailed(items, capacity)

print(f"\nTaken:")
for idx, frac, val in taken:
    print(f"  Item {idx}: {frac*100:.0f}% -> value {val:.2f}")
print(f"\nTotal value: {total}")</textarea>
                <div class="code-figure-output" id="outputcode10"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.10:</strong> Greedy by value/weight ratio gives optimal fractional solution.
                </div>
            </div>
            
            <div class="margin-note">
                <strong>Why greedy works for fractional knapsack:</strong> Taking the highest ratio item is always optimal because we can always take fractions. This doesn't work for 0/1 knapsack where items must be taken whole.
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.29 ‚Äî Fractional vs 0/1 Knapsack Comparison</span>
                    <button class="code-figure-run" onclick="runCode('code29')">‚ñ∂ Run</button>
                </div>
                <textarea id="code29" spellcheck="false"># Compare fractional (greedy) vs 0/1 (DP) knapsack

def fractional_knapsack(items, capacity):
    """Greedy: sort by value/weight ratio."""
    items = sorted(items, key=lambda x: x[1]/x[0], reverse=True)
    total = 0
    for weight, value in items:
        if capacity >= weight:
            total += value
            capacity -= weight
        else:
            total += value * (capacity / weight)
            break
    return total

def knapsack_01(items, capacity):
    """DP: consider all subsets."""
    n = len(items)
    dp = [0] * (capacity + 1)
    for w, v in items:
        for c in range(capacity, w - 1, -1):
            dp[c] = max(dp[c], dp[c - w] + v)
    return dp[capacity]

items = [(10, 60), (20, 100), (30, 120)]
capacity = 50

print(f"Items (weight, value): {items}")
print(f"Capacity: {capacity}")
print(f"\nFractional (Greedy): {fractional_knapsack(items, capacity)}")
print(f"0/1 (DP): {knapsack_01(items, capacity)}")
print("\nFractional can take 10 + 20 + 20/30 of item 3 = 60 + 100 + 80 = 240")
print("0/1 takes items 2 and 3 = 100 + 120 = 220")</textarea>
                <div class="code-figure-output" id="outputcode29"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.29:</strong> Fractional gets more value by taking partial items.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 6: HUFFMAN CODING -->
        <!-- ============================================== -->
        <section id="huffman">
            <h2>6. Huffman Coding</h2>
            
            <div class="definition">
                <div class="definition-title">Definition</div>
                <p><span class="term">Huffman coding</span> is a greedy algorithm for lossless data compression. It assigns shorter codes to more frequent characters, building an optimal prefix-free binary code. The greedy choice: always combine the two nodes with lowest frequency.</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.11 ‚Äî Huffman Tree Construction</span>
                    <button class="code-figure-run" onclick="runCode('code11')">‚ñ∂ Run</button>
                </div>
                <textarea id="code11" spellcheck="false">import heapq
from collections import Counter

class HuffmanNode:
    def __init__(self, char, freq):
        self.char = char
        self.freq = freq
        self.left = None
        self.right = None
    
    def __lt__(self, other):
        return self.freq < other.freq

def build_huffman_tree(text):
    """Build Huffman tree from text."""
    # Count frequencies
    freq = Counter(text)
    
    # Create leaf nodes and add to min-heap
    heap = [HuffmanNode(char, f) for char, f in freq.items()]
    heapq.heapify(heap)
    
    # Build tree by combining lowest frequency nodes
    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)
        
        internal = HuffmanNode(None, left.freq + right.freq)
        internal.left = left
        internal.right = right
        
        heapq.heappush(heap, internal)
    
    return heap[0]

def get_codes(root, code="", codes=None):
    """Extract codes from Huffman tree."""
    if codes is None:
        codes = {}
    
    if root.char is not None:
        codes[root.char] = code if code else "0"
        return codes
    
    get_codes(root.left, code + "0", codes)
    get_codes(root.right, code + "1", codes)
    return codes

# Test
text = "abracadabra"
print(f"Text: {text}")
print(f"Frequencies: {dict(Counter(text))}")

tree = build_huffman_tree(text)
codes = get_codes(tree)
print(f"\nHuffman codes:")
for char, code in sorted(codes.items()):
    print(f"  '{char}': {code}")

encoded = ''.join(codes[c] for c in text)
print(f"\nEncoded: {encoded}")
print(f"Original bits: {len(text) * 8}")
print(f"Encoded bits: {len(encoded)}")</textarea>
                <div class="code-figure-output" id="outputcode11"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.11:</strong> Frequent characters get shorter codes; 'a' appears most so gets shortest code.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.12 ‚Äî Huffman Encoding and Decoding</span>
                    <button class="code-figure-run" onclick="runCode('code12')">‚ñ∂ Run</button>
                </div>
                <textarea id="code12" spellcheck="false">import heapq
from collections import Counter

class HuffmanNode:
    def __init__(self, char, freq):
        self.char = char
        self.freq = freq
        self.left = None
        self.right = None
    def __lt__(self, other):
        return self.freq < other.freq

def huffman_encode(text):
    """Encode text using Huffman coding."""
    if len(set(text)) == 1:
        return "0" * len(text), {text[0]: "0"}
    
    freq = Counter(text)
    heap = [HuffmanNode(c, f) for c, f in freq.items()]
    heapq.heapify(heap)
    
    while len(heap) > 1:
        left, right = heapq.heappop(heap), heapq.heappop(heap)
        internal = HuffmanNode(None, left.freq + right.freq)
        internal.left, internal.right = left, right
        heapq.heappush(heap, internal)
    
    codes = {}
    def build_codes(node, code=""):
        if node.char:
            codes[node.char] = code
        else:
            build_codes(node.left, code + "0")
            build_codes(node.right, code + "1")
    build_codes(heap[0])
    
    encoded = ''.join(codes[c] for c in text)
    return encoded, codes

def huffman_decode(encoded, codes):
    """Decode Huffman encoded string."""
    reverse_codes = {v: k for k, v in codes.items()}
    
    decoded = []
    current = ""
    for bit in encoded:
        current += bit
        if current in reverse_codes:
            decoded.append(reverse_codes[current])
            current = ""
    
    return ''.join(decoded)

# Test
text = "hello world"
encoded, codes = huffman_encode(text)
decoded = huffman_decode(encoded, codes)

print(f"Original: '{text}'")
print(f"Codes: {codes}")
print(f"Encoded: {encoded}")
print(f"Decoded: '{decoded}'")
print(f"Match: {text == decoded}")</textarea>
                <div class="code-figure-output" id="outputcode12"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.12:</strong> Prefix-free codes allow unambiguous decoding.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 7: MINIMUM SPANNING TREES -->
        <!-- ============================================== -->
        <section id="mst">
            <h2>7. Minimum Spanning Trees</h2>
            
            <div class="definition">
                <div class="definition-title">Definition</div>
                <p>A <span class="term">Minimum Spanning Tree (MST)</span> connects all vertices in a weighted graph with minimum total edge weight. Two classic greedy algorithms: <span class="term">Kruskal's</span> (sort edges, add if no cycle) and <span class="term">Prim's</span> (grow tree from a vertex).</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.13 ‚Äî Kruskal's Algorithm with Union-Find</span>
                    <button class="code-figure-run" onclick="runCode('code13')">‚ñ∂ Run</button>
                </div>
                <textarea id="code13" spellcheck="false">class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False
        if self.rank[px] < self.rank[py]:
            px, py = py, px
        self.parent[py] = px
        if self.rank[px] == self.rank[py]:
            self.rank[px] += 1
        return True

def kruskal_mst(n, edges):
    """
    Kruskal's MST algorithm.
    edges: list of (weight, u, v)
    Greedy: sort edges, add smallest that doesn't create cycle.
    Time: O(E log E)
    """
    edges.sort()  # Sort by weight
    uf = UnionFind(n)
    
    mst = []
    total_weight = 0
    
    for weight, u, v in edges:
        if uf.union(u, v):  # No cycle
            mst.append((u, v, weight))
            total_weight += weight
            if len(mst) == n - 1:
                break
    
    return mst, total_weight

# Test
n = 4
edges = [
    (1, 0, 1), (2, 1, 2), (3, 0, 2),
    (4, 2, 3), (5, 1, 3), (6, 0, 3)
]
print(f"Vertices: {n}")
print(f"Edges (weight, u, v): {edges}")

mst, total = kruskal_mst(n, edges)
print(f"\nMST edges: {mst}")
print(f"Total weight: {total}")</textarea>
                <div class="code-figure-output" id="outputcode13"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.13:</strong> Kruskal's: greedily add smallest edge that doesn't create a cycle.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.14 ‚Äî Prim's Algorithm with Heap</span>
                    <button class="code-figure-run" onclick="runCode('code14')">‚ñ∂ Run</button>
                </div>
                <textarea id="code14" spellcheck="false">import heapq

def prim_mst(n, adj):
    """
    Prim's MST algorithm.
    adj: adjacency list with (neighbor, weight)
    Greedy: always add closest vertex to current tree.
    Time: O(E log V) with heap
    """
    visited = [False] * n
    mst = []
    total_weight = 0
    
    # Start from vertex 0: (weight, vertex, parent)
    heap = [(0, 0, -1)]
    
    while heap and len(mst) < n:
        weight, u, parent = heapq.heappop(heap)
        
        if visited[u]:
            continue
        
        visited[u] = True
        if parent != -1:
            mst.append((parent, u, weight))
            total_weight += weight
        
        for v, w in adj[u]:
            if not visited[v]:
                heapq.heappush(heap, (w, v, u))
    
    return mst, total_weight

# Test - same graph as Kruskal's
adj = {
    0: [(1, 1), (2, 3), (3, 6)],
    1: [(0, 1), (2, 2), (3, 5)],
    2: [(0, 3), (1, 2), (3, 4)],
    3: [(0, 6), (1, 5), (2, 4)]
}

mst, total = prim_mst(4, adj)
print(f"Prim's MST edges (parent, vertex, weight): {mst}")
print(f"Total weight: {total}")</textarea>
                <div class="code-figure-output" id="outputcode14"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.14:</strong> Prim's: grow tree by always adding the nearest unvisited vertex.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 8: DIJKSTRA'S SHORTEST PATH -->
        <!-- ============================================== -->
        <section id="dijkstra">
            <h2>8. Dijkstra's Shortest Path</h2>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.15 ‚Äî Dijkstra's Algorithm</span>
                    <button class="code-figure-run" onclick="runCode('code15')">‚ñ∂ Run</button>
                </div>
                <textarea id="code15" spellcheck="false">import heapq

def dijkstra(n, adj, start):
    """
    Dijkstra's shortest path from start to all vertices.
    Greedy: always process vertex with smallest known distance.
    Time: O((V + E) log V) with heap
    Only works with non-negative weights!
    """
    dist = [float('inf')] * n
    dist[start] = 0
    
    heap = [(0, start)]  # (distance, vertex)
    
    while heap:
        d, u = heapq.heappop(heap)
        
        if d > dist[u]:  # Already found better path
            continue
        
        for v, weight in adj[u]:
            if dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                heapq.heappush(heap, (dist[v], v))
    
    return dist

# Test
adj = {
    0: [(1, 4), (2, 1)],
    1: [(3, 1)],
    2: [(1, 2), (3, 5)],
    3: []
}

dist = dijkstra(4, adj, 0)
print("Graph:")
print("  0 --4--> 1 --1--> 3")
print("  |        ^        ^")
print("  1        2        5")
print("  v        |        |")
print("  2 -------+--------+")

print(f"\nShortest distances from 0:")
for v, d in enumerate(dist):
    print(f"  0 -> {v}: {d}")</textarea>
                <div class="code-figure-output" id="outputcode15"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.15:</strong> Dijkstra greedily processes vertices in order of distance.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.16 ‚Äî Dijkstra with Path Reconstruction</span>
                    <button class="code-figure-run" onclick="runCode('code16')">‚ñ∂ Run</button>
                </div>
                <textarea id="code16" spellcheck="false">import heapq

def dijkstra_with_path(n, adj, start, end):
    """Dijkstra's with path reconstruction."""
    dist = [float('inf')] * n
    dist[start] = 0
    parent = [-1] * n
    
    heap = [(0, start)]
    
    while heap:
        d, u = heapq.heappop(heap)
        
        if u == end:
            break
        
        if d > dist[u]:
            continue
        
        for v, weight in adj[u]:
            if dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                parent[v] = u
                heapq.heappush(heap, (dist[v], v))
    
    # Reconstruct path
    if dist[end] == float('inf'):
        return None, float('inf')
    
    path = []
    current = end
    while current != -1:
        path.append(current)
        current = parent[current]
    
    return path[::-1], dist[end]

# Test
adj = {
    0: [(1, 4), (2, 1)],
    1: [(3, 1)],
    2: [(1, 2), (3, 5)],
    3: []
}

path, dist = dijkstra_with_path(4, adj, 0, 3)
print(f"Shortest path 0 -> 3: {path}")
print(f"Distance: {dist}")</textarea>
                <div class="code-figure-output" id="outputcode16"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.16:</strong> Track parent pointers to reconstruct the actual shortest path.
                </div>
            </div>
            
            <div class="important">
                <strong>Dijkstra's Limitations:</strong><br>
                ‚Ä¢ Only works with non-negative edge weights<br>
                ‚Ä¢ For negative weights, use Bellman-Ford (O(VE))<br>
                ‚Ä¢ For negative cycles, no shortest path exists
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 9: TASK SCHEDULING -->
        <!-- ============================================== -->
        <section id="scheduling">
            <h2>9. Task Scheduling</h2>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.17 ‚Äî Job Scheduling with Deadlines</span>
                    <button class="code-figure-run" onclick="runCode('code17')">‚ñ∂ Run</button>
                </div>
                <textarea id="code17" spellcheck="false">def job_sequencing(jobs):
    """
    Maximize profit by scheduling jobs before their deadlines.
    Each job takes 1 time unit.
    jobs: list of (job_id, deadline, profit)
    """
    # Sort by profit descending
    jobs = sorted(jobs, key=lambda x: x[2], reverse=True)
    
    max_deadline = max(job[1] for job in jobs)
    slots = [None] * max_deadline
    
    total_profit = 0
    scheduled = []
    
    for job_id, deadline, profit in jobs:
        # Find latest available slot before deadline
        for slot in range(min(deadline, max_deadline) - 1, -1, -1):
            if slots[slot] is None:
                slots[slot] = job_id
                total_profit += profit
                scheduled.append((job_id, slot + 1, profit))
                break
    
    return scheduled, total_profit

# Test
jobs = [
    ('a', 2, 100),
    ('b', 1, 19),
    ('c', 2, 27),
    ('d', 1, 25),
    ('e', 3, 15)
]

print("Jobs (id, deadline, profit):")
for job in jobs:
    print(f"  {job}")

scheduled, profit = job_sequencing(jobs)
print(f"\nScheduled jobs:")
for job_id, slot, p in scheduled:
    print(f"  Job '{job_id}' in slot {slot}, profit {p}")
print(f"\nTotal profit: {profit}")</textarea>
                <div class="code-figure-output" id="outputcode17"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.17:</strong> Schedule highest profit jobs first, as late as possible before deadline.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.18 ‚Äî Minimum Platforms (Train Station)</span>
                    <button class="code-figure-run" onclick="runCode('code18')">‚ñ∂ Run</button>
                </div>
                <textarea id="code18" spellcheck="false">def min_platforms(arrivals, departures):
    """
    Minimum platforms needed at a train station.
    Similar to meeting rooms problem.
    """
    events = []
    for arr in arrivals:
        events.append((arr, 1))   # Arrival
    for dep in departures:
        events.append((dep, -1))  # Departure
    
    events.sort()
    
    max_platforms = current = 0
    for time, delta in events:
        current += delta
        max_platforms = max(max_platforms, current)
    
    return max_platforms

# Test
arrivals = [900, 940, 950, 1100, 1500, 1800]
departures = [910, 1200, 1120, 1130, 1900, 2000]

print(f"Train arrivals:   {arrivals}")
print(f"Train departures: {departures}")
print(f"Minimum platforms needed: {min_platforms(arrivals, departures)}")</textarea>
                <div class="code-figure-output" id="outputcode18"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.18:</strong> Sweep line tracks concurrent trains at any moment.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.19 ‚Äî Task Scheduler with Cooldown</span>
                    <button class="code-figure-run" onclick="runCode('code19')">‚ñ∂ Run</button>
                </div>
                <textarea id="code19" spellcheck="false">from collections import Counter

def least_interval(tasks, n):
    """
    Minimum time to complete all tasks with cooldown n between same tasks.
    Greedy: always schedule most frequent task.
    """
    freq = Counter(tasks)
    max_freq = max(freq.values())
    
    # Count tasks with max frequency
    max_count = sum(1 for f in freq.values() if f == max_freq)
    
    # Formula: (max_freq - 1) * (n + 1) + max_count
    # This is the minimum slots needed for the most frequent tasks
    formula_result = (max_freq - 1) * (n + 1) + max_count
    
    # But can't be less than total tasks
    return max(formula_result, len(tasks))

# Test
tasks = ['A', 'A', 'A', 'B', 'B', 'B']
n = 2
print(f"Tasks: {tasks}")
print(f"Cooldown: {n}")
print(f"Minimum intervals: {least_interval(tasks, n)}")
# A -> B -> idle -> A -> B -> idle -> A -> B

tasks = ['A', 'A', 'A', 'B', 'B', 'B']
n = 0
print(f"\nTasks: {tasks}")
print(f"Cooldown: {n}")
print(f"Minimum intervals: {least_interval(tasks, n)}")</textarea>
                <div class="code-figure-output" id="outputcode19"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.19:</strong> Most frequent task determines minimum time; fill idle slots with others.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 10: COMMON PATTERNS -->
        <!-- ============================================== -->
        <section id="patterns">
            <h2>10. Common Patterns</h2>
            
            <h3>Pattern 1: Jump Game</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.20 ‚Äî Jump Game</span>
                    <button class="code-figure-run" onclick="runCode('code20')">‚ñ∂ Run</button>
                </div>
                <textarea id="code20" spellcheck="false">def can_jump(nums):
    """
    Can we reach the last index?
    Greedy: track farthest reachable position.
    """
    max_reach = 0
    
    for i, jump in enumerate(nums):
        if i > max_reach:
            return False
        max_reach = max(max_reach, i + jump)
        if max_reach >= len(nums) - 1:
            return True
    
    return True

def min_jumps(nums):
    """
    Minimum jumps to reach last index.
    Greedy: BFS-like level traversal.
    """
    if len(nums) <= 1:
        return 0
    
    jumps = 0
    current_end = 0
    farthest = 0
    
    for i in range(len(nums) - 1):
        farthest = max(farthest, i + nums[i])
        
        if i == current_end:
            jumps += 1
            current_end = farthest
            
            if current_end >= len(nums) - 1:
                break
    
    return jumps

# Test
nums = [2, 3, 1, 1, 4]
print(f"Array: {nums}")
print(f"Can reach end: {can_jump(nums)}")
print(f"Minimum jumps: {min_jumps(nums)}")

nums = [3, 2, 1, 0, 4]
print(f"\nArray: {nums}")
print(f"Can reach end: {can_jump(nums)}")</textarea>
                <div class="code-figure-output" id="outputcode20"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.20:</strong> Track reachable range; expand greedily when hitting boundary.
                </div>
            </div>
            
            <h3>Pattern 2: Gas Station</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.21 ‚Äî Gas Station Circuit</span>
                    <button class="code-figure-run" onclick="runCode('code21')">‚ñ∂ Run</button>
                </div>
                <textarea id="code21" spellcheck="false">def can_complete_circuit(gas, cost):
    """
    Find starting station to complete circuit.
    Greedy: if we can't reach station i from start,
    start must be after i.
    """
    total_tank = 0
    current_tank = 0
    start = 0
    
    for i in range(len(gas)):
        diff = gas[i] - cost[i]
        total_tank += diff
        current_tank += diff
        
        if current_tank < 0:
            # Can't reach station i+1 from start
            # New start must be after i
            start = i + 1
            current_tank = 0
    
    return start if total_tank >= 0 else -1

# Test
gas = [1, 2, 3, 4, 5]
cost = [3, 4, 5, 1, 2]
print(f"Gas:  {gas}")
print(f"Cost: {cost}")
print(f"Start from station: {can_complete_circuit(gas, cost)}")

gas = [2, 3, 4]
cost = [3, 4, 3]
print(f"\nGas:  {gas}")
print(f"Cost: {cost}")
print(f"Start from station: {can_complete_circuit(gas, cost)}")</textarea>
                <div class="code-figure-output" id="outputcode21"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.21:</strong> If total gas >= total cost, solution exists; find valid starting point.
                </div>
            </div>
            
            <h3>Pattern 3: Candy Distribution</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.22 ‚Äî Candy Distribution</span>
                    <button class="code-figure-run" onclick="runCode('code22')">‚ñ∂ Run</button>
                </div>
                <textarea id="code22" spellcheck="false">def candy(ratings):
    """
    Distribute candies: higher rating gets more than neighbors.
    Two-pass greedy: left to right, then right to left.
    """
    n = len(ratings)
    candies = [1] * n
    
    # Left to right: handle ascending sequences
    for i in range(1, n):
        if ratings[i] > ratings[i - 1]:
            candies[i] = candies[i - 1] + 1
    
    # Right to left: handle descending sequences
    for i in range(n - 2, -1, -1):
        if ratings[i] > ratings[i + 1]:
            candies[i] = max(candies[i], candies[i + 1] + 1)
    
    return sum(candies), candies

# Test
ratings = [1, 0, 2]
total, dist = candy(ratings)
print(f"Ratings: {ratings}")
print(f"Candies: {dist}")
print(f"Total: {total}")

ratings = [1, 2, 2]
total, dist = candy(ratings)
print(f"\nRatings: {ratings}")
print(f"Candies: {dist}")
print(f"Total: {total}")</textarea>
                <div class="code-figure-output" id="outputcode22"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.22:</strong> Two passes handle both increasing and decreasing sequences.
                </div>
            </div>
            
            <h3>Pattern 4: Partition Labels</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.23 ‚Äî Partition Labels</span>
                    <button class="code-figure-run" onclick="runCode('code23')">‚ñ∂ Run</button>
                </div>
                <textarea id="code23" spellcheck="false">def partition_labels(s):
    """
    Partition string so each letter appears in at most one part.
    Greedy: extend partition until all letters in it have ended.
    """
    # Find last occurrence of each character
    last = {c: i for i, c in enumerate(s)}
    
    partitions = []
    start = end = 0
    
    for i, c in enumerate(s):
        end = max(end, last[c])  # Extend if needed
        
        if i == end:  # All chars in partition have ended
            partitions.append(end - start + 1)
            start = i + 1
    
    return partitions

# Test
s = "ababcbacadefegdehijhklij"
print(f"String: {s}")
result = partition_labels(s)
print(f"Partition sizes: {result}")

# Show partitions
idx = 0
parts = []
for size in result:
    parts.append(s[idx:idx + size])
    idx += size
print(f"Partitions: {parts}")</textarea>
                <div class="code-figure-output" id="outputcode23"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.23:</strong> Track last occurrence; partition when current position equals max end.
                </div>
            </div>
            
            <h3>Pattern 5: Best Time to Buy and Sell Stock II</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.30 ‚Äî Stock Profit (Multiple Transactions)</span>
                    <button class="code-figure-run" onclick="runCode('code30')">‚ñ∂ Run</button>
                </div>
                <textarea id="code30" spellcheck="false">def max_profit_multiple(prices):
    """
    Maximum profit with unlimited buy/sell transactions.
    Greedy: collect every upward price movement.
    """
    profit = 0
    for i in range(1, len(prices)):
        if prices[i] > prices[i - 1]:
            profit += prices[i] - prices[i - 1]
    return profit

# Test
prices = [7, 1, 5, 3, 6, 4]
print(f"Prices: {prices}")
print(f"Max profit: {max_profit_multiple(prices)}")
# Buy at 1, sell at 5 (profit 4)
# Buy at 3, sell at 6 (profit 3)
# Total: 7

prices = [1, 2, 3, 4, 5]
print(f"\nPrices: {prices}")
print(f"Max profit: {max_profit_multiple(prices)}")
# Buy at 1, sell at 5 = profit 4 (or collect each +1)</textarea>
                <div class="code-figure-output" id="outputcode30"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.30:</strong> Greedy collects every positive price difference.
                </div>
            </div>
            
            <h3>Pattern 6: Remove K Digits</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.31 ‚Äî Remove K Digits for Smallest Number</span>
                    <button class="code-figure-run" onclick="runCode('code31')">‚ñ∂ Run</button>
                </div>
                <textarea id="code31" spellcheck="false">def remove_k_digits(num, k):
    """
    Remove k digits to get smallest possible number.
    Greedy: remove digit if next digit is smaller (using stack).
    """
    stack = []
    
    for digit in num:
        while k > 0 and stack and stack[-1] > digit:
            stack.pop()
            k -= 1
        stack.append(digit)
    
    # Remove remaining k digits from end
    stack = stack[:-k] if k else stack
    
    # Remove leading zeros
    result = ''.join(stack).lstrip('0')
    return result or '0'

# Test
num = "1432219"
k = 3
print(f"Number: {num}, remove {k} digits")
print(f"Result: {remove_k_digits(num, k)}")  # 1219

num = "10200"
k = 1
print(f"\nNumber: {num}, remove {k} digit")
print(f"Result: {remove_k_digits(num, k)}")  # 200</textarea>
                <div class="code-figure-output" id="outputcode31"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.31:</strong> Monotonic stack removes larger digits when smaller digit follows.
                </div>
            </div>
            
            <h3>Pattern 7: Maximum Number of Events</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.32 ‚Äî Maximum Events Attended</span>
                    <button class="code-figure-run" onclick="runCode('code32')">‚ñ∂ Run</button>
                </div>
                <textarea id="code32" spellcheck="false">import heapq

def max_events(events):
    """
    Maximum events you can attend (one event per day).
    Greedy: each day, attend event ending soonest.
    """
    events = sorted(events)
    heap = []  # End days of available events
    day = 0
    count = 0
    i = 0
    n = len(events)
    
    while i < n or heap:
        if not heap:
            day = events[i][0]
        
        # Add all events starting today or earlier
        while i < n and events[i][0] <= day:
            heapq.heappush(heap, events[i][1])
            i += 1
        
        # Remove expired events
        while heap and heap[0] < day:
            heapq.heappop(heap)
        
        # Attend event ending soonest
        if heap:
            heapq.heappop(heap)
            count += 1
        
        day += 1
    
    return count

# Test
events = [[1, 2], [2, 3], [3, 4]]
print(f"Events: {events}")
print(f"Max events: {max_events(events)}")  # 3

events = [[1, 2], [2, 3], [3, 4], [1, 2]]
print(f"\nEvents: {events}")
print(f"Max events: {max_events(events)}")  # 4</textarea>
                <div class="code-figure-output" id="outputcode32"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.32:</strong> Use heap to always attend event ending soonest.
                </div>
            </div>
            
            <h3>Pattern 8: Reorganize String</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.33 ‚Äî Reorganize String (No Adjacent Same)</span>
                    <button class="code-figure-run" onclick="runCode('code33')">‚ñ∂ Run</button>
                </div>
                <textarea id="code33" spellcheck="false">import heapq
from collections import Counter

def reorganize_string(s):
    """
    Rearrange so no two adjacent chars are same.
    Greedy: always place most frequent char not just used.
    """
    freq = Counter(s)
    
    # Check if possible
    max_freq = max(freq.values())
    if max_freq > (len(s) + 1) // 2:
        return ""
    
    # Max heap of (-count, char)
    heap = [(-count, char) for char, count in freq.items()]
    heapq.heapify(heap)
    
    result = []
    prev_count, prev_char = 0, ''
    
    while heap:
        count, char = heapq.heappop(heap)
        result.append(char)
        
        # Put previous char back if it has remaining count
        if prev_count < 0:
            heapq.heappush(heap, (prev_count, prev_char))
        
        prev_count, prev_char = count + 1, char
    
    return ''.join(result)

# Test
s = "aab"
print(f"String: {s}")
print(f"Reorganized: {reorganize_string(s)}")

s = "aaab"
print(f"\nString: {s}")
print(f"Reorganized: '{reorganize_string(s)}' (impossible)")</textarea>
                <div class="code-figure-output" id="outputcode33"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.33:</strong> Alternate between most frequent characters using heap.
                </div>
            </div>
            
            <div class="summary">
                <div class="summary-title">Key Takeaways</div>
                <ul>
                    <li><strong>Greedy choice property:</strong> Local optimal leads to global optimal</li>
                    <li><strong>Activity selection:</strong> Sort by end time, pick non-overlapping</li>
                    <li><strong>Interval problems:</strong> Sort by start or end depending on goal</li>
                    <li><strong>MST:</strong> Kruskal's (edges) or Prim's (vertices)</li>
                    <li><strong>Shortest path:</strong> Dijkstra's for non-negative weights</li>
                    <li><strong>Proof technique:</strong> Exchange argument shows greedy is optimal</li>
                </ul>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 11: PITFALLS -->
        <!-- ============================================== -->
        <section id="pitfalls">
            <h2>11. Common Pitfalls</h2>
            
            <h3>Pitfall 1: Greedy Doesn't Always Work</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.24 ‚Äî When Greedy Fails</span>
                    <button class="code-figure-run" onclick="runCode('code24')">‚ñ∂ Run</button>
                </div>
                <textarea id="code24" spellcheck="false"># 0/1 Knapsack: Greedy by ratio fails

def greedy_knapsack_01(items, capacity):
    """WRONG: Greedy approach for 0/1 knapsack."""
    items = sorted(items, key=lambda x: x[1]/x[0], reverse=True)
    
    total = 0
    remaining = capacity
    for weight, value in items:
        if weight <= remaining:
            total += value
            remaining -= weight
    return total

def dp_knapsack_01(items, capacity):
    """CORRECT: DP approach."""
    n = len(items)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        w, v = items[i - 1]
        for c in range(capacity + 1):
            dp[i][c] = dp[i - 1][c]
            if w <= c:
                dp[i][c] = max(dp[i][c], dp[i - 1][c - w] + v)
    
    return dp[n][capacity]

# Counter-example where greedy fails
items = [(10, 60), (20, 100), (30, 120)]  # (weight, value)
capacity = 50

print("Items (weight, value):")
for w, v in items:
    print(f"  weight={w}, value={v}, ratio={v/w:.2f}")

print(f"\nCapacity: {capacity}")
print(f"Greedy result: {greedy_knapsack_01(items, capacity)}")
print(f"DP result: {dp_knapsack_01(items, capacity)}")
print("\nGreedy takes items 0+1 (value 160)")
print("Optimal takes items 1+2 (value 220)")</textarea>
                <div class="code-figure-output" id="outputcode24"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.24:</strong> 0/1 knapsack requires considering combinations‚Äîgreedy misses better options.
                </div>
            </div>
            
            <h3>Pitfall 2: Wrong Sorting Criteria</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.25 ‚Äî Correct Sorting Matters</span>
                    <button class="code-figure-run" onclick="runCode('code25')">‚ñ∂ Run</button>
                </div>
                <textarea id="code25" spellcheck="false"># Activity selection: which sorting is correct?

activities = [(1, 4), (3, 5), (0, 6), (5, 7), (3, 9), (5, 9), (6, 10)]

def by_start_time(activities):
    """WRONG: Sort by start time."""
    activities = sorted(activities, key=lambda x: x[0])
    selected = [activities[0]]
    for start, end in activities[1:]:
        if start >= selected[-1][1]:
            selected.append((start, end))
    return selected

def by_end_time(activities):
    """CORRECT: Sort by end time."""
    activities = sorted(activities, key=lambda x: x[1])
    selected = [activities[0]]
    for start, end in activities[1:]:
        if start >= selected[-1][1]:
            selected.append((start, end))
    return selected

def by_duration(activities):
    """WRONG: Sort by duration."""
    activities = sorted(activities, key=lambda x: x[1] - x[0])
    selected = [activities[0]]
    for start, end in activities[1:]:
        if start >= selected[-1][1]:
            selected.append((start, end))
    return selected

print(f"Activities: {activities}")
print(f"\nBy start time: {len(by_start_time(activities))} activities")
print(f"By end time:   {len(by_end_time(activities))} activities (CORRECT)")
print(f"By duration:   {len(by_duration(activities))} activities")</textarea>
                <div class="code-figure-output" id="outputcode25"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.25:</strong> Different sorting criteria give different results‚Äîonly end time is optimal.
                </div>
            </div>
            
            <h3>Pitfall 3: Forgetting Edge Cases</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.26 ‚Äî Handle Edge Cases</span>
                    <button class="code-figure-run" onclick="runCode('code26')">‚ñ∂ Run</button>
                </div>
                <textarea id="code26" spellcheck="false">def jump_game_robust(nums):
    """Jump game with edge case handling."""
    if not nums:
        return False
    if len(nums) == 1:
        return True  # Already at end
    
    max_reach = 0
    for i in range(len(nums)):
        if i > max_reach:
            return False
        max_reach = max(max_reach, i + nums[i])
        if max_reach >= len(nums) - 1:
            return True
    
    return False

# Edge cases
test_cases = [
    [],           # Empty
    [0],          # Single element, zero jump
    [1],          # Single element, can jump
    [0, 1],       # Stuck at start
    [1, 0, 1],    # Middle zero
]

for nums in test_cases:
    print(f"nums = {nums}: {jump_game_robust(nums)}")</textarea>
                <div class="code-figure-output" id="outputcode26"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.26:</strong> Always handle empty, single element, and boundary cases.
                </div>
            </div>
            
            <h3>Pitfall 4: Negative Weights in Dijkstra</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.27 ‚Äî Dijkstra Fails with Negative Weights</span>
                    <button class="code-figure-run" onclick="runCode('code27')">‚ñ∂ Run</button>
                </div>
                <textarea id="code27" spellcheck="false">import heapq

def dijkstra(adj, start, n):
    dist = [float('inf')] * n
    dist[start] = 0
    heap = [(0, start)]
    
    while heap:
        d, u = heapq.heappop(heap)
        if d > dist[u]:
            continue
        for v, w in adj.get(u, []):
            if dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                heapq.heappush(heap, (dist[v], v))
    return dist

# Graph with negative edge
adj = {
    0: [(1, 1), (2, 5)],
    1: [(2, -3)],  # Negative edge!
    2: []
}

print("Graph with negative edge:")
print("  0 --1--> 1 ---(-3)---> 2")
print("  0 --5--> 2")
print(f"\nDijkstra distances: {dijkstra(adj, 0, 3)}")
print("Correct: 0->1->2 = 1 + (-3) = -2")
print("\nDijkstra may give wrong answer with negative weights!")
print("Use Bellman-Ford instead for negative weights.")</textarea>
                <div class="code-figure-output" id="outputcode27"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.27:</strong> Dijkstra's greedy assumption breaks with negative edges.
                </div>
            </div>
            
            <h3>Pitfall 5: Not Proving Greedy Works</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 13.28 ‚Äî Exchange Argument Proof</span>
                    <button class="code-figure-run" onclick="runCode('code28')">‚ñ∂ Run</button>
                </div>
                <textarea id="code28" spellcheck="false">"""
Exchange Argument for Activity Selection:

Claim: Always picking earliest-finish activity is optimal.

Proof:
1. Let G = greedy solution, O = any optimal solution
2. Let g1 be first activity in G (earliest finish)
3. Let o1 be first activity in O

Case: g1 finishes no later than o1
- Replace o1 with g1 in O
- Still valid (g1 finishes earlier, so same or more room for remaining)
- Still optimal (same number of activities)
- Now G and O have same first activity

4. Repeat argument for remaining activities
5. Eventually, G = O

This is called the "exchange argument" - we can exchange
any optimal solution to match greedy without losing optimality.
"""

print("Exchange Argument proves greedy is optimal:")
print()
print("1. Suppose greedy picks activity A that ends at time t")
print("2. Any other first choice B ends at time >= t")
print("3. Replacing B with A leaves MORE room for remaining activities")
print("4. So greedy choice is NEVER worse than any alternative")
print("5. Therefore greedy is optimal")
print()
print("ALWAYS prove greedy works before using it!")</textarea>
                <div class="code-figure-output" id="outputcode28"></div>
                <div class="code-figure-caption">
                    <strong>Figure 13.28:</strong> Exchange argument: show greedy can replace any optimal solution.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 12: EXERCISES -->
        <!-- ============================================== -->
        <section id="exercises">
            <h2>12. Exercises</h2>
            
            <!-- Exercise 1 -->
            <div class="exercise" data-exercise="ex1">
                <div class="exercise-title">Exercise 1: Maximum Units on a Truck</div>
                <p class="exercise-description">You can load boxes onto a truck with capacity truckSize. Given boxTypes where boxTypes[i] = [numberOfBoxes, unitsPerBox], return maximum units you can load.</p>
                <p class="answer">(Expected: [[1,3],[2,2],[3,1]], truckSize=4 ‚Üí 8)</p>
                
                <div class="hint-section">
                    <button class="hint-toggle" onclick="toggleHint('ex1', 1)">üí° Hint 1</button>
                    <button class="hint-toggle" onclick="toggleHint('ex1', 2)">üí° Hint 2</button>
                    <button class="hint-toggle" onclick="toggleHint('ex1', 3)">üí° Hint 3</button>
                    
                    
                    <div class="hint-content" id="ex1-hint1">
                        <strong>Hint 1 - Greedy Choice:</strong><br>
                        Load boxes with most units per box first (higher value per space).
                    </div>
                    <div class="hint-content" id="ex1-hint2">
                        <strong>Hint 2 - Sort:</strong><br>
                        Sort by unitsPerBox in descending order.
                    </div>
                    <div class="hint-content" id="ex1-hint3">
                        <strong>Hint 3 - Load:</strong><br>
                        Take min(available boxes, remaining capacity) of each type.
                    </div>
                    </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 1 ‚Äî Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex1')">‚ñ∂ Run</button>
                </div>
                <textarea id="ex1" spellcheck="false"># Maximum Units on a Truck - Greedy

def maximum_units(box_types, truck_size):
    # Your code here
    pass

# Test your implementation (uncomment)
# box_types = [[1,3],[2,2],[3,1]]
# print(maximum_units(box_types, 4))  # 8</textarea>
                <div class="code-figure-output" id="outputex1"></div>
            </div>
            
            <!-- Exercise 2 -->
            <div class="exercise" data-exercise="ex2">
                <div class="exercise-title">Exercise 2: Boats to Save People</div>
                <p class="exercise-description">Given people's weights and boat limit (max 2 people per boat), find minimum boats needed.</p>
                <p class="answer">(Expected: [3,2,2,1], limit=3 ‚Üí 3 boats)</p>
                
                <div class="hint-section">
                    <button class="hint-toggle" onclick="toggleHint('ex2', 1)">üí° Hint 1</button>
                    <button class="hint-toggle" onclick="toggleHint('ex2', 2)">üí° Hint 2</button>
                    <button class="hint-toggle" onclick="toggleHint('ex2', 3)">üí° Hint 3</button>
                    
                    
                    <div class="hint-content" id="ex2-hint1">
                        <strong>Hint 1 - Sort:</strong><br>
                        Sort people by weight to enable optimal pairing.
                    </div>
                    <div class="hint-content" id="ex2-hint2">
                        <strong>Hint 2 - Two Pointers:</strong><br>
                        Try to pair lightest (left) with heaviest (right).
                    </div>
                    <div class="hint-content" id="ex2-hint3">
                        <strong>Hint 3 - Logic:</strong><br>
                        If they fit together, both go. Otherwise heaviest goes alone.
                    </div>
                    </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 2 ‚Äî Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex2')">‚ñ∂ Run</button>
                </div>
                <textarea id="ex2" spellcheck="false"># Boats to Save People - Two Pointers

def num_rescue_boats(people, limit):
    # Your code here
    pass

# Test your implementation (uncomment)
# print(num_rescue_boats([3, 2, 2, 1], 3))  # 3
# print(num_rescue_boats([3, 5, 3, 4], 5))  # 4</textarea>
                <div class="code-figure-output" id="outputex2"></div>
            </div>
            
            <!-- Exercise 3 -->
            <div class="exercise" data-exercise="ex3">
                <div class="exercise-title">Exercise 3: Assign Cookies</div>
                <p class="exercise-description">Given greed factors g[i] and cookie sizes s[j], assign cookies to maximize content children. A child is content if cookie size >= greed factor.</p>
                <p class="answer">(Expected: g=[1,2,3], s=[1,1] ‚Üí 1 child content)</p>
                
                <div class="hint-section">
                    <button class="hint-toggle" onclick="toggleHint('ex3', 1)">üí° Hint 1</button>
                    <button class="hint-toggle" onclick="toggleHint('ex3', 2)">üí° Hint 2</button>
                    <button class="hint-toggle" onclick="toggleHint('ex3', 3)">üí° Hint 3</button>
                    
                    
                    <div class="hint-content" id="ex3-hint1">
                        <strong>Hint 1 - Sort Both:</strong><br>
                        Sort children by greed and cookies by size.
                    </div>
                    <div class="hint-content" id="ex3-hint2">
                        <strong>Hint 2 - Greedy Match:</strong><br>
                        Give smallest sufficient cookie to least greedy child.
                    </div>
                    <div class="hint-content" id="ex3-hint3">
                        <strong>Hint 3 - Two Pointers:</strong><br>
                        If cookie satisfies child, move both. Else, try next cookie.
                    </div>
                    </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 3 ‚Äî Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex3')">‚ñ∂ Run</button>
                </div>
                <textarea id="ex3" spellcheck="false"># Assign Cookies - Greedy Matching

def find_content_children(g, s):
    # Your code here
    pass

# Test your implementation (uncomment)
# print(find_content_children([1, 2, 3], [1, 1]))  # 1
# print(find_content_children([1, 2], [1, 2, 3]))  # 2</textarea>
                <div class="code-figure-output" id="outputex3"></div>
            </div>
            
            <!-- Exercise 4 -->
            <div class="exercise" data-exercise="ex4">
                <div class="exercise-title">Exercise 4: Queue Reconstruction by Height</div>
                <p class="exercise-description">People described by [h, k] where h is height and k is number of taller people in front. Reconstruct the queue.</p>
                <p class="answer">(Expected: Reconstruct based on height and k value)</p>
                
                <div class="hint-section">
                    <button class="hint-toggle" onclick="toggleHint('ex4', 1)">üí° Hint 1</button>
                    <button class="hint-toggle" onclick="toggleHint('ex4', 2)">üí° Hint 2</button>
                    <button class="hint-toggle" onclick="toggleHint('ex4', 3)">üí° Hint 3</button>
                    
                    
                    <div class="hint-content" id="ex4-hint1">
                        <strong>Hint 1 - Sort Order:</strong><br>
                        Sort by height descending, then by k ascending.
                    </div>
                    <div class="hint-content" id="ex4-hint2">
                        <strong>Hint 2 - Insertion Logic:</strong><br>
                        Tallest first don't see shorter people, so insert at index k.
                    </div>
                    <div class="hint-content" id="ex4-hint3">
                        <strong>Hint 3 - Build Queue:</strong><br>
                        Insert each person at position k in the result list.
                    </div>
                    </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 4 ‚Äî Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex4')">‚ñ∂ Run</button>
                </div>
                <textarea id="ex4" spellcheck="false"># Queue Reconstruction by Height

def reconstruct_queue(people):
    # Your code here
    pass

# Test your implementation (uncomment)
# people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
# print(reconstruct_queue(people))
# [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</textarea>
                <div class="code-figure-output" id="outputex4"></div>
            </div>
            
            <!-- Exercise 5 -->
            <div class="exercise" data-exercise="ex5">
                <div class="exercise-title">Exercise 5: Minimum Number of Arrows</div>
                <p class="exercise-description">Given balloons as [start, end] intervals on x-axis, find minimum arrows needed to burst all balloons. One arrow at x bursts all balloons where start ‚â§ x ‚â§ end.</p>
                <p class="answer">(Expected: [[10,16],[2,8],[1,6],[7,12]] ‚Üí 2 arrows)</p>
                
                <div class="hint-section">
                    <button class="hint-toggle" onclick="toggleHint('ex5', 1)">üí° Hint 1</button>
                    <button class="hint-toggle" onclick="toggleHint('ex5', 2)">üí° Hint 2</button>
                    <button class="hint-toggle" onclick="toggleHint('ex5', 3)">üí° Hint 3</button>
                    
                    
                    <div class="hint-content" id="ex5-hint1">
                        <strong>Hint 1 - Sort by End:</strong><br>
                        Sort balloons by end point (like activity selection).
                    </div>
                    <div class="hint-content" id="ex5-hint2">
                        <strong>Hint 2 - Shoot Strategy:</strong><br>
                        Shoot arrow at end of first balloon to maximize overlap.
                    </div>
                    <div class="hint-content" id="ex5-hint3">
                        <strong>Hint 3 - Skip Overlapping:</strong><br>
                        Skip all balloons whose start <= current arrow position.
                    </div>
                    </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 5 ‚Äî Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex5')">‚ñ∂ Run</button>
                </div>
                <textarea id="ex5" spellcheck="false"># Minimum Number of Arrows - Interval Greedy

def find_min_arrow_shots(points):
    # Your code here
    pass

# Test your implementation (uncomment)
# points = [[10,16],[2,8],[1,6],[7,12]]
# print(find_min_arrow_shots(points))  # 2</textarea>
                <div class="code-figure-output" id="outputex5"></div>
            </div>
        </section>

        <!-- SUBMIT SECTION -->
        <section class="submit-section">
            <h2>Submit Your Work</h2>
            <p>After completing the exercises, submit your attendance below.</p>
            
            <div class="form-row">
                <div class="form-group">
                    <label>Student ID</label>
                    <input type="text" id="studentId" placeholder="Enter your student ID">
                </div>
                <div class="form-group">
                    <label>Full Name</label>
                    <input type="text" id="studentName" placeholder="Enter your full name">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>Email (@istun.edu.tr)</label>
                    <input type="email" id="studentEmail" placeholder="your.email@istun.edu.tr">
                </div>
                <div class="form-group">
                    <label>Class Code</label>
                    <input type="text" id="classCode" placeholder="From instructor">
                </div>
            </div>
            <input type="text" id="hp" class="hp" tabindex="-1" autocomplete="off">
            <button class="submit-btn" onclick="submitWork()">Submit Attendance</button>
            <div class="submit-status" id="submitStatus"></div>
        </section>
    </main>

    <script>
        const pageLoadTime = Date.now();
        
        // ============ HINT SYSTEM ============
        function toggleHint(exerciseId, hintNum) {
            const hintId = exerciseId + '-hint' + hintNum;
            const hintEl = document.getElementById(hintId);
            const btn = event.target;
            if (hintEl.classList.contains('show')) {
                hintEl.classList.remove('show');
                btn.classList.remove('revealed');
            } else {
                hintEl.classList.add('show');
                btn.classList.add('revealed');
            }
        }
        
        // ============ ANTI-CHEAT SYSTEM ============
        const originalExerciseCode = {};
        const keystrokeCounts = {};
        const pasteAttempts = {};
        
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('textarea[id^="ex"]').forEach(textarea => {
                const exId = textarea.id;
                originalExerciseCode[exId] = textarea.value;
                keystrokeCounts[exId] = 0;
                pasteAttempts[exId] = 0;
                
                textarea.addEventListener('paste', function(e) {
                    e.preventDefault();
                    pasteAttempts[exId]++;
                    const warning = document.createElement('div');
                    warning.textContent = '‚ö†Ô∏è Paste is disabled. Please type your code.';
                    warning.className = 'paste-warning';
                    const existingWarning = textarea.parentElement.querySelector('.paste-warning');
                    if (existingWarning) existingWarning.remove();
                    textarea.parentElement.appendChild(warning);
                    setTimeout(() => warning.remove(), 3000);
                });
                textarea.addEventListener('drop', function(e) { e.preventDefault(); });
                textarea.addEventListener('keydown', function(e) {
                    if (e.key.length === 1 || ['Backspace', 'Delete', 'Enter', 'Tab'].includes(e.key)) {
                        keystrokeCounts[exId]++;
                    }
                });
            });
        });
        
        function isCodeModified(exId, currentCode) {
            const original = originalExerciseCode[exId] || '';
            const keystrokes = keystrokeCounts[exId] || 0;
            const normalizedOriginal = original.trim().replace(/\s+/g, ' ');
            const normalizedCurrent = currentCode.trim().replace(/\s+/g, ' ');
            if (normalizedOriginal === normalizedCurrent) return false;
            if (keystrokes < 20) return false;
            const withoutComments = currentCode.replace(/#.*$/gm, '').replace(/"""[\s\S]*?"""/g, '').replace(/'''[\s\S]*?'''/g, '').trim();
            const originalWithoutComments = original.replace(/#.*$/gm, '').replace(/"""[\s\S]*?"""/g, '').replace(/'''[\s\S]*?'''/g, '').trim();
            if (withoutComments.length <= originalWithoutComments.length + 10) return false;
            return true;
        }
        
        // ============ PYODIDE CODE RUNNER ============
        async function runCode(codeId) {
            const codeEl = document.getElementById(codeId);
            const outputEl = document.getElementById('output' + codeId);
            const code = codeEl.value;
            outputEl.classList.add('show');
            outputEl.textContent = 'Loading Python...';
            
            try {
                if (!window.pyodideReady) {
                    if (typeof loadPyodide === 'undefined') {
                        const script = document.createElement('script');
                        script.src = 'https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js';
                        document.head.appendChild(script);
                        await new Promise((resolve, reject) => {
                            script.onload = resolve;
                            script.onerror = reject;
                            setTimeout(reject, 10000);
                        });
                    }
                    outputEl.textContent = 'Initializing Python (first run may take a moment)...';
                    window.pyodide = await loadPyodide();
                    window.pyodideReady = true;
                }
                outputEl.textContent = 'Running...';
                window.pyodide.runPython(`
import sys
from io import StringIO
sys.stdout = StringIO()
`);
                try {
                    window.pyodide.runPython(code);
                } catch (pyErr) {
                    outputEl.textContent = 'Error: ' + pyErr.message;
                    return;
                }
                const output = window.pyodide.runPython('sys.stdout.getvalue()');
                outputEl.textContent = output || '(no output)';
            } catch(e) {
                outputEl.textContent = 'Error: ' + e.message;
            }
        }
        
        // ============ VALIDATION ============
        function validateStudentId(id) {
            if (id.length < 6 || id.length > 10) return false;
            if (!/^\d+$/.test(id)) return false;
            if (/^(\d)\1+$/.test(id)) return false;
            return true;
        }
        function validateName(name) {
            if (name.length < 5) return false;
            const words = name.trim().split(/\s+/);
            if (words.length < 2) return false;
            if (!/^[A-Za-zƒü√º≈üƒ±√∂√ßƒû√ú≈ûƒ∞√ñ√á\s]+$/.test(name)) return false;
            const blockedWords = ['test', 'fake', 'asdf', 'qwer', 'spam', 'admin', 'null', 'undefined', 'xxx', 'abc', 'aaa', 'deneme', '√∂rnek'];
            const nameLower = name.toLowerCase();
            for (const word of blockedWords) { if (nameLower.includes(word)) return false; }
            return true;
        }
        function validateEmail(email) {
            return email.endsWith('@istun.edu.tr') && email.length > 15;
        }
        
        // ============ SUBMIT ============
        async function submitWork() {
            const status = document.getElementById('submitStatus');
            status.style.display = 'none';
            const studentId = document.getElementById('studentId').value.trim();
            const studentName = document.getElementById('studentName').value.trim();
            const studentEmail = document.getElementById('studentEmail').value.trim().toLowerCase();
            const classCode = document.getElementById('classCode').value.trim().toUpperCase();
            const honeypot = document.getElementById('hp').value;
            
            if (honeypot) { status.textContent = '‚ùå Submission rejected.'; status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5'; return; }
            const timeOnPage = Math.floor((Date.now() - pageLoadTime) / 1000);
            if (timeOnPage < 60) { status.textContent = '‚ùå Please spend more time reviewing the material.'; status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5'; return; }
            if (!studentId || !studentName || !studentEmail || !classCode) { status.textContent = '‚ùå All fields are required.'; status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5'; return; }
            if (!validateStudentId(studentId)) { status.textContent = '‚ùå Invalid Student ID (must be 6-10 digits).'; status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5'; return; }
            if (!validateName(studentName)) { status.textContent = '‚ùå Please use your real information.'; status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5'; return; }
            if (!validateEmail(studentEmail)) { status.textContent = '‚ùå Use your @istun.edu.tr email.'; status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5'; return; }
            
            status.textContent = '‚è≥ Collecting answers and submitting...';
            status.style.cssText = 'display:block;background:rgba(124,58,237,0.2);color:#a78bfa';
            
            const answers = {};
            document.querySelectorAll('.exercise[data-exercise]').forEach(exercise => {
                const exId = exercise.getAttribute('data-exercise');
                const titleEl = exercise.querySelector('.exercise-title');
                const descEl = exercise.querySelector('.exercise-description');
                const codeEl = document.getElementById(exId);
                if (codeEl) {
                    const code = codeEl.value || '';
                    answers[exId] = {
                        title: titleEl ? titleEl.textContent.replace(/^Exercise \d+:\s*/, '').trim() : 'Exercise',
                        description: descEl ? descEl.textContent.trim() : '',
                        code: code,
                        modified: isCodeModified(exId, code),
                        keystrokes: keystrokeCounts[exId] || 0,
                        pasteAttempts: pasteAttempts[exId] || 0
                    };
                }
            });
            
            let ipAddress = 'Unknown', location = 'Unknown';
            try {
                const ipResponse = await fetch('https://ipapi.co/json/', { timeout: 5000 });
                if (ipResponse.ok) {
                    const ipData = await ipResponse.json();
                    ipAddress = ipData.ip || 'Unknown';
                    location = (ipData.city && ipData.country_name) ? `${ipData.city}, ${ipData.country_name}` : (ipData.country_name || 'Unknown');
                }
            } catch (e) { console.log('Could not fetch IP info'); }
            
            const data = { week: 'Week_13', studentId, studentName, studentEmail, classCode, timeOnPage, answers, ipAddress, location, source: 'dsa-web' };
            const scriptUrl = 'https://script.google.com/macros/s/AKfycbxepk2NvNg3Whad-WOPxdZI-mWnVJeNKCsZVspvk7Ku5YHC_oWv7376VrWLn_30nyI_vw/exec';
            
            fetch(scriptUrl, { method: 'POST', mode: 'cors', cache: 'no-cache', headers: { 'Content-Type': 'text/plain' }, body: JSON.stringify(data) })
            .then(response => response.json())
            .then(res => {
                if (res.success) { status.textContent = '‚úÖ Submitted successfully! Check your email for confirmation.'; status.style.cssText = 'display:block;background:rgba(74,222,128,0.2);color:#4ade80'; }
                else { status.textContent = '‚ùå ' + (res.message || 'Submission failed.'); status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5'; }
            })
            .catch(error => {
                fetch(scriptUrl, { method: 'POST', mode: 'no-cors', cache: 'no-cache', headers: { 'Content-Type': 'text/plain' }, body: JSON.stringify(data) })
                .then(() => { status.textContent = '‚è≥ Request sent. Check your email.'; status.style.cssText = 'display:block;background:rgba(251,191,36,0.2);color:#fbbf24'; })
                .catch(() => { status.textContent = '‚ùå Connection error.'; status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5'; });
            });
        }
    </script>
</body>
</html>
