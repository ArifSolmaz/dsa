<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 04: Linked Lists | DSA Course</title>
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Crimson Pro', Georgia, serif;
            font-size: 19px;
            background: #faf9f7;
            color: #2c2c2c; 
            line-height: 1.8;
        }
        
        .topbar {
            position: sticky;
            top: 0;
            background: #1a1a2e;
            color: white;
            padding: 12px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }
        .topbar .title { font-family: system-ui, sans-serif; font-size: 0.9rem; font-weight: 500; }
        .topbar a { font-family: system-ui, sans-serif; color: white; text-decoration: none; font-size: 0.85rem; padding: 6px 14px; background: rgba(255,255,255,0.1); border-radius: 5px; }
        .topbar a:hover { background: rgba(255,255,255,0.2); }
        
        .book { max-width: 750px; margin: 0 auto; padding: 60px 40px 100px; }
        
        .chapter-header { text-align: center; padding: 50px 0 60px; border-bottom: 1px solid #ddd; margin-bottom: 50px; }
        .chapter-num { font-family: system-ui, sans-serif; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 3px; color: #7c3aed; margin-bottom: 15px; }
        .chapter-header h1 { font-size: 2.8rem; font-weight: 600; color: #1a1a2e; margin-bottom: 15px; letter-spacing: -0.5px; }
        .chapter-header .subtitle { font-style: italic; color: #666; font-size: 1.1rem; }
        
        h2 { font-size: 1.6rem; font-weight: 600; color: #1a1a2e; margin: 60px 0 25px; padding-top: 30px; border-top: 1px solid #e5e5e5; }
        h2:first-of-type { border-top: none; margin-top: 0; padding-top: 0; }
        h3 { font-size: 1.25rem; font-weight: 600; color: #333; margin: 40px 0 15px; }
        h4 { font-size: 1.05rem; font-weight: 600; color: #555; margin: 30px 0 12px; }
        
        p { margin: 0 0 20px; text-align: justify; hyphens: auto; }
        ul, ol { margin: 20px 0 25px 30px; }
        li { margin: 10px 0; }
        
        code { font-family: 'JetBrains Mono', monospace; font-size: 0.85em; background: #f0eeeb; padding: 2px 6px; border-radius: 3px; color: #7c3aed; }
        .term { font-weight: 600; color: #1a1a2e; }
        
        .definition { background: #f8f7f5; border-left: 4px solid #7c3aed; padding: 20px 25px; margin: 30px 0; }
        .definition-title { font-family: system-ui, sans-serif; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px; color: #7c3aed; margin-bottom: 8px; font-weight: 600; }
        .definition p { margin: 0; }
        
        .margin-note { background: #fffbeb; border: 1px solid #fcd34d; padding: 15px 18px; margin: 25px 0; border-radius: 4px; font-size: 0.9rem; }
        .margin-note::before { content: "üí° "; }
        
        .important { background: #fef2f2; border: 1px solid #fca5a5; padding: 15px 18px; margin: 25px 0; border-radius: 4px; font-size: 0.9rem; }
        .important::before { content: "‚ö†Ô∏è "; }
        
        .example { background: #fafafa; border: 1px solid #e5e5e5; border-radius: 6px; padding: 25px; margin: 30px 0; }
        .example-title { font-family: system-ui, sans-serif; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: #666; margin-bottom: 15px; font-weight: 600; }
        
        .code-figure { margin: 35px 0; border: 1px solid #e0e0e0; border-radius: 6px; overflow: hidden; background: #1e1e2e; }
        .code-figure-header { background: #28283c; padding: 10px 18px; display: flex; justify-content: space-between; align-items: center; }
        .code-figure-label { font-family: system-ui, sans-serif; font-size: 0.75rem; color: #a0a0b0; text-transform: uppercase; letter-spacing: 0.5px; }
        .code-figure-run { font-family: system-ui, sans-serif; background: #7c3aed; color: white; border: none; padding: 5px 14px; border-radius: 4px; font-size: 0.8rem; cursor: pointer; font-weight: 500; }
        .code-figure-run:hover { background: #6d28d9; }
        .code-figure textarea { width: 100%; min-height: 100px; padding: 18px; background: #1e1e2e; color: #e0e0e0; border: none; font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; line-height: 1.6; resize: vertical; }
        .code-figure textarea:focus { outline: none; }
        .code-figure-output { display: none; border-top: 1px solid #28283c; padding: 15px 18px; background: #161622; color: #4ade80; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; white-space: pre-wrap; }
        .code-figure-output.show { display: block; }
        .code-figure-caption { background: #f8f8f8; padding: 12px 18px; font-size: 0.85rem; color: #666; border-top: 1px solid #e0e0e0; }
        .code-figure-caption strong { color: #333; }
        
        .summary { background: linear-gradient(135deg, #7c3aed10, #7c3aed05); border: 1px solid #7c3aed30; border-radius: 8px; padding: 25px 30px; margin: 40px 0; }
        .summary-title { font-family: system-ui, sans-serif; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: #7c3aed; margin-bottom: 12px; font-weight: 600; }
        .summary ul { margin: 0; }
        
        .exercise { background: #f0fdf4; border: 1px solid #bbf7d0; border-radius: 8px; padding: 25px 30px; margin: 40px 0 20px; }
        .exercise-title { font-family: system-ui, sans-serif; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: #16a34a; margin-bottom: 12px; font-weight: 600; }
        .exercise p { margin: 0; }
        .exercise .answer { margin-top: 12px; font-size: 0.9rem; color: #166534; }
        
        table { width: 100%; border-collapse: collapse; margin: 25px 0; font-size: 0.95rem; }
        th, td { border: 1px solid #ddd; padding: 12px 15px; text-align: left; }
        th { background: #f5f5f5; font-weight: 600; }
        
        .submit-section { background: #1a1a2e; color: white; padding: 40px; border-radius: 10px; margin-top: 60px; }
        .submit-section h2 { color: white; border: none; margin: 0 0 20px; padding: 0; font-size: 1.4rem; }
        .submit-section p { color: #a0a0b0; text-align: left; }
        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .form-group { margin-bottom: 15px; }
        .form-group label { display: block; font-family: system-ui, sans-serif; font-size: 0.85rem; color: #a0a0b0; margin-bottom: 6px; }
        .form-group input { width: 100%; padding: 12px 14px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 5px; color: white; font-size: 1rem; font-family: system-ui, sans-serif; }
        .form-group input:focus { outline: none; border-color: #7c3aed; }
        .submit-btn { background: #7c3aed; color: white; border: none; padding: 14px 30px; border-radius: 6px; font-size: 1rem; font-weight: 500; cursor: pointer; font-family: system-ui, sans-serif; margin-top: 10px; }
        .submit-btn:hover { background: #6d28d9; }
        .submit-status { margin-top: 15px; padding: 12px; border-radius: 5px; display: none; font-family: system-ui, sans-serif; font-size: 0.9rem; }
        .hp { position: absolute; left: -9999px; }
        
        .toc { background: #f8f7f5; padding: 30px 35px; margin: 0 0 50px; border-radius: 6px; }
        .toc-title { font-family: system-ui, sans-serif; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 2px; color: #888; margin-bottom: 15px; }
        .toc ol { margin: 0; padding-left: 20px; }
        .toc li { margin: 8px 0; }
        .toc a { color: #7c3aed; text-decoration: none; }
        .toc a:hover { text-decoration: underline; }
        
        @media (max-width: 600px) {
            .book { padding: 30px 20px; }
            .chapter-header h1 { font-size: 2rem; }
            h2 { font-size: 1.4rem; }
            .form-row { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <nav class="topbar">
        <span class="title">Data Structures &amp; Algorithms</span>
        <a href="index.html">‚Üê Course Home</a>
    </nav>
    
    <main class="book">
        <header class="chapter-header">
            <div class="chapter-num">Week Four</div>
            <h1>Linked Lists</h1>
            <p class="subtitle">Dynamic data structures with pointer-based connections</p>
        </header>
        
        <nav class="toc">
            <div class="toc-title">Contents</div>
            <ol>
                <li><a href="#intro">Why Linked Lists?</a></li>
                <li><a href="#nodes">Nodes: The Building Block</a></li>
                <li><a href="#singly">Singly Linked Lists</a></li>
                <li><a href="#operations">Basic Operations</a></li>
                <li><a href="#complexity">Complexity Analysis</a></li>
                <li><a href="#doubly">Doubly Linked Lists</a></li>
                <li><a href="#circular">Circular Linked Lists</a></li>
                <li><a href="#patterns">Common Patterns &amp; Techniques</a></li>
                <li><a href="#problems">Classic Problems</a></li>
                <li><a href="#pitfalls">Common Pitfalls</a></li>
                <li><a href="#exercises">Exercises</a></li>
            </ol>
        </nav>

        <!-- ============================================== -->
        <!-- SECTION 1: WHY LINKED LISTS? -->
        <!-- ============================================== -->
        <section id="intro">
            <h2>1. Why Linked Lists?</h2>
            
            <p>In the previous week, we learned about arrays and their O(1) random access. Arrays are powerful, but they have a significant limitation: inserting or deleting elements in the middle requires shifting all subsequent elements‚Äîan O(n) operation. <span class="term">Linked lists</span> solve this problem by trading random access for efficient insertions and deletions.</p>
            
            <div class="definition">
                <div class="definition-title">Definition</div>
                <p>A <span class="term">linked list</span> is a linear data structure where elements are stored in nodes, and each node contains a reference (pointer) to the next node in the sequence. Unlike arrays, linked list elements are not stored in contiguous memory locations.</p>
            </div>
            
            <h3>The Problem with Arrays</h3>
            
            <div class="example">
                <div class="example-title">Array Insertion Problem</div>
                <p>Consider inserting an element at the beginning of an array with 1 million elements:</p>
                <pre style="font-family: 'JetBrains Mono', monospace; font-size: 0.85rem;">
Before: [A, B, C, D, E, ...]  (1 million elements)
Insert X at position 0

Step 1: Shift E right    [A, B, C, D, _, E, ...]
Step 2: Shift D right    [A, B, C, _, D, E, ...]
Step 3: Shift C right    [A, B, _, C, D, E, ...]
...
Step 999,999: Shift A    [_, A, B, C, D, E, ...]
Step 1,000,000: Insert X [X, A, B, C, D, E, ...]

‚Üí 1 million operations just to insert one element!
                </pre>
            </div>
            
            <p>With a linked list, inserting at the beginning takes only O(1) time‚Äîwe simply create a new node and update one pointer. No shifting required.</p>
            
            <h3>Array vs Linked List: Trade-offs</h3>
            
            <table>
                <tr>
                    <th>Operation</th>
                    <th>Array</th>
                    <th>Linked List</th>
                </tr>
                <tr>
                    <td>Access by index</td>
                    <td>O(1)</td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td>Insert at beginning</td>
                    <td>O(n)</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Insert at end</td>
                    <td>O(1)*</td>
                    <td>O(n) or O(1)**</td>
                </tr>
                <tr>
                    <td>Insert in middle</td>
                    <td>O(n)</td>
                    <td>O(1)***</td>
                </tr>
                <tr>
                    <td>Delete at beginning</td>
                    <td>O(n)</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Search</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td>Memory</td>
                    <td>Compact</td>
                    <td>Extra pointer overhead</td>
                </tr>
            </table>
            
            <p><em>* Amortized for dynamic arrays. ** O(1) with tail pointer. *** Once you have a reference to the position.</em></p>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.1 ‚Äî Demonstrating the Trade-off</span>
                    <button class="code-figure-run" onclick="runCode('code1')">‚ñ∂ Run</button>
                </div>
                <textarea id="code1" spellcheck="false">import time

# Simulate the difference: insert at beginning
n = 10000

# Array (Python list): Insert at beginning is O(n)
arr = list(range(n))
start = time.perf_counter()
for i in range(100):
    arr.insert(0, -1)  # Insert at beginning
array_time = time.perf_counter() - start

# Linked list simulation: Insert at beginning is O(1)
# We'll use a collections.deque which has O(1) left operations
from collections import deque
linked = deque(range(n))
start = time.perf_counter()
for i in range(100):
    linked.appendleft(-1)  # Insert at beginning
linked_time = time.perf_counter() - start

print(f"Insert 100 elements at beginning (n={n}):")
print(f"  Array (list.insert): {array_time*1000:.2f} ms")
print(f"  Linked (deque):      {linked_time*1000:.2f} ms")
print(f"  Speedup: {array_time/linked_time:.1f}x")</textarea>
                <div class="code-figure-output" id="outputcode1"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.1:</strong> Inserting at the beginning shows the linked list advantage. The speedup grows with n.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.2 ‚Äî When to Use Each</span>
                    <button class="code-figure-run" onclick="runCode('code1a')">‚ñ∂ Run</button>
                </div>
                <textarea id="code1a" spellcheck="false"># Decision guide: Array vs Linked List

def demonstrate_use_cases():
    """Show when each data structure excels."""
    
    print("USE ARRAY (list) WHEN:")
    print("  - Frequent random access by index")
    print("  - Known or fixed size")
    print("  - Memory efficiency matters")
    print("  - Cache locality important (iteration)")
    
    print("\nUSE LINKED LIST WHEN:")
    print("  - Frequent insertions/deletions at front")
    print("  - Unknown size that changes often")
    print("  - Memory allocation in small chunks preferred")
    print("  - No random access needed")
    
    print("\n" + "="*50)
    print("PRACTICAL EXAMPLES:")
    print("="*50)
    
    print("\nArray: Store student grades, access by ID")
    grades = [85, 90, 78, 92, 88]  # O(1) access
    print(f"  grades[2] = {grades[2]}")
    
    print("\nLinked List: Undo history (add/remove at ends)")
    from collections import deque
    history = deque()
    history.append("action1")  # O(1)
    history.append("action2")  # O(1)
    print(f"  Undo: {history.pop()}")  # O(1) from end

demonstrate_use_cases()</textarea>
                <div class="code-figure-output" id="outputcode1a"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.2:</strong> Choose arrays for random access; linked lists for frequent head/tail operations.
                </div>
            </div>
            
            <div class="margin-note">
                Python's <code>collections.deque</code> is implemented as a doubly-linked list. It provides O(1) operations at both ends, making it ideal when you need to insert/remove at either end frequently.
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 2: NODES -->
        <!-- ============================================== -->
        <section id="nodes">
            <h2>2. Nodes: The Building Block</h2>
            
            <p>Every linked list is built from <span class="term">nodes</span>. A node is a simple container that holds two things: the data value and a reference to the next node.</p>
            
            <div class="definition">
                <div class="definition-title">Definition</div>
                <p>A <span class="term">node</span> is the fundamental unit of a linked list. It contains: (1) a <span class="term">data</span> field storing the actual value, and (2) a <span class="term">next</span> field storing a reference (pointer) to the next node in the list, or <code>None</code> if it's the last node.</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.2 ‚Äî The Node Class</span>
                    <button class="code-figure-run" onclick="runCode('code2')">‚ñ∂ Run</button>
                </div>
                <textarea id="code2" spellcheck="false"># The Node class - building block of linked lists
class Node:
    """A node in a singly linked list."""
    
    def __init__(self, data):
        self.data = data    # The value stored in this node
        self.next = None    # Reference to the next node (initially None)
    
    def __repr__(self):
        return f"Node({self.data})"

# Create some nodes
node1 = Node(10)
node2 = Node(20)
node3 = Node(30)

print(f"node1: {node1}, next = {node1.next}")
print(f"node2: {node2}, next = {node2.next}")
print(f"node3: {node3}, next = {node3.next}")

# Link them together: 10 -> 20 -> 30
node1.next = node2
node2.next = node3

print("\nAfter linking:")
print(f"node1.next = {node1.next}")
print(f"node2.next = {node2.next}")
print(f"node3.next = {node3.next}")

# Traverse the chain
print("\nTraversal:")
current = node1
while current:
    print(f"  {current.data}", end=" -> " if current.next else "\n")
    current = current.next</textarea>
                <div class="code-figure-output" id="outputcode2"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.2:</strong> Nodes are linked by setting each node's <code>next</code> to reference the following node.
                </div>
            </div>
            
            <h3>Understanding References</h3>
            
            <p>In Python, variables hold <em>references</em> to objects, not the objects themselves. When we write <code>node1.next = node2</code>, we're storing a reference to <code>node2</code> inside <code>node1</code>. Both <code>node1.next</code> and <code>node2</code> point to the same object in memory.</p>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.3 ‚Äî References and Identity</span>
                    <button class="code-figure-run" onclick="runCode('code3')">‚ñ∂ Run</button>
                </div>
                <textarea id="code3" spellcheck="false"># Understanding references in linked lists
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

# Create nodes
a = Node("A")
b = Node("B")

# Link them
a.next = b

# a.next and b refer to the SAME object
print(f"a.next is b: {a.next is b}")
print(f"id(a.next): {id(a.next)}")
print(f"id(b):      {id(b)}")

# Modifying through one reference affects the other
a.next.data = "B-modified"
print(f"\nAfter a.next.data = 'B-modified':")
print(f"  b.data = '{b.data}'")  # Also changed!

# This is why linked lists work - nodes "know" each other through references</textarea>
                <div class="code-figure-output" id="outputcode3"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.3:</strong> References allow nodes to form chains. Changes through one reference affect the same object.
                </div>
            </div>
            
            <h3>Visualizing a Linked List</h3>
            
            <div class="example">
                <div class="example-title">Linked List Visualization</div>
                <pre style="font-family: 'JetBrains Mono', monospace; font-size: 0.85rem;">
head
  ‚îÇ
  ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ data: 1 ‚îÇ    ‚îÇ data: 2 ‚îÇ    ‚îÇ data: 3 ‚îÇ    ‚îÇ data: 4 ‚îÇ
‚îÇ next: ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ next: ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ next: ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ next: ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚ñ∫ None
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
   Node 0        Node 1         Node 2         Node 3

Memory addresses are NOT contiguous:
  Node 0 at 0x7f001234
  Node 1 at 0x7f009876  (could be anywhere!)
  Node 2 at 0x7f002468
  Node 3 at 0x7f008642
                </pre>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 3: SINGLY LINKED LISTS -->
        <!-- ============================================== -->
        <section id="singly">
            <h2>3. Singly Linked Lists</h2>
            
            <p>A <span class="term">singly linked list</span> is the simplest form of linked list, where each node has only one link‚Äîto the next node. The list maintains a reference to the first node, called the <span class="term">head</span>.</p>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.4 ‚Äî Basic LinkedList Class</span>
                    <button class="code-figure-run" onclick="runCode('code4')">‚ñ∂ Run</button>
                </div>
                <textarea id="code4" spellcheck="false"># Complete Singly Linked List implementation
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    """A singly linked list."""
    
    def __init__(self):
        self.head = None
        self._size = 0
    
    def __len__(self):
        return self._size
    
    def is_empty(self):
        return self.head is None
    
    def __str__(self):
        """String representation: [1 -> 2 -> 3]"""
        if self.is_empty():
            return "[]"
        
        result = []
        current = self.head
        while current:
            result.append(str(current.data))
            current = current.next
        return "[" + " -> ".join(result) + "]"
    
    def __iter__(self):
        """Allow iteration: for item in linked_list"""
        current = self.head
        while current:
            yield current.data
            current = current.next

# Test
ll = LinkedList()
print(f"Empty list: {ll}")
print(f"Length: {len(ll)}")
print(f"Is empty: {ll.is_empty()}")</textarea>
                <div class="code-figure-output" id="outputcode4"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.4:</strong> The LinkedList class maintains a head pointer and size counter.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.5 ‚Äî LinkedList with Tail Pointer</span>
                    <button class="code-figure-run" onclick="runCode('code4a')">‚ñ∂ Run</button>
                </div>
                <textarea id="code4a" spellcheck="false"># LinkedList with tail pointer for O(1) append
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedListWithTail:
    """Singly linked list with both head and tail pointers."""
    
    def __init__(self):
        self.head = None
        self.tail = None
        self._size = 0
    
    def __len__(self):
        return self._size
    
    def __str__(self):
        if not self.head:
            return "[]"
        parts = []
        curr = self.head
        while curr:
            parts.append(str(curr.data))
            curr = curr.next
        return "[" + " -> ".join(parts) + "]"
    
    def append(self, data):
        """O(1) append with tail pointer!"""
        new_node = Node(data)
        self._size += 1
        
        if not self.head:
            self.head = self.tail = new_node
            return
        
        self.tail.next = new_node
        self.tail = new_node
    
    def prepend(self, data):
        """O(1) prepend."""
        new_node = Node(data)
        self._size += 1
        
        if not self.head:
            self.head = self.tail = new_node
            return
        
        new_node.next = self.head
        self.head = new_node

# Test: append is now O(1)!
ll = LinkedListWithTail()
for i in range(5):
    ll.append(i)

print(f"List: {ll}")
print(f"Head: {ll.head.data}, Tail: {ll.tail.data}")</textarea>
                <div class="code-figure-output" id="outputcode4a"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.5:</strong> A tail pointer makes append O(1) instead of O(n).
                </div>
            </div>
            
            <h3>Adding to the List</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.5 ‚Äî Insertion Methods</span>
                    <button class="code-figure-run" onclick="runCode('code5')">‚ñ∂ Run</button>
                </div>
                <textarea id="code5" spellcheck="false">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self._size = 0
    
    def __len__(self):
        return self._size
    
    def __str__(self):
        if not self.head:
            return "[]"
        parts = []
        curr = self.head
        while curr:
            parts.append(str(curr.data))
            curr = curr.next
        return "[" + " -> ".join(parts) + "]"
    
    def prepend(self, data):
        """Insert at beginning - O(1)."""
        new_node = Node(data)
        new_node.next = self.head  # Point to old head
        self.head = new_node       # Update head
        self._size += 1
    
    def append(self, data):
        """Insert at end - O(n) without tail pointer."""
        new_node = Node(data)
        self._size += 1
        
        if not self.head:
            self.head = new_node
            return
        
        # Traverse to find last node
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node
    
    def insert_at(self, index, data):
        """Insert at specific index - O(n)."""
        if index < 0 or index > self._size:
            raise IndexError("Index out of bounds")
        
        if index == 0:
            self.prepend(data)
            return
        
        new_node = Node(data)
        current = self.head
        for _ in range(index - 1):  # Stop at node before target
            current = current.next
        
        new_node.next = current.next
        current.next = new_node
        self._size += 1

# Test insertions
ll = LinkedList()
print("Building list:")

ll.append(1)
print(f"append(1): {ll}")

ll.append(3)
print(f"append(3): {ll}")

ll.prepend(0)
print(f"prepend(0): {ll}")

ll.insert_at(2, 2)
print(f"insert_at(2, 2): {ll}")

ll.append(4)
print(f"append(4): {ll}")

print(f"\nFinal list: {ll}")
print(f"Length: {len(ll)}")</textarea>
                <div class="code-figure-output" id="outputcode5"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.5:</strong> Three insertion methods: prepend (O(1)), append (O(n)), and insert_at (O(n)).
                </div>
            </div>
            
            <div class="important">
                Without a tail pointer, <code>append()</code> is O(n) because we must traverse the entire list to find the last node. We'll see later how adding a tail pointer makes it O(1).
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 4: BASIC OPERATIONS -->
        <!-- ============================================== -->
        <section id="operations">
            <h2>4. Basic Operations</h2>
            
            <h3>Traversal</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.6 ‚Äî Traversal Patterns</span>
                    <button class="code-figure-run" onclick="runCode('code6')">‚ñ∂ Run</button>
                </div>
                <textarea id="code6" spellcheck="false">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

# Build a list manually for demonstration
head = Node(10)
head.next = Node(20)
head.next.next = Node(30)
head.next.next.next = Node(40)

# Pattern 1: Basic traversal
print("Basic traversal:")
current = head
while current:
    print(f"  {current.data}")
    current = current.next

# Pattern 2: Count nodes
count = 0
current = head
while current:
    count += 1
    current = current.next
print(f"\nNode count: {count}")

# Pattern 3: Find a value
def find(head, target):
    """Return index of target, or -1 if not found."""
    current = head
    index = 0
    while current:
        if current.data == target:
            return index
        current = current.next
        index += 1
    return -1

print(f"\nFind 30: index {find(head, 30)}")
print(f"Find 99: index {find(head, 99)}")

# Pattern 4: Get node at index
def get_at(head, index):
    """Return data at index, or None if out of bounds."""
    current = head
    for i in range(index):
        if current is None:
            return None
        current = current.next
    return current.data if current else None

print(f"\nGet index 2: {get_at(head, 2)}")
print(f"Get index 10: {get_at(head, 10)}")</textarea>
                <div class="code-figure-output" id="outputcode6"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.6:</strong> Traversal patterns: basic loop, counting, searching, and indexed access.
                </div>
            </div>
            
            <h3>Search Operations</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.7 ‚Äî Search Operations</span>
                    <button class="code-figure-run" onclick="runCode('code6a')">‚ñ∂ Run</button>
                </div>
                <textarea id="code6a" spellcheck="false">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def build_list(values):
    if not values:
        return None
    head = Node(values[0])
    current = head
    for v in values[1:]:
        current.next = Node(v)
        current = current.next
    return head

def find_all(head, target):
    """Find all indices where target appears."""
    indices = []
    current = head
    index = 0
    while current:
        if current.data == target:
            indices.append(index)
        current = current.next
        index += 1
    return indices

def find_min_max(head):
    """Find minimum and maximum values."""
    if not head:
        return None, None
    
    min_val = max_val = head.data
    current = head.next
    
    while current:
        if current.data < min_val:
            min_val = current.data
        if current.data > max_val:
            max_val = current.data
        current = current.next
    
    return min_val, max_val

def count_occurrences(head, target):
    """Count how many times target appears."""
    count = 0
    current = head
    while current:
        if current.data == target:
            count += 1
        current = current.next
    return count

# Test
head = build_list([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])
print(f"List: 3 -> 1 -> 4 -> 1 -> 5 -> 9 -> 2 -> 6 -> 5 -> 3 -> 5")
print(f"find_all(5): indices {find_all(head, 5)}")
print(f"find_min_max(): {find_min_max(head)}")
print(f"count_occurrences(5): {count_occurrences(head, 5)}")</textarea>
                <div class="code-figure-output" id="outputcode6a"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.7:</strong> Search operations for finding values, min/max, and counting occurrences.
                </div>
            </div>
            
            <h3>Deletion</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.7 ‚Äî Deletion Operations</span>
                    <button class="code-figure-run" onclick="runCode('code7')">‚ñ∂ Run</button>
                </div>
                <textarea id="code7" spellcheck="false">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self._size = 0
    
    def __str__(self):
        if not self.head:
            return "[]"
        parts = []
        curr = self.head
        while curr:
            parts.append(str(curr.data))
            curr = curr.next
        return "[" + " -> ".join(parts) + "]"
    
    def append(self, data):
        new_node = Node(data)
        self._size += 1
        if not self.head:
            self.head = new_node
            return
        curr = self.head
        while curr.next:
            curr = curr.next
        curr.next = new_node
    
    def delete_first(self):
        """Delete first node - O(1)."""
        if not self.head:
            raise IndexError("Delete from empty list")
        data = self.head.data
        self.head = self.head.next
        self._size -= 1
        return data
    
    def delete_last(self):
        """Delete last node - O(n)."""
        if not self.head:
            raise IndexError("Delete from empty list")
        
        if not self.head.next:  # Only one node
            data = self.head.data
            self.head = None
            self._size -= 1
            return data
        
        # Find second-to-last node
        current = self.head
        while current.next.next:
            current = current.next
        
        data = current.next.data
        current.next = None
        self._size -= 1
        return data
    
    def delete_at(self, index):
        """Delete at index - O(n)."""
        if index < 0 or index >= self._size:
            raise IndexError("Index out of bounds")
        
        if index == 0:
            return self.delete_first()
        
        current = self.head
        for _ in range(index - 1):
            current = current.next
        
        data = current.next.data
        current.next = current.next.next
        self._size -= 1
        return data
    
    def delete_value(self, value):
        """Delete first occurrence of value."""
        if not self.head:
            return False
        
        if self.head.data == value:
            self.head = self.head.next
            self._size -= 1
            return True
        
        current = self.head
        while current.next:
            if current.next.data == value:
                current.next = current.next.next
                self._size -= 1
                return True
            current = current.next
        return False

# Test deletions
ll = LinkedList()
for x in [1, 2, 3, 4, 5]:
    ll.append(x)

print(f"Original: {ll}")

val = ll.delete_first()
print(f"delete_first(): removed {val}, list: {ll}")

val = ll.delete_last()
print(f"delete_last(): removed {val}, list: {ll}")

val = ll.delete_at(1)
print(f"delete_at(1): removed {val}, list: {ll}")

ll.append(3)
ll.append(3)
print(f"\nAfter adding 3s: {ll}")

ll.delete_value(3)
print(f"delete_value(3): {ll}")</textarea>
                <div class="code-figure-output" id="outputcode7"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.7:</strong> Deletion requires finding the node <em>before</em> the target to update its <code>next</code> pointer.
                </div>
            </div>
            
            <h3>Key Insight: The Previous Node</h3>
            
            <p>For both insertion and deletion, you need access to the node <em>before</em> the target position. This is because you need to update its <code>next</code> pointer. This is a fundamental pattern in linked list operations.</p>
            
            <div class="example">
                <div class="example-title">Deleting a Middle Node</div>
                <pre style="font-family: 'JetBrains Mono', monospace; font-size: 0.85rem;">
Delete node B from: A -> B -> C -> D

Step 1: Find node BEFORE B (node A)
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ  A  ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  B  ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  C  ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  D  ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚ñ≤
        prev

Step 2: Set prev.next = prev.next.next (skip B)
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ  A  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  C  ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  D  ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚ñ≤
              B is now orphaned (garbage collected)

Result: A -> C -> D
                </pre>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 5: COMPLEXITY ANALYSIS -->
        <!-- ============================================== -->
        <section id="complexity">
            <h2>5. Complexity Analysis</h2>
            
            <h3>Time Complexity Summary</h3>
            
            <table>
                <tr>
                    <th>Operation</th>
                    <th>Singly (no tail)</th>
                    <th>Singly (with tail)</th>
                    <th>Doubly</th>
                </tr>
                <tr>
                    <td>Access by index</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td>Insert at head</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Insert at tail</td>
                    <td>O(n)</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Insert at position</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td>Delete head</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Delete tail</td>
                    <td>O(n)</td>
                    <td>O(n)*</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Delete at position</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td>Search</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                </tr>
            </table>
            
            <p><em>* Even with a tail pointer, singly linked list delete-at-tail is O(n) because we need to find the second-to-last node.</em></p>
            
            <h3>Space Complexity</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.8 ‚Äî Memory Overhead Comparison</span>
                    <button class="code-figure-run" onclick="runCode('code8')">‚ñ∂ Run</button>
                </div>
                <textarea id="code8" spellcheck="false">import sys

# Python list memory
n = 1000
py_list = list(range(n))
list_size = sys.getsizeof(py_list)

# Estimate linked list memory
# Each node: object overhead + data ref + next ref
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

node = Node(0)
node_size = sys.getsizeof(node) + sys.getsizeof(node.__dict__)

print(f"Storing {n} integers:")
print(f"  Python list total: {list_size:,} bytes")
print(f"  Single node size:  ~{node_size} bytes")
print(f"  Linked list estimate: ~{node_size * n:,} bytes")
print(f"\nLinked list overhead: ~{(node_size * n) / list_size:.1f}x more memory")
print("\nLinked lists use more memory but enable O(1) insertions!")</textarea>
                <div class="code-figure-output" id="outputcode8"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.8:</strong> Linked lists have significant memory overhead due to pointer storage. Use them when insertion efficiency matters more than memory.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 6: DOUBLY LINKED LISTS -->
        <!-- ============================================== -->
        <section id="doubly">
            <h2>6. Doubly Linked Lists</h2>
            
            <p>A <span class="term">doubly linked list</span> extends the singly linked list by adding a <code>prev</code> pointer to each node, allowing traversal in both directions.</p>
            
            <div class="definition">
                <div class="definition-title">Definition</div>
                <p>A <span class="term">doubly linked list</span> is a linked list where each node has two pointers: <code>next</code> (pointing to the next node) and <code>prev</code> (pointing to the previous node). This enables O(1) deletion from the tail and bidirectional traversal.</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.9 ‚Äî Doubly Linked List Node</span>
                    <button class="code-figure-run" onclick="runCode('code9')">‚ñ∂ Run</button>
                </div>
                <textarea id="code9" spellcheck="false"># Doubly Linked List Node
class DNode:
    """A node in a doubly linked list."""
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None
    
    def __repr__(self):
        return f"DNode({self.data})"

# Create and link nodes
a = DNode("A")
b = DNode("B")
c = DNode("C")

# Link forward
a.next = b
b.next = c

# Link backward
b.prev = a
c.prev = b

print("Forward traversal:")
current = a
while current:
    print(f"  {current.data}")
    current = current.next

print("\nBackward traversal:")
current = c
while current:
    print(f"  {current.data}")
    current = current.prev

# Show bidirectional links
print(f"\nb.prev.data = '{b.prev.data}'")  # A
print(f"b.next.data = '{b.next.data}'"  )  # C</textarea>
                <div class="code-figure-output" id="outputcode9"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.9:</strong> Doubly linked nodes can traverse both forward and backward.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.10 ‚Äî Complete Doubly Linked List</span>
                    <button class="code-figure-run" onclick="runCode('code10')">‚ñ∂ Run</button>
                </div>
                <textarea id="code10" spellcheck="false">class DNode:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None

class DoublyLinkedList:
    """A doubly linked list with head and tail pointers."""
    
    def __init__(self):
        self.head = None
        self.tail = None
        self._size = 0
    
    def __len__(self):
        return self._size
    
    def __str__(self):
        if not self.head:
            return "[]"
        parts = []
        curr = self.head
        while curr:
            parts.append(str(curr.data))
            curr = curr.next
        return "[" + " <-> ".join(parts) + "]"
    
    def append(self, data):
        """Add to end - O(1) with tail pointer!"""
        new_node = DNode(data)
        self._size += 1
        
        if not self.head:
            self.head = self.tail = new_node
            return
        
        new_node.prev = self.tail
        self.tail.next = new_node
        self.tail = new_node
    
    def prepend(self, data):
        """Add to beginning - O(1)."""
        new_node = DNode(data)
        self._size += 1
        
        if not self.head:
            self.head = self.tail = new_node
            return
        
        new_node.next = self.head
        self.head.prev = new_node
        self.head = new_node
    
    def delete_first(self):
        """Remove from beginning - O(1)."""
        if not self.head:
            raise IndexError("Empty list")
        
        data = self.head.data
        self.head = self.head.next
        
        if self.head:
            self.head.prev = None
        else:
            self.tail = None  # List is now empty
        
        self._size -= 1
        return data
    
    def delete_last(self):
        """Remove from end - O(1) with doubly linked!"""
        if not self.tail:
            raise IndexError("Empty list")
        
        data = self.tail.data
        self.tail = self.tail.prev
        
        if self.tail:
            self.tail.next = None
        else:
            self.head = None  # List is now empty
        
        self._size -= 1
        return data

# Test
dll = DoublyLinkedList()
for x in [1, 2, 3, 4, 5]:
    dll.append(x)

print(f"List: {dll}")
print(f"Head: {dll.head.data}, Tail: {dll.tail.data}")

print(f"\ndelete_last(): {dll.delete_last()}")
print(f"List: {dll}")

print(f"\ndelete_first(): {dll.delete_first()}")
print(f"List: {dll}")</textarea>
                <div class="code-figure-output" id="outputcode10"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.12:</strong> Doubly linked list with tail pointer enables O(1) operations at both ends.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.13 ‚Äî Doubly Linked List Delete at Position</span>
                    <button class="code-figure-run" onclick="runCode('code10a')">‚ñ∂ Run</button>
                </div>
                <textarea id="code10a" spellcheck="false">class DNode:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
        self._size = 0
    
    def __str__(self):
        if not self.head:
            return "[]"
        parts = []
        curr = self.head
        while curr:
            parts.append(str(curr.data))
            curr = curr.next
        return "[" + " <-> ".join(parts) + "]"
    
    def append(self, data):
        new_node = DNode(data)
        self._size += 1
        if not self.head:
            self.head = self.tail = new_node
            return
        new_node.prev = self.tail
        self.tail.next = new_node
        self.tail = new_node
    
    def delete_node(self, node):
        """Delete a specific node in O(1) if you have reference!"""
        if node.prev:
            node.prev.next = node.next
        else:
            self.head = node.next
        
        if node.next:
            node.next.prev = node.prev
        else:
            self.tail = node.prev
        
        self._size -= 1
        return node.data
    
    def get_node_at(self, index):
        """Get node at index - can traverse from either end!"""
        if index < 0 or index >= self._size:
            return None
        
        # Optimize: start from closer end
        if index < self._size // 2:
            curr = self.head
            for _ in range(index):
                curr = curr.next
        else:
            curr = self.tail
            for _ in range(self._size - 1 - index):
                curr = curr.prev
        
        return curr

# Test
dll = DoublyLinkedList()
for x in [1, 2, 3, 4, 5]:
    dll.append(x)

print(f"List: {dll}")

# Get and delete middle node
middle = dll.get_node_at(2)
print(f"Middle node (index 2): {middle.data}")
dll.delete_node(middle)
print(f"After delete: {dll}")</textarea>
                <div class="code-figure-output" id="outputcode10a"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.13:</strong> Doubly linked list can delete any node in O(1) if you have a reference to it.
                </div>
            </div>
            
            <div class="margin-note">
                Python's <code>collections.deque</code> is implemented as a doubly linked list. Use it when you need O(1) operations at both ends!
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 7: CIRCULAR LINKED LISTS -->
        <!-- ============================================== -->
        <section id="circular">
            <h2>7. Circular Linked Lists</h2>
            
            <p>In a <span class="term">circular linked list</span>, the last node's <code>next</code> pointer points back to the first node, forming a circle. This is useful for round-robin scheduling, circular buffers, and games.</p>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.11 ‚Äî Circular Linked List</span>
                    <button class="code-figure-run" onclick="runCode('code11')">‚ñ∂ Run</button>
                </div>
                <textarea id="code11" spellcheck="false">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class CircularLinkedList:
    """A circular singly linked list."""
    
    def __init__(self):
        self.head = None
        self._size = 0
    
    def __len__(self):
        return self._size
    
    def is_empty(self):
        return self.head is None
    
    def append(self, data):
        """Add to end (before head in circle)."""
        new_node = Node(data)
        self._size += 1
        
        if not self.head:
            self.head = new_node
            new_node.next = new_node  # Points to itself
            return
        
        # Find last node (the one pointing to head)
        current = self.head
        while current.next != self.head:
            current = current.next
        
        current.next = new_node
        new_node.next = self.head
    
    def display(self, max_iterations=None):
        """Display the circular list."""
        if not self.head:
            return "[]"
        
        parts = []
        current = self.head
        count = 0
        max_show = max_iterations or self._size
        
        while count < max_show:
            parts.append(str(current.data))
            current = current.next
            count += 1
            if current == self.head and max_iterations is None:
                break
        
        return "[" + " -> ".join(parts) + " -> (back to head)]"
    
    def rotate(self):
        """Move head to next node - O(1)."""
        if self.head:
            self.head = self.head.next

# Test
cll = CircularLinkedList()
for x in ["A", "B", "C", "D"]:
    cll.append(x)

print(f"Circular list: {cll.display()}")
print(f"Head: {cll.head.data}")

cll.rotate()
print(f"\nAfter rotate(): {cll.display()}")
print(f"Head: {cll.head.data}")

cll.rotate()
print(f"\nAfter rotate(): {cll.display()}")
print(f"Head: {cll.head.data}")

# Demonstrate circular nature
print("\nTraversing 10 times around the circle:")
current = cll.head
path = []
for i in range(10):
    path.append(current.data)
    current = current.next
print(" -> ".join(path))</textarea>
                <div class="code-figure-output" id="outputcode11"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.15:</strong> Circular lists have no end‚Äîthe last node points back to the head.
                </div>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.16 ‚Äî Josephus Problem (Circular List)</span>
                    <button class="code-figure-run" onclick="runCode('code11a')">‚ñ∂ Run</button>
                </div>
                <textarea id="code11a" spellcheck="false"># Classic Josephus Problem using circular list
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def josephus(n, k):
    """
    N people in circle, eliminate every k-th person.
    Return the survivor's position (1-indexed).
    """
    # Build circular list
    head = Node(1)
    current = head
    for i in range(2, n + 1):
        current.next = Node(i)
        current = current.next
    current.next = head  # Make circular
    
    # Eliminate until one remains
    prev = current  # Last node (before head)
    current = head
    
    while current.next != current:  # More than one node
        # Skip k-1 people
        for _ in range(k - 1):
            prev = current
            current = current.next
        
        # Eliminate current
        print(f"  Eliminated: {current.data}")
        prev.next = current.next
        current = prev.next
    
    return current.data

# Test: 7 people, eliminate every 3rd
print("Josephus(7, 3):")
survivor = josephus(7, 3)
print(f"  Survivor: Person {survivor}")</textarea>
                <div class="code-figure-output" id="outputcode11a"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.16:</strong> The Josephus problem is a classic application of circular linked lists.
                </div>
            </div>
            
            <h3>Applications of Circular Lists</h3>
            
            <ul>
                <li><strong>Round-robin scheduling:</strong> CPU scheduling where each process gets equal time</li>
                <li><strong>Circular buffers:</strong> Audio/video streaming buffers that wrap around</li>
                <li><strong>Game turns:</strong> Cycling through players in a multiplayer game</li>
                <li><strong>Music playlists:</strong> Repeat mode that loops back to start</li>
            </ul>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 8: PATTERNS AND TECHNIQUES -->
        <!-- ============================================== -->
        <section id="patterns">
            <h2>8. Common Patterns &amp; Techniques</h2>
            
            <h3>Pattern 1: Dummy Head Node</h3>
            
            <p>Using a dummy (sentinel) head node simplifies edge cases by ensuring there's always a node before the first real element.</p>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.12 ‚Äî Dummy Head Pattern</span>
                    <button class="code-figure-run" onclick="runCode('code12')">‚ñ∂ Run</button>
                </div>
                <textarea id="code12" spellcheck="false">class Node:
    def __init__(self, data=None):
        self.data = data
        self.next = None

# WITHOUT dummy head - need special case for empty list
def insert_without_dummy(head, data):
    """Insert in sorted order (no dummy)."""
    new_node = Node(data)
    
    # Special case: empty list or insert at beginning
    if not head or data < head.data:
        new_node.next = head
        return new_node  # New head!
    
    # Find insertion point
    current = head
    while current.next and current.next.data < data:
        current = current.next
    
    new_node.next = current.next
    current.next = new_node
    return head

# WITH dummy head - no special cases needed!
def insert_with_dummy(dummy, data):
    """Insert in sorted order (with dummy)."""
    new_node = Node(data)
    
    # Always start from dummy - first real node is dummy.next
    current = dummy
    while current.next and current.next.data < data:
        current = current.next
    
    new_node.next = current.next
    current.next = new_node
    # No need to return new head - dummy is always the head

# Demonstrate
dummy = Node()  # Dummy head with no data
for x in [30, 10, 50, 20, 40]:
    insert_with_dummy(dummy, x)

# Print (skip dummy)
print("Sorted list with dummy head:")
current = dummy.next  # Skip dummy
while current:
    print(f"  {current.data}")
    current = current.next</textarea>
                <div class="code-figure-output" id="outputcode12"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.12:</strong> A dummy head eliminates special cases for empty list and head insertion.
                </div>
            </div>
            
            <h3>Pattern 2: Two-Pointer (Fast/Slow)</h3>
            
            <p>The fast and slow pointer technique is essential for many linked list problems.</p>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.13 ‚Äî Fast/Slow Pointers</span>
                    <button class="code-figure-run" onclick="runCode('code13')">‚ñ∂ Run</button>
                </div>
                <textarea id="code13" spellcheck="false">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def build_list(values):
    """Helper to build a linked list from values."""
    if not values:
        return None
    head = Node(values[0])
    current = head
    for v in values[1:]:
        current.next = Node(v)
        current = current.next
    return head

def find_middle(head):
    """Find middle node using fast/slow pointers."""
    if not head:
        return None
    
    slow = fast = head
    while fast and fast.next:
        slow = slow.next          # Move 1 step
        fast = fast.next.next     # Move 2 steps
    
    return slow  # When fast reaches end, slow is at middle

def find_nth_from_end(head, n):
    """Find nth node from end using two pointers."""
    # Move fast pointer n nodes ahead
    fast = head
    for _ in range(n):
        if not fast:
            return None
        fast = fast.next
    
    # Move both until fast reaches end
    slow = head
    while fast:
        slow = slow.next
        fast = fast.next
    
    return slow

# Test find_middle
head = build_list([1, 2, 3, 4, 5])
print("List: 1 -> 2 -> 3 -> 4 -> 5")
middle = find_middle(head)
print(f"Middle: {middle.data}")

head = build_list([1, 2, 3, 4, 5, 6])
print("\nList: 1 -> 2 -> 3 -> 4 -> 5 -> 6")
middle = find_middle(head)
print(f"Middle: {middle.data}")

# Test find_nth_from_end
head = build_list([1, 2, 3, 4, 5])
print("\nList: 1 -> 2 -> 3 -> 4 -> 5")
for n in [1, 2, 3]:
    node = find_nth_from_end(head, n)
    print(f"  {n}th from end: {node.data}")</textarea>
                <div class="code-figure-output" id="outputcode13"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.13:</strong> Fast/slow pointers find the middle in one pass. Gap technique finds nth from end.
                </div>
            </div>
            
            <h3>Pattern 3: Runner Technique for Rearrangement</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.14 ‚Äî Reorder List</span>
                    <button class="code-figure-run" onclick="runCode('code14')">‚ñ∂ Run</button>
                </div>
                <textarea id="code14" spellcheck="false">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def build_list(values):
    if not values:
        return None
    head = Node(values[0])
    current = head
    for v in values[1:]:
        current.next = Node(v)
        current = current.next
    return head

def list_to_string(head):
    parts = []
    while head:
        parts.append(str(head.data))
        head = head.next
    return " -> ".join(parts)

def reorder_list(head):
    """
    Reorder: L0 ‚Üí L1 ‚Üí ... ‚Üí Ln-1 ‚Üí Ln
    To:      L0 ‚Üí Ln ‚Üí L1 ‚Üí Ln-1 ‚Üí L2 ‚Üí Ln-2 ‚Üí ...
    """
    if not head or not head.next:
        return head
    
    # Step 1: Find middle
    slow, fast = head, head
    while fast.next and fast.next.next:
        slow = slow.next
        fast = fast.next.next
    
    # Step 2: Reverse second half
    prev, curr = None, slow.next
    slow.next = None  # Cut the list
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    
    # Step 3: Merge two halves
    first, second = head, prev
    while second:
        tmp1, tmp2 = first.next, second.next
        first.next = second
        second.next = tmp1
        first, second = tmp1, tmp2
    
    return head

# Test
head = build_list([1, 2, 3, 4, 5])
print(f"Original: {list_to_string(head)}")
reorder_list(head)
print(f"Reordered: {list_to_string(head)}")</textarea>
                <div class="code-figure-output" id="outputcode14"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.14:</strong> Reordering combines finding middle, reversing, and merging.
                </div>
            </div>
            
            <h3>Pattern 4: Reversing a Linked List</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.14 ‚Äî Reversing a Linked List</span>
                    <button class="code-figure-run" onclick="runCode('code14')">‚ñ∂ Run</button>
                </div>
                <textarea id="code14" spellcheck="false">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def build_list(values):
    if not values:
        return None
    head = Node(values[0])
    current = head
    for v in values[1:]:
        current.next = Node(v)
        current = current.next
    return head

def list_to_string(head):
    parts = []
    while head:
        parts.append(str(head.data))
        head = head.next
    return " -> ".join(parts) if parts else "empty"

def reverse_iterative(head):
    """Reverse linked list iteratively - O(n) time, O(1) space."""
    prev = None
    current = head
    
    while current:
        next_temp = current.next  # Save next
        current.next = prev       # Reverse link
        prev = current            # Move prev forward
        current = next_temp       # Move current forward
    
    return prev  # New head

def reverse_recursive(head):
    """Reverse linked list recursively - O(n) time, O(n) space."""
    # Base case: empty or single node
    if not head or not head.next:
        return head
    
    # Reverse the rest
    new_head = reverse_recursive(head.next)
    
    # Put first element at end
    head.next.next = head
    head.next = None
    
    return new_head

# Test iterative
head = build_list([1, 2, 3, 4, 5])
print(f"Original:  {list_to_string(head)}")
head = reverse_iterative(head)
print(f"Reversed:  {list_to_string(head)}")

# Test recursive
head = build_list(["A", "B", "C", "D"])
print(f"\nOriginal:  {list_to_string(head)}")
head = reverse_recursive(head)
print(f"Reversed:  {list_to_string(head)}")</textarea>
                <div class="code-figure-output" id="outputcode14"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.14:</strong> Reversing a linked list is a fundamental operation. Iterative uses O(1) space; recursive uses O(n) stack space.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 9: CLASSIC PROBLEMS -->
        <!-- ============================================== -->
        <section id="problems">
            <h2>9. Classic Problems</h2>
            
            <h3>Cycle Detection (Floyd's Algorithm)</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.15 ‚Äî Detecting Cycles</span>
                    <button class="code-figure-run" onclick="runCode('code15')">‚ñ∂ Run</button>
                </div>
                <textarea id="code15" spellcheck="false">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def has_cycle(head):
    """
    Detect cycle using Floyd's algorithm.
    Fast pointer moves 2 steps, slow moves 1 step.
    If there's a cycle, they will eventually meet.
    """
    if not head:
        return False
    
    slow = fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        
        if slow == fast:  # They met - cycle exists!
            return True
    
    return False  # Fast reached end - no cycle

def find_cycle_start(head):
    """Find where the cycle begins."""
    if not head:
        return None
    
    # Phase 1: Detect cycle
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            break
    else:
        return None  # No cycle
    
    # Phase 2: Find cycle start
    # Reset slow to head, move both at same speed
    slow = head
    while slow != fast:
        slow = slow.next
        fast = fast.next
    
    return slow  # Cycle start

# Create list with cycle: 1 -> 2 -> 3 -> 4 -> 5 -> 3 (back to 3)
head = Node(1)
head.next = Node(2)
head.next.next = Node(3)
head.next.next.next = Node(4)
head.next.next.next.next = Node(5)
head.next.next.next.next.next = head.next.next  # Cycle to node 3

print("List with cycle (1->2->3->4->5->3...):")
print(f"  has_cycle: {has_cycle(head)}")
cycle_start = find_cycle_start(head)
print(f"  cycle_start: {cycle_start.data}")

# Create list without cycle
head2 = Node(1)
head2.next = Node(2)
head2.next.next = Node(3)

print("\nList without cycle (1->2->3):")
print(f"  has_cycle: {has_cycle(head2)}")</textarea>
                <div class="code-figure-output" id="outputcode15"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.15:</strong> Floyd's cycle detection uses O(1) space. If fast and slow meet, there's a cycle.
                </div>
            </div>
            
            <h3>Merge Two Sorted Lists</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.16 ‚Äî Merging Sorted Lists</span>
                    <button class="code-figure-run" onclick="runCode('code16')">‚ñ∂ Run</button>
                </div>
                <textarea id="code16" spellcheck="false">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def build_list(values):
    if not values:
        return None
    head = Node(values[0])
    current = head
    for v in values[1:]:
        current.next = Node(v)
        current = current.next
    return head

def list_to_string(head):
    parts = []
    while head:
        parts.append(str(head.data))
        head = head.next
    return " -> ".join(parts) if parts else "empty"

def merge_sorted(l1, l2):
    """Merge two sorted lists into one sorted list."""
    # Use dummy head to simplify edge cases
    dummy = Node(0)
    current = dummy
    
    while l1 and l2:
        if l1.data <= l2.data:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
    
    # Attach remaining nodes
    current.next = l1 or l2
    
    return dummy.next

# Test
list1 = build_list([1, 3, 5, 7])
list2 = build_list([2, 4, 6, 8])

print(f"List 1: {list_to_string(list1)}")
print(f"List 2: {list_to_string(list2)}")

merged = merge_sorted(list1, list2)
print(f"Merged: {list_to_string(merged)}")</textarea>
                <div class="code-figure-output" id="outputcode16"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.17:</strong> Merging sorted lists is O(n+m) time and O(1) extra space (just reusing existing nodes).
                </div>
            </div>
            
            <h3>Remove Nth Node from End</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.18 ‚Äî Remove Nth from End</span>
                    <button class="code-figure-run" onclick="runCode('code16a')">‚ñ∂ Run</button>
                </div>
                <textarea id="code16a" spellcheck="false">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def build_list(values):
    if not values:
        return None
    head = Node(values[0])
    current = head
    for v in values[1:]:
        current.next = Node(v)
        current = current.next
    return head

def list_to_string(head):
    parts = []
    while head:
        parts.append(str(head.data))
        head = head.next
    return " -> ".join(parts)

def remove_nth_from_end(head, n):
    """Remove nth node from end (1-indexed)."""
    # Use dummy to handle edge case of removing head
    dummy = Node(0)
    dummy.next = head
    
    # Move fast n+1 steps ahead
    fast = slow = dummy
    for _ in range(n + 1):
        fast = fast.next
    
    # Move both until fast reaches end
    while fast:
        fast = fast.next
        slow = slow.next
    
    # Remove the node
    slow.next = slow.next.next
    
    return dummy.next

# Test
head = build_list([1, 2, 3, 4, 5])
print(f"Original: {list_to_string(head)}")

head = remove_nth_from_end(head, 2)
print(f"Remove 2nd from end: {list_to_string(head)}")

head = remove_nth_from_end(head, 1)
print(f"Remove 1st from end: {list_to_string(head)}")</textarea>
                <div class="code-figure-output" id="outputcode16a"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.18:</strong> Two-pointer technique with dummy head for safe removal from any position.
                </div>
            </div>
            
            <h3>Swap Nodes in Pairs</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.19 ‚Äî Swap Nodes in Pairs</span>
                    <button class="code-figure-run" onclick="runCode('code16b')">‚ñ∂ Run</button>
                </div>
                <textarea id="code16b" spellcheck="false">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def build_list(values):
    if not values:
        return None
    head = Node(values[0])
    current = head
    for v in values[1:]:
        current.next = Node(v)
        current = current.next
    return head

def list_to_string(head):
    parts = []
    while head:
        parts.append(str(head.data))
        head = head.next
    return " -> ".join(parts)

def swap_pairs(head):
    """Swap every two adjacent nodes."""
    dummy = Node(0)
    dummy.next = head
    prev = dummy
    
    while prev.next and prev.next.next:
        first = prev.next
        second = prev.next.next
        
        # Swap
        first.next = second.next
        second.next = first
        prev.next = second
        
        prev = first
    
    return dummy.next

# Test
head = build_list([1, 2, 3, 4, 5])
print(f"Original: {list_to_string(head)}")
head = swap_pairs(head)
print(f"Swapped pairs: {list_to_string(head)}")</textarea>
                <div class="code-figure-output" id="outputcode16b"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.19:</strong> Swapping adjacent pairs requires careful pointer manipulation.
                </div>
            </div>
            
            <h3>Partition List</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.20 ‚Äî Partition List</span>
                    <button class="code-figure-run" onclick="runCode('code16c')">‚ñ∂ Run</button>
                </div>
                <textarea id="code16c" spellcheck="false">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def build_list(values):
    if not values:
        return None
    head = Node(values[0])
    current = head
    for v in values[1:]:
        current.next = Node(v)
        current = current.next
    return head

def list_to_string(head):
    parts = []
    while head:
        parts.append(str(head.data))
        head = head.next
    return " -> ".join(parts)

def partition(head, x):
    """
    Partition list so all nodes < x come before nodes >= x.
    Maintains original relative order.
    """
    # Two dummy heads for two lists
    less_dummy = Node(0)
    greater_dummy = Node(0)
    less = less_dummy
    greater = greater_dummy
    
    current = head
    while current:
        if current.data < x:
            less.next = current
            less = less.next
        else:
            greater.next = current
            greater = greater.next
        current = current.next
    
    # Connect the two lists
    greater.next = None  # Important: terminate the list
    less.next = greater_dummy.next
    
    return less_dummy.next

# Test
head = build_list([1, 4, 3, 2, 5, 2])
print(f"Original: {list_to_string(head)}")
head = partition(head, 3)
print(f"Partitioned (x=3): {list_to_string(head)}")</textarea>
                <div class="code-figure-output" id="outputcode16c"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.20:</strong> Partition uses two separate lists for elements less than and greater than pivot.
                </div>
            </div>
            
            <h3>Checking for Palindrome</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.17 ‚Äî Palindrome Check</span>
                    <button class="code-figure-run" onclick="runCode('code17')">‚ñ∂ Run</button>
                </div>
                <textarea id="code17" spellcheck="false">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def build_list(values):
    if not values:
        return None
    head = Node(values[0])
    current = head
    for v in values[1:]:
        current.next = Node(v)
        current = current.next
    return head

def reverse(head):
    prev = None
    while head:
        next_temp = head.next
        head.next = prev
        prev = head
        head = next_temp
    return prev

def is_palindrome(head):
    """
    Check if linked list is palindrome.
    Strategy: Find middle, reverse second half, compare.
    """
    if not head or not head.next:
        return True
    
    # Find middle using fast/slow
    slow = fast = head
    while fast.next and fast.next.next:
        slow = slow.next
        fast = fast.next.next
    
    # Reverse second half
    second_half = reverse(slow.next)
    
    # Compare first and second half
    first_half = head
    while second_half:
        if first_half.data != second_half.data:
            return False
        first_half = first_half.next
        second_half = second_half.next
    
    return True

# Test cases
test_cases = [
    [1, 2, 3, 2, 1],      # Palindrome (odd)
    [1, 2, 2, 1],          # Palindrome (even)
    [1, 2, 3, 4, 5],       # Not palindrome
    [1],                   # Single element
    [1, 1],                # Two same
    [1, 2],                # Two different
]

print("Palindrome checks:")
for values in test_cases:
    head = build_list(values)
    result = is_palindrome(head)
    print(f"  {values}: {result}")</textarea>
                <div class="code-figure-output" id="outputcode17"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.21:</strong> Palindrome check uses fast/slow to find middle, then reverses and compares. O(n) time, O(1) space.
                </div>
            </div>
            
            <h3>Copy List with Random Pointer</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.22 ‚Äî Deep Copy with Random Pointers</span>
                    <button class="code-figure-run" onclick="runCode('code17a')">‚ñ∂ Run</button>
                </div>
                <textarea id="code17a" spellcheck="false">class RandomNode:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.random = None

def copy_random_list(head):
    """
    Deep copy a list where each node has a random pointer.
    Uses O(n) space with hash map approach.
    """
    if not head:
        return None
    
    # Create mapping from original to copy
    old_to_new = {}
    
    # First pass: create all nodes
    current = head
    while current:
        old_to_new[current] = RandomNode(current.data)
        current = current.next
    
    # Second pass: set next and random pointers
    current = head
    while current:
        copy = old_to_new[current]
        copy.next = old_to_new.get(current.next)
        copy.random = old_to_new.get(current.random)
        current = current.next
    
    return old_to_new[head]

# Test
a = RandomNode(1)
b = RandomNode(2)
c = RandomNode(3)
a.next, b.next = b, c
a.random, b.random, c.random = c, a, b

# Copy
copy_head = copy_random_list(a)

# Verify copy
print("Original: 1 -> 2 -> 3")
print(f"  a.random = {a.random.data}, b.random = {b.random.data}")

print("\nCopy created successfully!")
print(f"  copy.data = {copy_head.data}")
print(f"  copy.random.data = {copy_head.random.data}")
print(f"  copy is a: {copy_head is a}")  # Should be False</textarea>
                <div class="code-figure-output" id="outputcode17a"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.22:</strong> Deep copy with random pointers uses a hash map to track original-to-copy mapping.
                </div>
            </div>
            
            <h3>Sort a Linked List</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.23 ‚Äî Merge Sort for Linked List</span>
                    <button class="code-figure-run" onclick="runCode('code17b')">‚ñ∂ Run</button>
                </div>
                <textarea id="code17b" spellcheck="false">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def build_list(values):
    if not values:
        return None
    head = Node(values[0])
    current = head
    for v in values[1:]:
        current.next = Node(v)
        current = current.next
    return head

def list_to_string(head):
    parts = []
    while head:
        parts.append(str(head.data))
        head = head.next
    return " -> ".join(parts)

def get_middle(head):
    """Get middle node (for splitting)."""
    slow, fast = head, head.next
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    return slow

def merge(l1, l2):
    """Merge two sorted lists."""
    dummy = Node(0)
    curr = dummy
    while l1 and l2:
        if l1.data < l2.data:
            curr.next = l1
            l1 = l1.next
        else:
            curr.next = l2
            l2 = l2.next
        curr = curr.next
    curr.next = l1 or l2
    return dummy.next

def sort_list(head):
    """Sort linked list using merge sort. O(n log n) time."""
    if not head or not head.next:
        return head
    
    # Split list in half
    mid = get_middle(head)
    right = mid.next
    mid.next = None
    
    # Recursively sort both halves
    left = sort_list(head)
    right = sort_list(right)
    
    # Merge sorted halves
    return merge(left, right)

# Test
head = build_list([4, 2, 1, 3, 5])
print(f"Original: {list_to_string(head)}")
head = sort_list(head)
print(f"Sorted: {list_to_string(head)}")</textarea>
                <div class="code-figure-output" id="outputcode17b"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.23:</strong> Merge sort is ideal for linked lists: O(n log n) time, O(log n) stack space.
                </div>
            </div>
            
            <h3>Rotate List</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.24 ‚Äî Rotate List by K</span>
                    <button class="code-figure-run" onclick="runCode('code17c')">‚ñ∂ Run</button>
                </div>
                <textarea id="code17c" spellcheck="false">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def build_list(values):
    if not values:
        return None
    head = Node(values[0])
    current = head
    for v in values[1:]:
        current.next = Node(v)
        current = current.next
    return head

def list_to_string(head):
    parts = []
    while head:
        parts.append(str(head.data))
        head = head.next
    return " -> ".join(parts)

def rotate_right(head, k):
    """Rotate list to the right by k places."""
    if not head or not head.next or k == 0:
        return head
    
    # Find length and last node
    length = 1
    tail = head
    while tail.next:
        tail = tail.next
        length += 1
    
    # Normalize k
    k = k % length
    if k == 0:
        return head
    
    # Find new tail (length - k - 1 steps from head)
    new_tail = head
    for _ in range(length - k - 1):
        new_tail = new_tail.next
    
    # Rotate
    new_head = new_tail.next
    new_tail.next = None
    tail.next = head
    
    return new_head

# Test
head = build_list([1, 2, 3, 4, 5])
print(f"Original: {list_to_string(head)}")

head = rotate_right(head, 2)
print(f"Rotate right 2: {list_to_string(head)}")</textarea>
                <div class="code-figure-output" id="outputcode17c"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.24:</strong> Rotation makes the list circular temporarily, then breaks at the right position.
                </div>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 10: COMMON PITFALLS -->
        <!-- ============================================== -->
        <section id="pitfalls">
            <h2>10. Common Pitfalls</h2>
            
            <h3>Pitfall 1: Losing the Head Reference</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.18 ‚Äî Losing References</span>
                    <button class="code-figure-run" onclick="runCode('code18')">‚ñ∂ Run</button>
                </div>
                <textarea id="code18" spellcheck="false">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

# BAD: Modifying head directly
def bad_traverse(head):
    """Wrong - loses head reference!"""
    while head:
        print(head.data, end=" ")
        head = head.next  # BAD: modifying parameter
    # head is now None! Original reference is lost

# GOOD: Use a separate current pointer
def good_traverse(head):
    """Correct - preserves head reference."""
    current = head  # Use separate variable
    while current:
        print(current.data, end=" ")
        current = current.next
    # head still points to first node

# Demonstrate
head = Node(1)
head.next = Node(2)
head.next.next = Node(3)

print("Good traverse (head preserved):")
good_traverse(head)
print(f"\nhead after: {head.data}")

# Note: Python passes references by value, so bad_traverse
# doesn't actually modify the caller's head variable,
# but inside the function you lose track of the start.</textarea>
                <div class="code-figure-output" id="outputcode18"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.18:</strong> Always use a separate <code>current</code> variable for traversal to preserve the head reference.
                </div>
            </div>
            
            <h3>Pitfall 2: Forgetting to Update Links</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.19 ‚Äî Link Update Errors</span>
                    <button class="code-figure-run" onclick="runCode('code19')">‚ñ∂ Run</button>
                </div>
                <textarea id="code19" spellcheck="false">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

# BAD: Order of operations matters!
def bad_insert_after(node, data):
    """Wrong order - loses rest of list!"""
    new_node = Node(data)
    node.next = new_node      # Now new_node.next is None
    new_node.next = node.next  # This is new_node itself! Wrong!

# GOOD: Save the next reference first
def good_insert_after(node, data):
    """Correct order - preserves list."""
    new_node = Node(data)
    new_node.next = node.next  # First: point to what's after
    node.next = new_node       # Then: insert new node

# Demonstrate
head = Node("A")
head.next = Node("C")

print(f"Before: A -> C")

# Insert B between A and C
good_insert_after(head, "B")

# Print result
current = head
parts = []
while current:
    parts.append(current.data)
    current = current.next
print(f"After good_insert_after: {' -> '.join(parts)}")</textarea>
                <div class="code-figure-output" id="outputcode19"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.19:</strong> When inserting, set the new node's next pointer BEFORE updating the previous node's next.
                </div>
            </div>
            
            <h3>Pitfall 3: Null Pointer Errors</h3>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Listing 4.20 ‚Äî Null Checks</span>
                    <button class="code-figure-run" onclick="runCode('code20')">‚ñ∂ Run</button>
                </div>
                <textarea id="code20" spellcheck="false">class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

# BAD: No null check before accessing .next
def bad_find_second(head):
    """Crashes on empty list!"""
    return head.next.data  # AttributeError if head is None!

# GOOD: Always check for None
def good_find_second(head):
    """Safe with proper null checks."""
    if not head:
        return None
    if not head.next:
        return None
    return head.next.data

# BAD: Not checking in loop condition
def bad_find_last(head):
    """Crashes when list is empty!"""
    while head.next:  # Crashes if head is None
        head = head.next
    return head.data

# GOOD: Check before loop
def good_find_last(head):
    """Safe implementation."""
    if not head:
        return None
    while head.next:
        head = head.next
    return head.data

# Test
print("Safe null handling:")
print(f"  good_find_second(None): {good_find_second(None)}")
print(f"  good_find_last(None): {good_find_last(None)}")

head = Node(1)
print(f"  good_find_second(single): {good_find_second(head)}")
print(f"  good_find_last(single): {good_find_last(head)}")</textarea>
                <div class="code-figure-output" id="outputcode20"></div>
                <div class="code-figure-caption">
                    <strong>Figure 4.20:</strong> Always check if a node is None before accessing its attributes.
                </div>
            </div>
            
            <div class="summary">
                <div class="summary-title">Key Takeaways</div>
                <ul>
                    <li><strong>Linked lists</strong> trade O(1) random access for O(1) insertions/deletions at known positions</li>
                    <li><strong>Nodes</strong> contain data and a reference to the next node</li>
                    <li><strong>Singly linked</strong> lists traverse forward only; <strong>doubly linked</strong> go both ways</li>
                    <li><strong>Tail pointer</strong> enables O(1) append; <strong>doubly linked</strong> enables O(1) delete at tail</li>
                    <li><strong>Fast/slow pointers</strong> find middle, detect cycles, find nth from end</li>
                    <li><strong>Dummy head</strong> pattern simplifies edge cases</li>
                    <li><strong>Always</strong> check for None before accessing node attributes</li>
                </ul>
            </div>
        </section>

        <!-- ============================================== -->
        <!-- SECTION 11: EXERCISES -->
        <!-- ============================================== -->
        <section id="exercises">
            <h2>11. Exercises</h2>
            
            <!-- Exercise 1 -->
            <div class="exercise">
                <div class="exercise-title">Exercise 1: Implement get(index)</div>
                <p>Add a <code>get(index)</code> method to LinkedList that returns the data at the given index, or raises IndexError if out of bounds.</p>
                <p class="answer">(Answer: get(0) returns head.data, get(2) returns third element's data)</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 1 ‚Äî Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex1')">‚ñ∂ Run</button>
                </div>
                <textarea id="ex1" spellcheck="false"># HINT 1: Traverse the list while counting
# HINT 2: Return current.data when count equals index
# HINT 3: Raise IndexError if you reach end before finding index

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self._size = 0
    
    def append(self, data):
        new_node = Node(data)
        self._size += 1
        if not self.head:
            self.head = new_node
            return
        curr = self.head
        while curr.next:
            curr = curr.next
        curr.next = new_node
    
    def get(self, index):
        # Your code here
        pass

# Test your implementation
# ll = LinkedList()
# for x in [10, 20, 30, 40, 50]:
#     ll.append(x)
# print(f"get(0): {ll.get(0)}")  # Expected: 10
# print(f"get(2): {ll.get(2)}")  # Expected: 30
# print(f"get(4): {ll.get(4)}")  # Expected: 50</textarea>
                <div class="code-figure-output" id="outputex1"></div>
            </div>
            
            <!-- Exercise 2 -->
            <div class="exercise">
                <div class="exercise-title">Exercise 2: Remove Duplicates from Sorted List</div>
                <p>Write <code>remove_duplicates(head)</code> that removes all duplicates from a sorted linked list, leaving only distinct values.</p>
                <p class="answer">(Answer: [1, 1, 2, 3, 3, 3, 4] ‚Üí [1, 2, 3, 4])</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 2 ‚Äî Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex2')">‚ñ∂ Run</button>
                </div>
                <textarea id="ex2" spellcheck="false"># HINT 1: Since sorted, duplicates are adjacent
# HINT 2: Compare current.data with current.next.data
# HINT 3: If same, skip current.next by setting current.next = current.next.next

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def build_list(values):
    if not values:
        return None
    head = Node(values[0])
    curr = head
    for v in values[1:]:
        curr.next = Node(v)
        curr = curr.next
    return head

def list_to_string(head):
    parts = []
    while head:
        parts.append(str(head.data))
        head = head.next
    return " -> ".join(parts)

def remove_duplicates(head):
    # Your code here
    pass

# Test your implementation
# head = build_list([1, 1, 2, 3, 3, 3, 4])
# print(f"Before: {list_to_string(head)}")
# remove_duplicates(head)
# print(f"After: {list_to_string(head)}")</textarea>
                <div class="code-figure-output" id="outputex2"></div>
            </div>
            
            <!-- Exercise 3 -->
            <div class="exercise">
                <div class="exercise-title">Exercise 3: Add Two Numbers (as Linked Lists)</div>
                <p>Given two linked lists representing numbers in reverse order (each node contains a single digit), return a new linked list representing their sum.</p>
                <p class="answer">(Answer: [2,4,3] + [5,6,4] = [7,0,8] representing 342 + 465 = 807)</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 3 ‚Äî Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex3')">‚ñ∂ Run</button>
                </div>
                <textarea id="ex3" spellcheck="false"># HINT 1: Process both lists simultaneously, digit by digit
# HINT 2: Track carry for digits that sum > 9
# HINT 3: Don't forget to handle remaining carry at the end

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def build_list(values):
    if not values:
        return None
    head = Node(values[0])
    curr = head
    for v in values[1:]:
        curr.next = Node(v)
        curr = curr.next
    return head

def list_to_string(head):
    parts = []
    while head:
        parts.append(str(head.data))
        head = head.next
    return " -> ".join(parts)

def add_two_numbers(l1, l2):
    # Your code here
    pass

# Test your implementation
# l1 = build_list([2, 4, 3])  # Represents 342
# l2 = build_list([5, 6, 4])  # Represents 465
# result = add_two_numbers(l1, l2)
# print(f"{list_to_string(l1)}")
# print(f"{list_to_string(l2)}")
# print(f"Sum: {list_to_string(result)}")  # Should be 7 -> 0 -> 8</textarea>
                <div class="code-figure-output" id="outputex3"></div>
            </div>
            
            <!-- Exercise 4 -->
            <div class="exercise">
                <div class="exercise-title">Exercise 4: Intersection of Two Lists</div>
                <p>Write <code>get_intersection(headA, headB)</code> that returns the node where two linked lists intersect, or None if they don't.</p>
                <p class="answer">(Answer: Return the shared node, not just equal data)</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 4 ‚Äî Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex4')">‚ñ∂ Run</button>
                </div>
                <textarea id="ex4" spellcheck="false"># HINT 1: Two lists intersect if they share the same tail
# HINT 2: Get lengths of both lists
# HINT 3: Advance the longer list by the difference in lengths
# HINT 4: Then traverse both together until pointers meet

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def get_intersection(headA, headB):
    # Your code here
    pass

# Test your implementation
# Create two lists that intersect:
# A: 1 -> 2 -> 3
#                \
#                 -> 6 -> 7 -> None
#                /
# B:      4 -> 5

# shared = Node(6)
# shared.next = Node(7)

# headA = Node(1)
# headA.next = Node(2)
# headA.next.next = Node(3)
# headA.next.next.next = shared

# headB = Node(4)
# headB.next = Node(5)
# headB.next.next = shared

# intersection = get_intersection(headA, headB)
# print(f"Intersection at: {intersection.data if intersection else None}")</textarea>
                <div class="code-figure-output" id="outputex4"></div>
            </div>
            
            <!-- Exercise 5 -->
            <div class="exercise">
                <div class="exercise-title">Exercise 5: Reverse Nodes in k-Groups</div>
                <p>Write <code>reverse_k_group(head, k)</code> that reverses nodes in groups of k. If remaining nodes are less than k, leave them as is.</p>
                <p class="answer">(Answer: [1,2,3,4,5] with k=2 ‚Üí [2,1,4,3,5])</p>
            </div>
            
            <div class="code-figure">
                <div class="code-figure-header">
                    <span class="code-figure-label">Exercise 5 ‚Äî Your Solution</span>
                    <button class="code-figure-run" onclick="runCode('ex5')">‚ñ∂ Run</button>
                </div>
                <textarea id="ex5" spellcheck="false"># HINT 1: First count if there are k nodes remaining
# HINT 2: If yes, reverse k nodes
# HINT 3: Recursively process the rest
# HINT 4: Connect the reversed group to the result of recursion

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def build_list(values):
    if not values:
        return None
    head = Node(values[0])
    curr = head
    for v in values[1:]:
        curr.next = Node(v)
        curr = curr.next
    return head

def list_to_string(head):
    parts = []
    while head:
        parts.append(str(head.data))
        head = head.next
    return " -> ".join(parts)

def reverse_k_group(head, k):
    # Your code here
    pass

# Test your implementation
# head = build_list([1, 2, 3, 4, 5])
# print(f"Original: {list_to_string(head)}")
# result = reverse_k_group(head, 2)
# print(f"k=2: {list_to_string(result)}")  # 2 -> 1 -> 4 -> 3 -> 5</textarea>
                <div class="code-figure-output" id="outputex5"></div>
            </div>
        </section>

        <!-- SUBMIT SECTION -->
        <section class="submit-section">
            <h2>Submit Your Work</h2>
            <p>After completing the exercises, submit your attendance below.</p>
            
            <div class="form-row">
                <div class="form-group">
                    <label>Student ID</label>
                    <input type="text" id="studentId" placeholder="Enter your student ID">
                </div>
                <div class="form-group">
                    <label>Full Name</label>
                    <input type="text" id="studentName" placeholder="Enter your full name">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>Email (@istun.edu.tr)</label>
                    <input type="email" id="studentEmail" placeholder="your.email@istun.edu.tr">
                </div>
                <div class="form-group">
                    <label>Class Code</label>
                    <input type="text" id="classCode" placeholder="From instructor">
                </div>
            </div>
            <input type="text" id="hp" class="hp" tabindex="-1" autocomplete="off">
            <button class="submit-btn" onclick="submitWork()">Submit Attendance</button>
            <div class="submit-status" id="submitStatus"></div>
        </section>
    </main>

    <script>
        const pageLoadTime = Date.now();
        
        async function runCode(codeId) {
            const codeEl = document.getElementById(codeId);
            const outputEl = document.getElementById('output' + codeId);
            const code = codeEl.value;
            outputEl.classList.add('show');
            outputEl.textContent = 'Running...';
            
            try {
                const escaped = code.replace(/\\/g, '\\\\').replace(/"""/g, '\\"\\"\\"');
                const result = await pyscript.interpreter.runPython(`
import sys
from io import StringIO
_code = """` + escaped + `"""
_old_stdout = sys.stdout
sys.stdout = StringIO()
try:
    exec(_code)
    _output = sys.stdout.getvalue()
except Exception as e:
    _output = f"Error: {e}"
finally:
    sys.stdout = _old_stdout
_output
`);
                outputEl.textContent = result || '(no output)';
            } catch(e) {
                outputEl.textContent = 'Error: ' + e.message;
            }
        }
        
        function submitWork() {
            const status = document.getElementById('submitStatus');
            const data = {
                week: 'Week_04',
                student_id: document.getElementById('studentId').value.trim(),
                student_name: document.getElementById('studentName').value.trim(),
                student_email: document.getElementById('studentEmail').value.trim().toLowerCase(),
                classCode: document.getElementById('classCode').value.trim().toUpperCase(),
                timeOnPage: Math.floor((Date.now() - pageLoadTime) / 1000)
            };
            
            if (document.getElementById('hp').value) {
                status.textContent = 'Submission rejected.';
                status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5';
                return;
            }
            if (data.timeOnPage < 60) {
                status.textContent = 'Please spend more time reviewing the material.';
                status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5';
                return;
            }
            if (!data.student_id || !data.student_name || !data.student_email || !data.classCode) {
                status.textContent = 'All fields are required.';
                status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5';
                return;
            }
            if (!data.student_email.endsWith('@istun.edu.tr')) {
                status.textContent = 'Use your @istun.edu.tr email.';
                status.style.cssText = 'display:block;background:rgba(239,68,68,0.2);color:#fca5a5';
                return;
            }
            
            status.textContent = 'Submitting...';
            status.style.cssText = 'display:block;background:rgba(124,58,237,0.2);color:#a78bfa';
            
            fetch('https://script.google.com/macros/s/AKfycbyf1D3HGSAX4MoIhNlAuWlGrFyyvbM5MIv7ZsLxrVDlATUihrRGEAaibvIZYlCfd8Me/exec', {
                method: 'POST',
                mode: 'cors',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            })
            .then(r => r.json())
            .then(res => {
                status.textContent = res.success ? 'Submitted successfully!' : res.message;
                status.style.cssText = 'display:block;background:rgba(' + (res.success ? '74,222,128' : '239,68,68') + ',0.2);color:' + (res.success ? '#4ade80' : '#fca5a5');
            })
            .catch(() => {
                fetch('https://script.google.com/macros/s/AKfycbyf1D3HGSAX4MoIhNlAuWlGrFyyvbM5MIv7ZsLxrVDlATUihrRGEAaibvIZYlCfd8Me/exec', {
                    method: 'POST', mode: 'no-cors',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                }).then(() => {
                    status.textContent = 'Submission sent!';
                    status.style.cssText = 'display:block;background:rgba(74,222,128,0.2);color:#4ade80';
                });
            });
        }
    </script>
</body>
</html>
